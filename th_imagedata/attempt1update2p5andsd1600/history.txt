# -*- coding: utf-8 -*-
# *** Spyder Python Console History Log ***

## ---(Thu May 03 11:11:48 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
slm.move_hologram(1920,0,1024,768)
slm.zernike_coefficients = np.zeros(12)
slm.disable_gaussian_to_tophat()
slm.make_spots([[0,0,0,1]])
slm.make_spots([[10,0,0,1]])
slm.make_spots([[10,5,0,1]])
runfile('C:/local/dev/slm_interference_lithography/basic_plane_waves.py', wdir='C:/local/dev/slm_interference_lithography')
slm.make_spots([[20,0,0,1],[-20,0,0,1]])
slm.make_spots([[20,-10,0,1],[-20,-10,0,1]])
slm.make_spots([[10,-10,0,1],[-10,-10,0,1]])
slm.make_spots([[0,-10,0,1]])
slm.make_spots([[10,-10,0,1],[-10,-10,0,1]])
slm.make_spots([[10,-10,0,1],[-10,-10,0,0.5]])
slm.make_spots([[10,-10,0,1],[-10,-10,0,0.7]])
runfile('C:/local/dev/slm_interference_lithography/basic_plane_waves.py', wdir='C:/local/dev/slm_interference_lithography')
slm.make_spots([[10,-10,0,1],[-10,-10,0,0.9]])
slm.make_spots([[10,-10,0,1],[-10,-10,0,1],[2,-15,0,1]])
slm.make_spots([[10,-10,0,1],[-10,-10,0,1]])
slm.make_spots([[10,-10,0,1],[-10,-10,0,1],[2,-15,0,1]])
slm.make_spots([[0,-10,0,1]])
slm.make_spots([[20,0,0,1],[-20,0,0,1]])
slm.make_spots([[10,-10,0,1],[-10,-10,0,1]])
slm.make_spots([[0,-10,0,1]])
slm.make_spots([[10,-10,0,1],[-10,-10,0,1],[2,-15,0,1]])
runfile('C:/local/dev/slm_interference_lithography/basic_plane_waves.py', wdir='C:/local/dev/slm_interference_lithography')
slm.make_spots([[10,-10,0,1],[-10,-10,0,1]])
slm.make_spots([[0,-10,0,1]])
slm.make_spots([[10,-10,0,1],[-10,-10,0,1],[2,-15,0,1]])
slm.make_spots([[2,0,0,1],[-2,0,0,1]])
slm.move_hologram(-1024,0,1024,768)
slm.make_spots([[10,-10,0,1],[-10,-10,0,1],[2,-15,0,1]])
slm.zernike_coefficients = np.array([0,1,0,0,0,0,0,0,0,0,0,0])
slm.zernike_coefficients = np.array([0,10,0,0,0,0,0,0,0,0,0,0])
slm.make_spots([[20,-20,0,1],[-20,-20,0,1]])
slm.zernike_coefficients = np.array([0,20,0,0,0,0,0,0,0,0,0,0])
slm.zernike_coefficients = np.array([0,30,0,0,0,0,0,0,0,0,0,0])
slm.zernike_coefficients = np.array([0,35,0,0,0,0,0,0,0,0,0,0])
slm.zernike_coefficients = np.array([0,5,0,0,0,0,0,0,0,0,0,0])
slm.zernike_coefficients = np.array([0,45,0,0,0,0,0,0,0,0,0,0])
slm.blazing_function = np.linspace(0,1,32)
slm.blazing_function = blazing_function
slm.blazing_function = np.linspace(0,1,32)
slm.blazing_function = blazing_function
slm.zernike_coefficients = np.array([0,-45,0,0,0,0,0,0,0,0,0,0])
slm.blazing_function = np.linspace(0,1,32)
slm.blazing_function = blazing_function
slm.blazing_function = np.linspace(0,1,32)
slm.blazing_function = blazing_function
slm.blazing_function = np.linspace(0,1,32)
slm.blazing_function = blazing_function
slm.blazing_function = np.linspace(0,1,32)
slm.blazing_function = blazing_function
slm.zernike_coefficients = np.array([0,0,0,0,0,0,0,0,0,0,0,0])
slm.make_spots([[0,-10,0,1]])
slm.make_spots([[10,-10,0,1]])
slm.make_spots([[20,-20,0,1]])
slm.blazing_function = blazing_function
slm.blazing_function = np.linspace(0,1,32)
slm.blazing_function = blazing_function
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
slm.move_hologram(-1024,0,1024,768)
slm.zernike_coefficients = np.array([0,-45,0,0,0,0,0,0,0,0,0,0])
slm.update_gaussian_to_tophat(1900,3000, distance=distance)
slm.disable_gaussian_to_tophat()
slm.zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = np.array([0,-45,0,0,0,0,0,0,0,0,0,0])
slm.zernike_coefficients = np.array([0,-40,0,0,0,0,0,0,0,0,0,0])
slm.zernike_coefficients = np.array([0,-50,0,0,0,0,0,0,0,0,0,0])
slm.make_spots([[10,-10,0,1],[-10,-10,0,1],[2,-15,0,1]])
slm.make_spots([[10,-10,0,1],[-10,-10,0,1]])
slm.make_spots([[10,-20,0,1],[-10,-20,0,1]])
slm.make_spots([[20,-20,0,1],[-20,-20,0,1]])
slm.zernike_coefficients = np.array([0,-30,0,0,0,0,0,0,0,0,0,0])
slm.zernike_coefficients = np.array([0,-60,0,0,0,0,0,0,0,0,0,0])
slm.zernike_coefficients = np.array([0,-45,0,0,0,0,0,0,0,0,0,0])
slm.zernike_coefficients = np.array([0,-50,0,0,0,0,0,0,0,0,0,0])
slm.zernike_coefficients = np.array([0,-55,0,0,0,0,0,0,0,0,0,0])
slm.zernike_coefficients = np.array([0,-65,0,0,0,0,0,0,0,0,0,0])
slm.zernike_coefficients = np.array([0,-55,0,0,0,0,0,0,0,0,0,0])
slm.zernike_coefficients = np.array([10,-55,0,0,0,0,0,0,0,0,0,0])
slm.zernike_coefficients = np.array([10,-40,0,0,0,0,0,0,0,0,0,0])
slm.zernike_coefficients = np.array([0,-40,0,0,0,0,0,0,0,0,0,0])
slm.zernike_coefficients = np.array([0,-40,10,0,0,0,0,0,0,0,0,0])
slm.zernike_coefficients = np.array([0,-40,-10,0,0,0,0,0,0,0,0,0])
slm.zernike_coefficients = np.array([0,-40,-20,0,0,0,0,0,0,0,0,0])
slm.zernike_coefficients = np.array([0,-40,-30,0,0,0,0,0,0,0,0,0])
slm.zernike_coefficients = np.array([0,-40,-25,0,0,0,0,0,0,0,0,0])
slm.zernike_coefficients = np.array([0,-55,-25,0,0,0,0,0,0,0,0,0])
slm.update_gaussian_to_tophat(1900,3000, distance=distance)
slm.update_gaussian_to_tophat(1900,3000, distance=1000)
slm.update_gaussian_to_tophat(1900,3000, distance=2000)
slm.update_gaussian_to_tophat(2500,3000, distance=2000)
slm.update_gaussian_to_tophat(2500,3000, distance=6000)
slm.update_gaussian_to_tophat(2500,3000, distance=60000)
slm.update_gaussian_to_tophat(1900,3000, distance=1000000)

## ---(Mon Jun 04 19:07:09 2018)---
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/basic_plane_waves.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/opengl_holograms.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/basic_plane_waves.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/opengl_holograms.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/opengl_holograms.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/basic_plane_waves.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/opengl_holograms.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/basic_plane_waves.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')

## ---(Tue Jun 05 18:22:03 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/opengl_holograms.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/basic_plane_waves.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/basic_plane_waves.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/basic_plane_waves.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
help
help(slm)

## ---(Fri Jun 15 17:16:08 2018)---
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')

## ---(Fri Jun 15 19:32:54 2018)---
runfile('C:/local/dev/slm_interference_lithography/opengl_holograms.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/basic_plane_waves.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/basic_plane_waves.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/opengl_holograms.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/basic_plane_waves.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/opengl_holograms.py', wdir='C:/local/dev/slm_interference_lithography')

## ---(Fri Jun 15 19:36:41 2018)---
runfile('C:/local/dev/slm_interference_lithography/opengl_holograms.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/basic_plane_waves.py', wdir='C:/local/dev/slm_interference_lithography')
slm.make_spots([[2,0,0,1],[-20,0,0,1]])
runfile('C:/local/dev/slm_interference_lithography/opengl_holograms.py', wdir='C:/local/dev/slm_interference_lithography')

## ---(Fri Jun 15 19:50:47 2018)---
runfile('C:/local/dev/slm_interference_lithography/opengl_holograms.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/basic_plane_waves.py', wdir='C:/local/dev/slm_interference_lithography')
class VeryCleverBeamsplitter(OpenGLShaderWindow):
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/basic_plane_waves.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/opengl_holograms.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
if __name__ == "__main__":
    slm = VeryCleverBeamsplitter()
    slm.move_hologram(1920,0,1024,768)
    # set uniform values so it has a blazing function and no aberration correction
    blazing_function = np.array([  0,   0,   0,   0,   0,   0,   0,   0,   0,  12,  69,  92, 124,
       139, 155, 171, 177, 194, 203, 212, 225, 234, 247, 255, 255, 255,
       255, 255, 255, 255, 255, 255]).astype(np.float)/255.0 #np.linspace(0,1,32)
    
    slm.blazing_function = blazing_function
    slm.update_gaussian_to_tophat(1900*3/2,3000, distance=3500e3)
runfile('C:/local/dev/slm_interference_lithography/opengl_holograms.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/basic_plane_waves.py', wdir='C:/local/dev/slm_interference_lithography')
slm.make_spots([[0,-10,0,1]])
slm.make_spots([[2,0,0,1],[-20,0,0,1]])
runfile('C:/local/dev/slm_interference_lithography/basic_plane_waves.py', wdir='C:/local/dev/slm_interference_lithography')
slm.make_spots([[20,0,0,1],[-30,0,0,1]])
runfile('C:/local/dev/slm_interference_lithography/basic_plane_waves.py', wdir='C:/local/dev/slm_interference_lithography')
slm.make_spots([[1,0,0,1],[-30,0,0,1]])
slm.make_spots([[100,0,0,1],[-30,0,0,1]])
slm.make_spots([[-20,0,0,1],[-30,0,0,1]])
slm.make_spots([[0,-10,0,1]])
slm.make_spots([[10,-10,0,1],[-10,-10,0,1],[2,-15,0,1]])
slm.make_spots([[10,-10,0,1],[-10,-10,0,1]])
slm.update_gaussian_to_tophat(1900*3/2,3000, distance=3500e3)
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
slm.blazing_function = blazing_function
slm.update_gaussian_to_tophat(1900*3/2,3000, distance=3500e3)
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
slm.make_spots([[-20,0,0,1],[-30,0,0,1]])
slm.move_hologram(1920,0,1024,768)
# set uniform values so it has a blazing function and no aberration correction
blazing_function = np.array([  0,   0,   0,   0,   0,   0,   0,   0,   0,  12,  69,  92, 124,
   139, 155, 171, 177, 194, 203, 212, 225, 234, 247, 255, 255, 255,
   255, 255, 255, 255, 255, 255]).astype(np.float)/255.0 #np.linspace(0,1,32)

slm.blazing_function = blazing_function
slm.update_gaussian_to_tophat(1900*3/2,3000, distance=3500e3)
slm.make_spots([[-20,0,0,1],[-30,0,0,1]])
slm.make_spots([[-100,0,0,1],[-30,0,0,1]])
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
slm.make_spots([[-1,0,0,1],[-30,0,0,1]])
slm.make_spots([[-100,0,0,1],[-30,0,0,1]])
slm.make_spots([[-10,0,0,1],[-10,0,0,1]])
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')

## ---(Tue Jul 03 17:17:21 2018)---
runfile('C:/local/dev/slm_interference_lithography/opengl_holograms.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/opengl_holograms.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
slm.update_gaussian_to_tophat(1900*3/2,3000, distance=3500e3)
runfile('C:/local/dev/slm_interference_lithography/basic_plane_waves.py', wdir='C:/local/dev/slm_interference_lithography')
slm.make_spots([[10,-10,0,1],[-10,-10,0,1],[2,-15,0,1]])
slm.make_spots([[-20,0,0,1],[-30,0,0,1]])
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/opengl_holograms.py', wdir='C:/local/dev/slm_interference_lithography')

## ---(Tue Jul 03 18:34:47 2018)---
runfile('C:/local/dev/slm_interference_lithography/opengl_holograms.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
slm.blazing_function = blazing_function
slm.update_gaussian_to_tophat(1900*3/2,3000, distance=3500e3)
runfile('C:/local/dev/slm_interference_lithography/basic_plane_waves.py', wdir='C:/local/dev/slm_interference_lithography')
slm.update_gaussian_to_tophat(1900*3/2,3000, distance=3500e3)
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
slm.update_gaussian_to_tophat(1900*3/2,3000, distance=3500e3)
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/opengl_holograms.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/basic_plane_waves.py', wdir='C:/local/dev/slm_interference_lithography')
slm.make_spots([[-10,0,0,1],[-30,0,0,1]])
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
blazing_function = np.array([  0,   0,   0,   0,   0,   0,   0,   0,   0,  12,  69,  92, 124,
   139, 155, 171, 177, 194, 203, 212, 225, 234, 247, 255, 255, 255,
   255, 255, 255, 255, 255, 255]).astype(np.float)/255.0 #np.linspace(0,1,32)
slm.update_gaussian_to_tophat(1900*3/2,3000, distance=3500e3)
runfile('C:/local/dev/slm_interference_lithography/basic_plane_waves.py', wdir='C:/local/dev/slm_interference_lithography')
slm.make_spots([[-100,0,0,1],[-30,0,0,1]])
slm.make_spots([[-100,0,0,1],[-40,0,0,1]])
slm.make_spots([[-10,0,0,1],[-40,0,0,1]])
slm.make_spots([[10,-10,0,1],[-10,-10,0,1]])
slm.make_spots([[10,-10,0,1],[-10,-10,0,1],[2,-15,0,1]])
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
slm.move_hologram(0,0,0,0)
slm.move_hologram(1920,0,1024,768)
helo
help
help(slm.move_hologram)
slm.move_hologram(1920,0,0,1024,768)
slm.move_hologram(0,0,1024,768)
blazing_function = np.array([  0,   0,   0,   0,   0,   0,   0,   0,   0,  12,  69,  92, 124,
   139, 155, 171, 177, 194, 203, 212, 225, 234, 247, 255, 255, 255,
   255, 255, 255, 255, 255, 255]).astype(np.float)/255.0 #np.linspace(0,1,32)
runfile('C:/local/dev/slm_interference_lithography/basic_plane_waves.py', wdir='C:/local/dev/slm_interference_lithography')
slm.make_spots([[10,-10,0,1],[-10,-10,0,1]])
slm.make_spots([[-10,0,0,1],[-40,0,0,1]])
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
slm.update_gaussian_to_tophat(1900*3/2,3000, distance=300e3)
slm.update_gaussian_to_tophat(1900*3/2,3000, distance=100e3)
slm.update_gaussian_to_tophat(1900*3/2,3000, distance=10e3)
slm.update_gaussian_to_tophat(1900*3/2,3000, distance=1e3)
slm.update_gaussian_to_tophat(1900*3/2,3000, distance=3500e3)
blazing_function = np.array([  0,   0,   0,   0,   0,   0,   0,   0,   0,  12,  69,  92, 124,
   139, 155, 171, 177, 194, 203, 212, 225, 234, 247, 255, 255, 255,
   255, 255, 255, 255, 255, 255]).astype(np.float)/255.0
disable_gaussian_to_tophat
disable_gaussian_to_tophat()
def disable_gaussian_to_tophat(self):
    """Set the radial phase function to zero"""
    #self.set_uniform(4, np.zeros((384,)))
    self.radial_phase_function = np.zeros((384,))
disable_gaussian_to_tophat()
disable_gaussian_to_tophat(0)
disable_gaussian_to_tophat(self)
disable_gaussian_to_tophat(1900*3/2)
disable_gaussian_to_tophat
slm.update_gaussian_to_tophat(1900*3/2,3000, distance=3500e3)

## ---(Wed Jul 04 11:23:20 2018)---
runfile('C:/local/dev/slm_interference_lithography/opengl_holograms.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
slm.update_gaussian_to_tophat(1900*3/2,3000, distance=3500e3)
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
slm.disable_gaussian_to_tophat()
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
import nplab
nplab.current_datafile()
nplab.current_datafile(mode="r")
df = nplab.datafile.open_file(mode="r")
df = nplab.datafile.DataFile(r"C:/local/dev/slm_interference_lithography/2017-11-02a.h5", mode="r")
df = nplab.datafile.DataFile(r"C:/local/dev/slm_interference_lithography/2017-11-02.h5", mode="r")
df = nplab.datafile.DataFile(r"C:\local\dev\slm_interference_lithography\2017-11-02.h5", mode="r")
df = nplab.datafile.DataFile(r"C:\local\dev\slm_interference_lithography\2017-01-17.h5", mode="r")
df = nplab.datafile.DataFile(r"C:\local\dev\slm_interference_lithography\2016-11-12.h5", mode="r")
df.show_gui()
import uc480
import pylab as pl

runfile('C:/local/dev/slm_interference_lithography/ub480.py', wdir='C:/local/dev/slm_interference_lithography')

## ---(Mon Jul 09 14:19:39 2018)---
runfile('C:/local/dev/slm_interference_lithography/ub480.py', wdir='C:/local/dev/slm_interference_lithography')
import nplab
import nplab.instrument.camera.uc480
from nplab.instrument.camera.thorlabs_uc480 import ThorLabsCamera
cam = ThorLabsCamera()
from nplab.instrument.camera.thorlabs_uc480 import ThorLabsCamera
cam = ThorLabsCamera()
cam.show_gui()
cam.raw_snapshot()
cam.raw_image()
cam.raw_image().shape
cam.raw_image().dtype
cam.raw_image().max()
cam.raw_image().min()
import matplotlib.pyplot as plt
plt.imshow(cam.raw_image(), vmin=0, vmax=255)
cam.show_gui(blocking=False)
cam.show_gui()
plt.imshow(cam.raw_image(), vmin=0, vmax=255)
cam.show_gui(blocking=True)
plt.imshow(cam.raw_image(), vmin=0, vmax=255)
plt.imshow(cam.raw_image())
plt.imshow(cam.raw_image(), vmin=0, vmax=255)
cam.close()
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
plt
import matplotlib.pyplot
plt.imshow(cam.rgb_image())
import matplotlib.pyplot as plt
plt.imshow(cam.rgb_image())
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
plt.imshow(cam.rgb_image())
plt.imshow(cam.raw_image())
plt.imshow(cam.raw_image(),vmin=0,vmax=255)
def snap():
    cam.raw_image()
    time.sleep(0.1)
    cam.raw_image()
    return cam.raw_image()


plt.imshow(snap())

## ---(Tue Jul 10 15:17:24 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/ub480.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
cam.show_gui()
None == None
a = [1,2]
b = [1,2]
a==b
a is b
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
cam.show_gui()
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
cam.show_gui()
distance = 2325e3
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%gui qt
cam.show_gui(blocking=False)
distance = 2325e3
slm.update_gaussian_to_tophat(1900,3000, distance=distance)
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([[20,-10,0,1],[-20,-10,0,1]])
slm.move_hologram(1920*0,0,1024,768)
slm.move_hologram(1920,0,1024,768)
slm.zernike_coefficients = np.zeros(12)
slm.disable_gaussian_to_tophat()
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
slm.make_spots([[20,-10,0,1],[-20,-10,0,1]])
slm.move_hologram(1920,0,1024,768)
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%gui qt
cam.show_gui()
slm.make_spots([[20,10,0,1],[-20,10,0,1]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
test_spot = [20,10,0,1];
slm.make_spots([test_spot])
test_spot = [-20,10,0,1];
slm.make_spots([test_spot])
def snap():
    cam.gray_image()
    time.sleep(0.1)
    cam.gray_image()
    return cam.gray_image()


plt.imshow(snap)
plt.imshow(snap())
slm.make_spots([test_spot + [0,0,0.075,0]])
test_spot = [-20,10,0,1]
slm.make_spots([test_spot])
slm.make_spots([test_spot + [0,0,0.075,0]])
([test_spot + [0,0,0.075,0]])
test_spot
test_spot = [-20,10,0,1]
slm.make_spots([test_spot])
slm.make_spots([test_spot + [0,0,0.075,0]])
([test_spot + [0,0,0.075,0]])
test_spot
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%gui qt
cam.show_gui()
slm.update_gaussian_to_tophat(1900,1, distance=distance)
test_spot = [-20,10,0,1]
test_spot
([test_spot + [0,0,0.075,0]])
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
def brightest_g():
    time.sleep(0.1)
    cam.color_image()
    img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])

slm.make_spots([test_spot])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, brightest_g, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, brightest_g, dz=0.3, modes=[0,1,2])
for dz in [0.2,0.15,0.1,0.07]:
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, brightest_g, dz=0.5, modes=[1])
print zernike_coefficients
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, brightest_g, dz=0.5, modes=[1])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, brightest_g, dz=0.5, modes=[1])
print zernike_coefficients
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, brightest_g, dz=0.5, modes=[1])
brightest_g()
zernike_coefficients[1] = 0.5
slm.zernike_coefficients = zernike_coefficients
zernike_coefficients[1] = 0
slm.zernike_coefficients = zernike_coefficients
beam_sd()
brightest_g()
zernike_coefficients[1] = 0.5
slm.zernike_coefficients = zernike_coefficients
brightest_g()
beam_sd()
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.2,0.15,0.1,0.07]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)


focus_stack(50,5)
focus_stack(50,5, snap=snap)
def focus_stack(N, dz, snap=None):
    """Shift the focus (using Zernike modes) and acquire images."""
    if snap is None:
        global cam
        snap = lambda: cam.color_image()[:,:,2]
    img = snap()
    focus_stack = ArrayWithAttrs(np.zeros((N,)+img.shape, dtype=img.dtype))
    for i, d in enumerate(np.linspace(-dz,dz,N)):
        z = zernike_coefficients.copy()
        z[1] += d
        slm.zernike_coefficients = z
        focus_stack[i,:,:] = snap()
    slm.zernike_coefficients=zernike_coefficients
    plt.figure()
    plt.imshow(focus_stack[:,240,:],aspect="auto")
    focus_stack.attrs["dz"]=dz
    focus_stack.attrs["zernike_coefficients"]=zernike_coefficients
    dset = nplab.current_datafile().create_dataset("zstack_%d",data=focus_stack)
    return dset


focus_stack(50,5, snap=snap)
_
stack = _
stack.shape
plt.imshow(stack[:,512, :])
plt.imshow(stack[:,512, :], aspect="auto")
plt.imshow(stack[:,:,640], aspect="auto")
f, ax = plt.subplots(1,2)
with True:f, ax = plt.subplots(1,2)
f
ax[0].imshow(stack[:,512,540:740], aspect="auto")
ax[1].imshow(stack[:,412:612,640], aspect="auto")
f
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.25, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
stack=focus_stack(50,5, snap=snap)
f, ax = plt.subplots(1,2)
ax[0].imshow(stack[:,512,540:740], aspect="auto")
ax[1].imshow(stack[:,412:612,640], aspect="auto")
f
zernike_coefficients
zernike_coefficients[1] += 1
slm.zernike_coefficients = zernike_coefficients
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients[1] -= 1
slm.zernike_coefficients = zernike_coefficients
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
nplab.close_current_datafile()
nplab.datafile.open_file(mode="r")
df = nplab.DataFile("2018-07-10-3.h5",mode="r")
df = nplab.datafile.DataFile("2018-07-10-3.h5",mode="r")
df.show_gui()
df.close()
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
cam.show_gui()
%gui qt
cam.show_gui()
cam = ThorLabsCamera()
runfile('C:/local/dev/slm_interference_lithography/camera.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/nplab/nplab/instrument/camera/thorlabs_uc480.py', wdir='C:/local/dev/nplab/nplab/instrument/camera')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
cam.show_gui()
ax[0].imshow(stack[:,512,540:740], aspect="auto")
f, ax = plt.subplots(1,2)
ax[0].imshow(stack[:,512,540:740], aspect="auto")
stack=focus_stack(50,5, snap=snap)
test_spot = [20,-10,0,1];
distance = 2900e3
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
cam.exposure=-2
snap = calibrate_hdr()
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
cam.show_gui()
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
cam.show_gui()
plot_shack_hartmann(res)
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
test_spot = [20,-10,0,1];
test_spot = [30,-10,0,1];
test_spot = [40,-10,0,1];
test_spot = [40,-30,0,1];
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
cam.show_gui()
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)

## ---(Thu Jul 12 14:32:17 2018)---
cam.show_gui()
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
cam.show_gui()
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
cam.show_gui()
slm.update_gaussian_to_tophat(1900,3000, distance=distance)
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.disable_gaussian_to_tophat()
slm.make_spots([[20,10,0,1],[-20,10,0,1]])
test_spot = [-20,10,0,1]
slm.update_gaussian_to_tophat(1900,3000, distance=distance)
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.update_gaussian_to_tophat(1900*3/2,3000, distance=3500e3)
slm.make_spots([[20,-10,0,1],[-20,-10,0,1]])
slm.disable_gaussian_to_tophat()
test_spot = [-20,10,0,1]
slm.make_spots([test_spot])
test_spot = [20,-10,0,1];
distance = 2900e3
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot + [0,0,0.5,0]])
## TURN LIGHTS OFF!
slm.make_spots([test_spot + [0,0,0.5,0]])
test_spot = [20,-10,0,1];
distance = 2900e3
test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
cam.show_gui()
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
cam.show_gui()
test_spot = [20,-10,0,1];
distance = 2900e3
slm.make_spots([test_spot + [0,0,0.5,0]])
cam.show_gui()
slm.update_gaussian_to_tophat(1900,1, distance=distance)
cam.show_gui()
modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
cam.show_gui()
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
cam.show_gui()
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
cam.show_gui()
test_spot = [20,-10,0,1];
distance = 2900e3
slm.make_spots([test_spot + [0,0,0.075,0]])
cam.show_gui()
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
test_spot = [20,-10,0,1];
distance = 2900e3
slm.make_spots([test_spot + [0,0,0.5,0]])
cam.show_gui()
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
test_spot = [20,-10,0,1];
distance = 2900e3
slm.make_spots([test_spot + [0,0,0.5,0]])
cam.show_gui()
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
cam.show_gui()
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.5,0]])
cam.show_gui()
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.5,0]])
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
slm.make_spots([test_spot + [0,0,0.5,0]])
cam.show_gui()
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.5,0]])
cam.show_gui()
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5, pause=True)
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%gui qt
cam.show_gui()
slm.make_spots([test_spot + [0,0,0.5,0]])
test_spot = [20,-10,0,1];
distance = 2900e3
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5, pause=True)
slm.make_spots([test_spot + [0,0,0.075,0]])
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
plot_shack_hartmann(res)
flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
plot_sh_shifts(ax, m - flat, discard_edges=1)
close
df.close()

## ---(Tue Jul 17 17:24:31 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
cam.show_gui()
%gui qt
cam.show_gui()
test_spot = [20,-10,0,1];
distance = 2900e3
# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m - flat, discard_edges=1)
    
flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m - flat, discard_edges=1)
    
slm_size = 6.9
initial_r = 1.9
N = res.shape[0]
x = (np.arange(N)-(N-1)/2.0)/N * slm_size #centres of apertures
gaussian = np.exp(-x**2/initial_r**2)
gaussian /= np.mean(gaussian)
f, axes = plt.subplots(1,2)
# plot the data and a Gaussian fit
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
# plot the data and a Gaussian fit
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(x, data[:,i], '+', color=plt.cm.gist_rainbow(float(i)/N))
        m = np.polyfit(gaussian, data[:,i], 1)
        ax.plot(x, gaussian*m[0]+m[1], '-', color=plt.cm.gist_rainbow(float(i)/N))
        
f, axes = plt.subplots(1,2)
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(gaussian, data[:,i], '-+', color=plt.cm.gist_rainbow(float(i)/N))
        
r = np.sqrt(x[:,np.newaxis]**2 + x[np.newaxis,:]**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')
plt.figure()
s=slm_size/2.0
plt.imshow(res[:,:,2],extent=(-s,s,-s,s))
for thresh in [0.0,0.1,0.2,0.5,0.9]:
I = res[:,:,2].copy()
for thresh in [0.0,0.1,0.2,0.5,0.9]:
    I = res[:,:,2].copy()
    I /= np.max(I)
    I -= thresh
    I[I<0] = 0
    cx = np.sum(x[:,np.newaxis]*I)/np.sum(I)
    cy = np.sum(x[np.newaxis,:]*I)/np.sum(I)
    hide = plt.plot(cy,cx,'+')
    print "found centroid at {}, {} with threshold {}".format(cx, cy, thresh)

# pick the right values for cx and cy...
    
r = np.sqrt((x[:,np.newaxis]-cx)**2 + (x[np.newaxis,:]-cy)**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')
radii = r.flatten()
I = res[:,:,2].flatten()/I.max()*10
from scipy.interpolate import UnivariateSpline
spl = UnivariateSpline(np.concatenate([radii,-radii]), np.tile(I,2))
rr = np.linspace(0,slm_size/np.sqrt(2),100)
plt.plot(rr,spl(rr))
plt.plot(radii,I,'.')
slm.centre=(cx,cy)
slm.radial_blaze_function = np.ones(384)
inner_edge_i = 1500//18 #bad
sd = 400/18.0
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
slm.radial_blaze_function = radial_blaze_function
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function

zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)

def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))
def brightest_g():
    time.sleep(0.1)
    cam.color_image()
    img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))
def beam_sd():
    cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd
def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])
merit_function = lambda: np.mean([beam_sd() for i in range(3)])

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.2,0.15,0.1,0.07]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})

slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
focus_stack(50,5, snap=snap)
test_spot = [20,-10,0,1];
distance = 2900e3
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
focus_stack(50,5, snap=snap)
xsection = np.zeros((30,640,3),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],480,3),dtype=np.uint8)
rs = np.linspace(-5,5,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    img = cam.color_image()
    img = cam.color_image()
    xsection[i,:,:] = np.mean(img[230:250,:,:], axis=0)
    ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))
test_spot = [20,-10,0,1];
distance = 2900e3
# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
df.close()
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')

## ---(Tue Jul 17 19:49:14 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
test_spot = [20,-10,0,1];
distance = 2900e3
%gui qt
cam.show_gui()
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
%gui qt
cam.show_gui()
test_spot = [20,-10,0,1];
distance = 2900e3
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
cam.show_gui()
test_spot = [20,-10,0,1];
distance = 2900e3
# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
df.close()

## ---(Wed Jul 18 11:00:47 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%gui qt
cam.show_gui()
test_spot = [20,-10,0,1];
distance = 2900e3
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
test_spot = [20,-10,0,1];
distance = 2900e3
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
%gui qt
cam.show_gui()
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
test_spot = [20,-10,0,1];
distance = 2900e3
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
test_spot = [20,-10,0,1];
distance = 2900e3
# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
test_spot = [20,-10,0,1];
distance = 2900e3
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
test_spot = [20,-10,0,1];
distance = 2900e3
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
test_spot = [20,-10,0,1];
distance = 2900e3
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
%gui qt
cam.show_gui()
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.075,0]])
plot_shack_hartmann(res)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.075,0]])
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.2)
plot_shack_hartmann(res)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 20, overlap=0.5)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 13, overlap=0.2)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot + [0,0,0.075,0]])
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
slm.make_spots([test_spot + [0,0,0.075,0]])
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.075,0]])
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
slm.make_spots([test_spot + [0,0,0.075,0]])
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot + [0,0,0.075,0]])
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
slm.make_spots([test_spot + [0,0,0.075,0]])
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
df.close()

## ---(Tue Aug 07 16:57:11 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
slm.make_spots([[20,-10,0,1],[-20,-10,0,1]])
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%gui qt
cam.show_gui()
test_spot = [20,-10,0,1];
distance = 2900e3
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.blazing_function = blazing_function
slm.update_gaussian_to_tophat(1900*3/2,3000, distance=3500e3)
slm.make_spots([[20,-10,0,1],[-20,-10,0,1]])
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%gui qt
cam.show_gui()
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
%gui qt
cam.show_gui()
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')

## ---(Thu Aug 09 17:58:33 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%gui qt
cam.show_gui()
test_spot = [20,-10,0,1];
distance = 2900e3
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.075,0]])
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)

slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)

## ---(Tue Aug 14 14:35:32 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
help slm.move_hologram
help slm
slm.move_hologram(800,0,600,0)
slm.move_hologram(800,0,600,768)
slm.move_hologram(800,1920,600,768)
slm.move_hologram(1920,1080,800,600)
slm.make_spots([[20,10,0,1],[-20,10,0,1]])
slm.make_spots([test_spot])
slm.blazing_function = blazing_function
blazing_function = np.array([  0,   0,   0,   0,   0,   0,   0,   0,   0,  12,  69,  92, 124,
   139]).astype(np.float)/255.0 #np.linspace(0,1,32)
slm.blazing_function = blazing_function
blazing_function = np.array([12,  69,  92, 124,
   139]).astype(np.float)/25
slm.blazing_function = blazing_function
slm.update_gaussian_to_tophat(1900*3/2,3000, distance=3500e3)
slm.make_spots([20,-10,0,1])
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
slm.make_spots([20,-10,0,1])
slm.make_spots([[20,-10,0,1],[-20,-10,0,1]])
void main(){ // basic gratings and lenses for a single spot
  vec2 uv = (gl_TexCoord[0].xy - slmcentre)*slmsize;
  vec3 pos = vec3(k*uv/f, -k*dot(uv,uv)/(2.0*f*f));
  float basephase = zernikeAberration() + radialPhaseFunction(uv);
  float phase, real=0.0, imag=0.0;
  for(int i; i<2*n; i+=2){
    if(length(uv/slmsize - spots[i+1].xy) < spots[i+1][2]){
      phase = dot(pos, spots[i].xyz) + basephase;
      float amp = spots[i][3];
      real += amp * sin(phase);
      imag += amp * cos(phase);
    }
  }
main()
slm.blazing_function = blazing_function
slm.update_gaussian_to_tophat(1900*3/2,3000, distance=3500e3)
slm.make_spots([[20,-10,0,1],[-20,-10,0,1]])
runfile('C:/local/dev/slm_interference_lithography/double_slit_holograms.py', wdir='C:/local/dev/slm_interference_lithography')
slm.move_hologram(-800,0,800,600)
slm.set_chessboard(0.25,0.75,800,600)
runfile('C:/local/dev/slm_interference_lithography/double_slit_holograms.py', wdir='C:/local/dev/slm_interference_lithography')
slm.set_phases(0.5,0)
slm.set_phases(0.5,0.5)
slm.set_phases(0.5,0)
slm.set_phases(0.5,0.5)
runfile('C:/local/dev/slm_interference_lithography/double_slit_holograms.py', wdir='C:/local/dev/slm_interference_lithography')
%gui qt
cam.show_gui()
runfile('C:/local/dev/slm_interference_lithography/double_slit_holograms.py', wdir='C:/local/dev/slm_interference_lithography')
cam
slm.cycle_phases(0.1, [(0.5,p) for p in np.linspace(0,1,20)])
from threading import Thread
Thread(target=slm.cycle_phases, args=(0.1, [(0.5,p) for p in np.linspace(0,1,20)])).start()
Thread(target=slm.cycle_phases, args=(0.1, [(0.5,p) for p in np.linspace(0,1,20)], 5)).start()
slm.rects = [0,0,1,0.5,   0,0.5,1,1]
slm.rects = [0,0,0.5,1,   0.5,0,1,1]
slm.rects = [0,0,1,0.5,   0,0.5,1,1]
slm.n=0
slm.set_chessboard(0,1,40,30)
#slm.rects = [0,0.2,1,0.3,   0,0.7,1,0.8]
slm.rects = [0,0.2,1,0.3,   0,0.7,1,0.8]
slm.n=2
slm.n=0
slm.n=2
slm.n=0
slm.set_chessboard(0,0.5,40,30)
slm.set_chessboard(0,0.8,40,30)
slm.set_chessboard(0,0.9,40,30)
slm.set_chessboard(0,0.5,40,30)
slm.set_chessboard(0,0.3,40,30)
slm.set_chessboard(0,0,40,30)
slm.set_chessboard(0,1,40,30)
slm.set_chessboard(0,0.5,40,30)
slm.set_chessboard(0,0.4,40,30)
slm.set_chessboard(0,0.3,40,30)
slm.set_chessboard(0,0.45,40,30)
slm.set_chessboard(0,0.35,40,30)
slm.set_chessboard(0,0.45,40,30)
slm.set_chessboard(0,0.35,40,30)
slm.set_chessboard(0,0.37,40,30)
slm.set_chessboard(0,0.33,40,30)
slm.set_chessboard(0,0.36,40,30)
slm.set_chessboard(0,0.38,40,30)
slm.set_chessboard(0,0.37,40,30)
slm.set_chessboard(0,0.37,400,300)
slm.set_chessboard(0,0.4,400,300)
slm.set_chessboard(0,0.5,400,300)
slm.set_chessboard(0,0.6,400,300)
slm.set_chessboard(0,0.55,400,300)
slm.n=2
slm.rects = [0,0,1,0.5,   0,0.5,1,1]
#slm.rects = [0,0.2,1,0.3,   0,0.7,1,0.8]
slm.rects = [0,0.2,1,0.3,   0,0.7,1,0.8]
slm.rects = [0,0.23,1,0.27,   0,0.73,1,0.77]
slm.rects = [0,0.24,1,0.26,   0,0.74,1,0.76]
slm.rects = [0,0.34,1,0.36,   0,0.64,1,0.66]
Thread(target=slm.cycle_phases, args=(0.1, [(0.5,p) for p in np.linspace(0,1,20)], 5)).start()
slm.rects = [0,0,1,0.5,   0,0.5,1,1]
cam.gray_image()
img = cam.gray_image()
import matplotlib.pyplot as plt
plt.ion()
plt.figure()
plt.plot(np.sum(img, axis=0))
plt.plot(np.sum(img, axis=1))
plt.plot(np.sum(img, axis=1)[300:600])
image.sum(axis=2)
image = cam.gray_image()
image.sum(axis=2)
image.sum(axis=1)
image.sum(axis=0)
colsum = image.sum(axis=0)
plt.plot(colsum)
colsum = image.sum(axis=1)
plt.plot(colsum)
plot.acorr(colsum)
plt.acorr(colsum)
% FFT Process and Shift of FFT matrix.

data = colsum 
F_data = np.fft.fft2(data)

F_shift_data = np.fft.fftshift(F_data)

plt.log10(abs(F_shift_data))?
data = colsum 
F_data = np.fft.fft2(data)
F_shift_data = np.fft.fftshift(F_data)
plt.log10(abs(F_shift_data))?
data = colsum 
F_data = np.fft.fft2(data)
F_shift_data = np.fft.fftshift(F_data)
plt.log10(abs(F_shift_data))
data = colsum 
F_data = np.fft.fft2(data)
F_data = np.fft(colsum)
F_data = np.fft.fft(colsum)
plt.F_data
plt.plot(F_data)
F_shift_data = np.fft.fftshift(F_data)
plt.plot(F_shift_data)
plt.log10(abs(F_shift_data))
plt.plot(log10(abs(F_shift_data)))
plt.plot(numpy.log10(abs(F_shift_data)))
plt.plot(np.log10(abs(F_shift_data)))
find_peaks_cwt(np.log10(abs(F_shift_data)))
np.find_peaks_cwt(np.log10(abs(F_shift_data)))
import peakutils
from detect_peaks import detect_peaks
from scipy.signal import find_peaks_cwt
np.find_peaks_cwt(np.log10(abs(F_shift_data)))
find_peaks_cwt(np.log10(abs(F_shift_data)))
from peakdetect import peakdetect
Thread(target=slm.cycle_phases, args=(0.1, [(0.5,p) for p in np.linspace(0,1,20)])).start()
img = cam.gray_image()
plt.plot(np.sum(gray_image, axis=0))
plt.plot(np.sum(img, axis=0))
plt.plot(np.sum(img, axis=1))
marginal = np.sum(img, axis=1)
plt.plot(np.correlate(marginal, marginal, mode="same"))
import scipy.signal
from scipy.ndimage.filters import gaussian_filter
template = marginal - gaussian_filter(marginal, 20)
plt.plot(template)
plt.plot(np.correlate(marginal, template))
plt.plot(np.correlate(marginal, template, mode='full'))
plt.plot(np.correlate(marginal, template, mode='same'))
plt.plot(np.correlate(marginal, template, mode='full')[len(marginal):)
)
plt.plot(np.correlate(marginal, template, mode='full')[len(marginal):])
plt.plot(np.correlate(marginal, template, mode='full')[len(marginal)-1:])
plt.plot(np.correlate(marginal, template, mode='full')[len(marginal)-1:100])
plt.plot(np.correlate(marginal, template, mode='full')[len(marginal)-1:len(marginal)+100])
plt.plot(np.diff(np.correlate(marginal, template,) mode='full')[len(marginal)-1:len(marginal)+100])
plt.plot(np.diff(np.correlate(marginal, template, mode='full')[len(marginal)-1:len(marginal)+100]))
def find_zero_crossings(y):
    """Find the (interpolated) zero crossings of an array."""
    crossings = np.argwhere(y[1:]>0 != y[:-1]>0)
    return crossings


def find_zero_crossings(y):
    """Find the (interpolated) zero crossings of an array."""
    crossings = np.argwhere(y[1:]>0 != y[:-1]>0)
    return crossings


marginal = np.sum(img, axis=axis)
template = marginal - gaussian_filter(marginal,smoothing)
corr = np.correlate(marginal, template, mode="full")
axis=1
marginal = np.sum(img, axis=axis)

template = marginal - gaussian_filter(marginal,smoothing)
corr = np.correlate(marginal, template, mode="full")

smoothing = 20
marginal = np.sum(img, axis=axis)

template = marginal - gaussian_filter(marginal,smoothing)
corr = np.correlate(marginal, template, mode="full")

plt.plot(corr)
find_zero_crossings(np.diff(corr[len(marginal)-1:len(marginak)+200]))
find_zero_crossings(np.diff(corr[len(marginal)-1:len(marginal)+200]))
def find_zero_crossings(y):
    """Find the (interpolated) zero crossings of an array."""
    crossings = np.argwhere(np.not_equal(y[1:]>0, y[:-1]>0))
    return crossings


find_zero_crossings(np.diff(corr[len(marginal)-1:len(marginal)+200]))
np.not_equal(marginal[1:]>0, marginal[:-1]>0)
def find_zero_crossings(y):
    """Find the (interpolated) zero crossings of an array."""
    crossings = np.argwhere(np.not_equal(y[1:]>0, y[:-1]>0))
    subpixel_crossings = []
    for index in crossings:
        i = index[0] # we're only using 1d arrays
        fractional_shift = abs(y[i+1])/(abs(y[i])+abs(y[i+1]))
        subpixel_crossings.append(i+fractional_shift)
    return subpixel_crossings


find_zero_crossings(np.diff(corr[len(marginal)-1:len(marginal)+200]))
plt.plot(find_zero_crossings(np.diff(corr[len(marginal)-1:len(marginal)+200])))
crop=200
first_derivative = np.diff(corr[len(marginal)-1:])[0:crop]

extrema = find_zero_crossings(first_derivative) + 0.5

def find_zero_crossings(y):
    """Find the (interpolated) zero crossings of an array."""
    crossings = np.argwhere(np.not_equal(y[1:]>0, y[:-1]>0))
    subpixel_crossings = []
    for index in crossings:
        i = index[0] # we're only using 1d arrays
        fractional_shift = abs(y[i+1])/(abs(y[i])+abs(y[i+1]))
        subpixel_crossings.append(i+fractional_shift)
    return np.array(subpixel_crossings)


extrema = find_zero_crossings(first_derivative) + 0.5

np.polyfit(np.arange(len(extrema)),extrema,1)
plt.plot(extrema)
plt.plot(extrema)
x = np.arange(len(extrema)) + 1

x = np.arange(len(extrema)) + 1
m = np.polyfit(x, extrema, 1)
plt.plot(x, extrema, "r+")
plt.plot(x, m[0]*x + m[1])

m
def find_rising_zero_crossings(y):
    """Find the (interpolated) zero crossings of an array."""
    crossings = np.argwhere(np.logical_and(y[1:]>0, y[:-1]<0))
    subpixel_crossings = []
    for index in crossings:
        i = index[0] # we're only using 1d arrays
        fractional_shift = abs(y[i+1])/(abs(y[i])+abs(y[i+1]))
        subpixel_crossings.append(i+fractional_shift)
    return np.array(subpixel_crossings)


def create_template(marginal, smoothing=20):
    """Make a template to use for finding phase"""
    return marginal - gaussian_filter(marginal,smoothing)


def find_template_and_period(marginal, template, crop=200):
    corr = np.correlate(marginal, template, mode="full")
    # Corr will have a maximum at element (N-1) and is (2N-1) long.
    # We want to find peaks - so find the zero crossings of the first
    # derivative (for the first few points, we don't care about noise)
    first_derivative = np.diff(corr[len(marginal)-1:])[0:crop]
    minima = find_rising_zero_crossings(first_derivative) + 0.5
    maxima = find_rising_zero_crossings(-first_derivative) + 0.5
    # Minima and maxima always alternate - but we should maybe check...
    assert abs(len(minima) - len(maxima)) <= 1, "Maxima/minima don't match!"
    x = np.arange(len(minima) + len(maxima))/2.0
    extrema = np.zeros_like(x)
    if minima[0] < maxima[0]:
        x += 0.5
        extrema[0::2] = minima
        extrema[1::2] = maxima
    else:
        extrema[0::2] = maxima
        extrema[1::2] = minima
    m = np.polyfit(x, extrema, 1)
    #plt.plot(x, extrema, "r+")
    #plt.plot(x, m[0]*x + m[1])
    period = m[0]
    phase = m[1]/period
    return phase, period


def find_phase_and_period(marginal, template, crop=200):
    corr = np.correlate(marginal, template, mode="full")
    # Corr will have a maximum at element (N-1) and is (2N-1) long.
    # We want to find peaks - so find the zero crossings of the first
    # derivative (for the first few points, we don't care about noise)
    first_derivative = np.diff(corr[len(marginal)-1:])[0:crop]
    minima = find_rising_zero_crossings(first_derivative) + 0.5
    maxima = find_rising_zero_crossings(-first_derivative) + 0.5
    # Minima and maxima always alternate - but we should maybe check...
    assert abs(len(minima) - len(maxima)) <= 1, "Maxima/minima don't match!"
    x = np.arange(len(minima) + len(maxima))/2.0
    extrema = np.zeros_like(x)
    if minima[0] < maxima[0]:
        x += 0.5
        extrema[0::2] = minima
        extrema[1::2] = maxima
    else:
        extrema[0::2] = maxima
        extrema[1::2] = minima
    m = np.polyfit(x, extrema, 1)
    #plt.plot(x, extrema, "r+")
    #plt.plot(x, m[0]*x + m[1])
    period = m[0]
    phase = m[1]/period
    return phase, period


template = create_template(marginal)
find_phase_and_period(marginal, template)
def find_phase_and_period(marginal, template, crop=200):
    corr = np.correlate(marginal, template, mode="full")
    # Corr will have a maximum at element (N-1) and is (2N-1) long.
    # We want to find peaks - so find the zero crossings of the first
    # derivative (for the first few points, we don't care about noise)
    first_derivative = np.diff(corr[len(marginal)-1:])[0:crop]
    minima = find_rising_zero_crossings(first_derivative) + 0.5
    maxima = find_rising_zero_crossings(-first_derivative) + 0.5
    # Minima and maxima always alternate - but we should maybe check...
    assert abs(len(minima) - len(maxima)) <= 1, "Maxima/minima don't match!"
    x = np.arange(len(minima) + len(maxima))/2.0
    extrema = np.zeros_like(x)
    if minima[0] < maxima[0]:
        x += 0.5
        extrema[0::2] = minima
        extrema[1::2] = maxima
    else:
        extrema[0::2] = maxima
        extrema[1::2] = minima
    m = np.polyfit(x, extrema, 1)
    #plt.plot(x, extrema, "r+")
    #plt.plot(x, m[0]*x + m[1])
    period = m[0]
    phase = m[1] / period * 2 * np.pi
    return phase, period



find_phase_and_period(marginal, template)
plt.plot(marginal)
plt.plot(marginal[512:712])
plt.plot(marginal[514:712])
plt.plot(marginal[516:712])
plt.plot(marginal[517:712])
plt.plot(marginal[515:712])
find_phase_and_period(np.sum(cam.gray_image(),axis=1), template)
def measure_phase_throw(slm, cam, grays=np.arange(0,1,32), axis=1, repeats=5):
    """Cycle through gray levels and measure phase shift"""
    slm.set_phases(0.5,0)
    time.sleep(0.5)
    cam.gray_image()
    template = create_template(np.sum(cam.gray_image(), axis=axis))
    phases = np.zeros((len(grays), repeats))
    periods = np.zeros_like(phases)
    for i, g in enumerate(grays):
        slm.set_phases(0.5,g)
        time.sleep(0.5)
        cam.gray_image()
        for j in range(repeats):
            phases[i,j], periods[i,j] = find_phase_and_period(np.sum(cam.gray_image(),axis=1), template)
    return grays, phases, periods



grays, phases, periods = measure_phase_throw(slm, cam)
plt.plot(grays, np.mean(phases, axis=1))
grays
np.arange(0,1,32)
np.arange(0,1.0,32)
grays=np.linspace(0,1.0,32)
grays
def measure_phase_throw(slm, cam, grays=np.linspace(0,1,32), axis=1, repeats=5):
    """Cycle through gray levels and measure phase shift"""
    slm.set_phases(0.5,0)
    time.sleep(0.5)
    cam.gray_image()
    template = create_template(np.sum(cam.gray_image(), axis=axis))
    phases = np.zeros((len(grays), repeats))
    periods = np.zeros_like(phases)
    for i, g in enumerate(grays):
        slm.set_phases(0.5,g)
        time.sleep(0.5)
        cam.gray_image()
        for j in range(repeats):
            phases[i,j], periods[i,j] = find_phase_and_period(np.sum(cam.gray_image(),axis=1), template)
    return grays, phases, periods


grays, phases, periods = measure_phase_throw(slm, cam)
plt.plot(grays, np.mean(phases, axis=1))
plt.plot(grays, np.mean(phases, axis=1))
for i in range(phases.shape[1]):
    plt.plot(grays, phases[:,i], "r+")
    
grays, phases, periods = measure_phase_throw(slm, cam, grays = np.linspace(0,1,17), repeats=1)
plt.plot(grays, np.mean(phases, axis=1))
for i in range(phases.shape[1]):
    plt.plot(grays, phases[:,i], "r+")
    
grays, phases, periods = measure_phase_throw(slm, cam, grays = np.linspace(0,1,128), repeats=5)
plt.plot(grays, np.mean(phases, axis=1))
for i in range(phases.shape[1]):
    plt.plot(grays, phases[:,i], "r+")
    
def phase_throw_image(slm, cam, grays=np.linspace(0,1,32), axis=1, dt=0.1):
    marginal = np.sum(cam.gray_image(), axis=axis)
    slices = np.zeros((len(grays), len(marginal)))
    for i, g in enumerate(grays):
        slm.set_phases(0.5,g)
        time.sleep(dt)
        slices[i,:] = np.sum(cam.gray_image(), axis=axis)
    return slices


fringes = phase_throw_image(slm, cam)
plt.imshow(fringes, aspect="auto")
plt.imshow(fringes[:,400:600], aspect="auto")
plt.imshow(fringes[:,400:600], grays=np.linspace(0,1,128), aspect="auto")
fringes = phase_throw_image(slm, cam, grays=np.linspace(0,1,128))
plt.imshow(fringes[:,400:600], aspect="auto")
plt.plot(periods.flatten(), '.')
def find_rising_zero_crossings(y, fit_r=2, fit_deg=2):
    """Find the (interpolated) zero crossings of an array."""
    crossings = np.argwhere(np.logical_and(y[1:]>0, y[:-1]<0))
    subpixel_crossings = []
    for index in crossings:
        i = index[0] # we're only using 1d arrays
        if i>fit_r and i<len(y)-1-fit_r:
            cx = np.arange(i-1, i+fit_r+2, dtype=int) # crossing is between i, i+1
            fit = np.polyfit(cx, y[cx], deg=fit_deg)
            roots = np.roots(fit)
            subpixel_crossings.append(roots[np.argmin((roots-i)**2)])
        
        fractional_shift = abs(y[i+1])/(abs(y[i])+abs(y[i+1]))
        subpixel_crossings.append(i+fractional_shift)
    return np.array(subpixel_crossings)


plt.imshow(fringes)
for i in range(fringes.shape[0]):
    marginal = fringes[i,:]
    phase = find_phase_and_period(marginal, template)

first_derivative = np.diff(corr[len(marginal)-1:])[0:crop]
minima = find_rising_zero_crossings(first_derivative) + 0.5
maxima = find_rising_zero_crossings(-first_derivative) + 0.5
minima
maxima
plt.plot(minima)
plt.plot(minima,  '+')
plt.plot(maxima,  '+')
plt.plot(maxima,  '+')
plt.plot(minima, '-')

def find_rising_zero_crossings(y, fit_r=2, fit_deg=2):
    """Find the (interpolated) zero crossings of an array."""
    crossings = np.argwhere(np.logical_and(y[1:]>0, y[:-1]<0))
    subpixel_crossings = []
    for index in crossings:
        i = index[0] # we're only using 1d arrays
        if i>fit_r and i<len(y)-1-fit_r:
            cx = np.arange(i-1, i+fit_r+2, dtype=int) # crossing is between i, i+1
            fit = np.polyfit(cx, y[cx], deg=fit_deg)
            roots = np.roots(fit)
            subpixel_crossings.append(roots[np.argmin((roots-i)**2)])
        
        #fractional_shift = abs(y[i+1])/(abs(y[i])+abs(y[i+1]))
        #subpixel_crossings.append(i+fractional_shift)
    return np.array(subpixel_crossings)


phases = np.zeros((fringes.shape[0]))
for i in range(fringes.shape[0]):
    marginal = fringes[i,:]
    phases[i] = find_phase_and_period(marginal, template)
plt.imshow(fringes, aspect="auto")
plt.plot(phases, np.arange(len(phases)))

phases = np.zeros((fringes.shape[0]))
for i in range(fringes.shape[0]):
    marginal = fringes[i,:]
    phases[i], period = find_phase_and_period(marginal, template)
plt.imshow(fringes, aspect="auto")
plt.plot(phases, np.arange(len(phases)))

phases = np.zeros((fringes.shape[0]))
for i in range(fringes.shape[0]):
    marginal = fringes[i,:]
    phases[i], period = find_phase_and_period(marginal, template)
plt.imshow(fringes[:,400:600, aspect="auto")
plt.plot(phases*period/2/np.pi+100, np.arange(len(phases)))
    

    
    
    ))
phases = np.zeros((fringes.shape[0]))
for i in range(fringes.shape[0]):
    marginal = fringes[i,:]
    phases[i], period = find_phase_and_period(marginal, template)
plt.imshow(fringes[:,400:600], aspect="auto")
plt.plot(phases*period/2/np.pi+100, np.arange(len(phases)))

def find_rising_zero_crossings(y, fit_r=2, fit_deg=2):
    """Find the (interpolated) zero crossings of an array."""
    crossings = np.argwhere(np.logical_and(y[1:]>0, y[:-1]<0))
    subpixel_crossings = []
    for index in crossings:
        i = index[0] # we're only using 1d arrays
        #if i>fit_r and i<len(y)-1-fit_r:
        #    cx = np.arange(i-1, i+fit_r+2, dtype=int) # crossing is between i, i+1
        #    fit = np.polyfit(cx, y[cx], deg=fit_deg)
        #    roots = np.roots(fit)
        #    subpixel_crossings.append(roots[np.argmin((roots-i)**2)])
        
        fractional_shift = abs(y[i+1])/(abs(y[i])+abs(y[i+1]))
        subpixel_crossings.append(i+fractional_shift)
    return np.array(subpixel_crossings)


phases = np.zeros((fringes.shape[0]))
for i in range(fringes.shape[0]):
    marginal = fringes[i,:]
    phases[i], period = find_phase_and_period(marginal, template)
plt.imshow(fringes[:,400:600], aspect="auto")
plt.plot(phases*period/2/np.pi+100, np.arange(len(phases)), 'r-', lwd=3)

phases = np.zeros((fringes.shape[0]))
for i in range(fringes.shape[0]):
    marginal = fringes[i,:]
    phases[i], period = find_phase_and_period(marginal, template)
plt.imshow(fringes[:,400:600], aspect="auto")
plt.plot(phases*period/2/np.pi+100, np.arange(len(phases)), 'r-', linewidth=3)

def find_rising_zero_crossings(y, fit_r=2, fit_deg=2):
    """Find the (interpolated) zero crossings of an array."""
    crossings = np.argwhere(np.logical_and(y[1:]>0, y[:-1]<0))
    subpixel_crossings = []
    for index in crossings:
        i = index[0] # we're only using 1d arrays
        if i>fit_r and i<len(y)-1-fit_r:
            cx = np.arange(i-1, i+fit_r+2, dtype=int) # crossing is between i, i+1
            fit = np.polyfit(cx, y[cx], deg=fit_deg)
            roots = np.roots(fit)
            subpixel_crossings.append(roots[np.argmin((roots-i)**2)])
        
        #fractional_shift = abs(y[i+1])/(abs(y[i])+abs(y[i+1]))
        #subpixel_crossings.append(i+fractional_shift)
    return np.array(subpixel_crossings)


def find_rising_zero_crossings(y, fit_r=2, fit_deg=2):
    """Find the (interpolated) zero crossings of an array."""
    crossings = np.argwhere(np.logical_and(y[1:]>0, y[:-1]<0))
    subpixel_crossings = []
    for index in crossings:
        i = index[0] # we're only using 1d arrays
        if i>fit_r and i<len(y)-1-fit_r:
            cx = np.arange(i-1, i+fit_r+2, dtype=int) # crossing is between i, i+1
            fit = np.polyfit(cx, y[cx], deg=fit_deg)
            roots = np.roots(fit)
            subpixel_crossings.append(roots[np.argmin((roots-i)**2)])
        
        #fractional_shift = abs(y[i+1])/(abs(y[i])+abs(y[i+1]))
        #subpixel_crossings.append(i+fractional_shift)
    return np.array(subpixel_crossings)


def create_template(marginal, smoothing=20):
    """Make a template to use for finding phase"""
    return marginal - gaussian_filter(marginal,smoothing)


def find_phase_and_period(marginal, template, crop=200):
    corr = np.correlate(marginal, template, mode="full", crossing_args={})
    # Corr will have a maximum at element (N-1) and is (2N-1) long.
    # We want to find peaks - so find the zero crossings of the first
    # derivative (for the first few points, we don't care about noise)
    first_derivative = np.diff(corr[len(marginal)-1:])[0:crop]
    minima = find_rising_zero_crossings(first_derivative, **crossing_args) + 0.5
    maxima = find_rising_zero_crossings(-first_derivative, **crossing_args) + 0.5
    # Minima and maxima always alternate - but we should maybe check...
    assert abs(len(minima) - len(maxima)) <= 1, "Maxima/minima don't match!"
    x = np.arange(len(minima) + len(maxima))/2.0
    extrema = np.zeros_like(x)
    if minima[0] < maxima[0]:
        x += 0.5
        extrema[0::2] = minima
        extrema[1::2] = maxima
    else:
        extrema[0::2] = maxima
        extrema[1::2] = minima
    m = np.polyfit(x, extrema, 1)
    #plt.plot(x, extrema, "r+")
    #plt.plot(x, m[0]*x + m[1])
    period = m[0]
    phase = m[1] / period * 2 * np.pi
    return phase, period


phases = np.zeros((fringes.shape[0]))
for i in range(fringes.shape[0]):
    marginal = fringes[i,:]
    phases[i], period = find_phase_and_period(marginal, template, crossing_args={'fit_r':0, 'fit_deg':1})
plt.imshow(fringes[:,400:600], aspect="auto")
plt.plot(phases*period/2/np.pi+100, np.arange(len(phases)), 'r-', linewidth=3)

def find_rising_zero_crossings(y, fit_r=2, fit_deg=2):
    """Find the (interpolated) zero crossings of an array."""
    crossings = np.argwhere(np.logical_and(y[1:]>0, y[:-1]<0))
    subpixel_crossings = []
    for index in crossings:
        i = index[0] # we're only using 1d arrays
        if i>fit_r and i<len(y)-1-fit_r:
            cx = np.arange(i-1, i+fit_r+2, dtype=int) # crossing is between i, i+1
            fit = np.polyfit(cx, y[cx], deg=fit_deg)
            roots = np.roots(fit)
            subpixel_crossings.append(roots[np.argmin((roots-i)**2)])
        
        #fractional_shift = abs(y[i+1])/(abs(y[i])+abs(y[i+1]))
        #subpixel_crossings.append(i+fractional_shift)
    return np.array(subpixel_crossings)


def create_template(marginal, smoothing=20):
    """Make a template to use for finding phase"""
    return marginal - gaussian_filter(marginal,smoothing)


def find_phase_and_period(marginal, template, crop=200, crossing_args={}):
    corr = np.correlate(marginal, template, mode="full")
    # Corr will have a maximum at element (N-1) and is (2N-1) long.
    # We want to find peaks - so find the zero crossings of the first
    # derivative (for the first few points, we don't care about noise)
    first_derivative = np.diff(corr[len(marginal)-1:])[0:crop]
    minima = find_rising_zero_crossings(first_derivative, **crossing_args) + 0.5
    maxima = find_rising_zero_crossings(-first_derivative, **crossing_args) + 0.5
    # Minima and maxima always alternate - but we should maybe check...
    assert abs(len(minima) - len(maxima)) <= 1, "Maxima/minima don't match!"
    x = np.arange(len(minima) + len(maxima))/2.0
    extrema = np.zeros_like(x)
    if minima[0] < maxima[0]:
        x += 0.5
        extrema[0::2] = minima
        extrema[1::2] = maxima
    else:
        extrema[0::2] = maxima
        extrema[1::2] = minima
    m = np.polyfit(x, extrema, 1)
    #plt.plot(x, extrema, "r+")
    #plt.plot(x, m[0]*x + m[1])
    period = m[0]
    phase = m[1] / period * 2 * np.pi
    return phase, period


phases = np.zeros((fringes.shape[0]))
for i in range(fringes.shape[0]):
    marginal = fringes[i,:]
    phases[i], period = find_phase_and_period(marginal, template, crossing_args={'fit_r':0, 'fit_deg':1})
plt.imshow(fringes[:,400:600], aspect="auto")
plt.plot(phases*period/2/np.pi+100, np.arange(len(phases)), 'r-', linewidth=3)

create_dataset()
nplab.create_dataset()
nplab.current_datafile()
nplab.create_datafile()
df.new_group("test", "test")
df.newgroup("test", "test")
import data_file
nplab.current_datafile().create_dataset("test",data=phases)
data
nplab.current_datafile().create_dataset("Phases", data=phases)
nplab.current_datafile().create_dataset("Period", period)
nplab.current_datafile().create_dataset("Plot", outplot = plt.plot(phases*period/2/np.pi+100, np.arange(len(phases)), 'r-', linewidth=3))
nplab.current_datafile().create_dataset("Phases", data=phases)
nplab.current_datafile().create_dataset("Period", data = period)
nplab.current_datafile().create_dataset("Plot", outplot = plt.plot(phases*period/2/np.pi+100, np.arange(len(phases)), 'r-', linewidth=3))

nplab.current_datafile().create_dataset("Plot", data = plt.plot(phases*period/2/np.pi+100, np.arange(len(phases)), 'r-', linewidth=3))
fringes
plot(fringes)
plt.plot(fringes)
plt.imshow(fringes)
get_qt_ui()
nplab.get_qt_ui()
import h5py 
phases = np.zeros((fringes.shape[0]))
for i in range(fringes.shape[0]):
    marginal = fringes[i,:]
    phases[i], period = find_phase_and_period(marginal, template, crossing_args={'fit_r':0, 'fit_deg':1})

plt.imshow(fringes[:,400:600], aspect="auto")
plt.plot(phases*period/2/np.pi+100, np.arange(len(phases)), 'r-', linewidth=3)
axis
runfile('C:/local/dev/slm_interference_lithography/double_slit_holograms.py', wdir='C:/local/dev/slm_interference_lithography')
%gui qt
cam.show_gui()
cam.exposure=5
df
data_group = df.create_group("phase_sweep_%d")
gray_levels = np.linspace(0,1,256)
data_group['gray_levels'] = gray_levels

img = cam.gray_image()
marginal = np.sum(img, axis=1)
template = create_template(marginal)
data_group['template'] = template
data_group['template'].attrs['description'] = "We correlate this against the marginal distribution of the images"
data_group['template_image'] = img
data_group['template_image'].attrs['description'] = "This is the image that the template is generated from"

fringes = phase_throw_image(slm, cam, grays=gray_levels)
data_group['marginals_vs_gray'] = fringes
data_group['marginals_vs_gray'].attrs['description'] = "Each row is the marginal distribution of the image for each gray level"

phases = np.zeros((fringes.shape[0]))
for i in range(fringes.shape[0]):
    marginal = fringes[i,:]
    phases[i], period = find_phase_and_period(marginal, template, crossing_args={'fit_r':0, 'fit_deg':1})

plt.imshow(fringes[:,400:600], aspect="auto")
plt.plot(phases*period/2/np.pi+100, np.arange(len(phases)), 'r-', linewidth=3)
grays, phases, periods = measure_phase_throw(slm, cam, grays=gray_levels, axis=1, repeats=5)
data_group['phases'] = phases
data_group['phases'].attrs['description'] = "5 measurements of phase for each gray level, in radians"
data_group['periods'] = periods
plt.figure()
plt.plot(grays, np.mean(phases, axis=1), '-')
for i in range(phases.shape[1]):
    plt.plot(grays, phases[:,i], '.')


def find_rising_zero_crossings(y, fit_r=0, fit_deg=1):
    """Find the (interpolated) zero crossings of an array."""
    crossings = np.argwhere(np.logical_and(y[1:]>0, y[:-1]<0))
    subpixel_crossings = []
    for index in crossings:
        i = index[0] # we're only using 1d arrays
        if i>fit_r and i<len(y)-1-fit_r:
            cx = np.arange(i-1, i+fit_r+2, dtype=int) # crossing is between i, i+1
            fit = np.polyfit(cx, y[cx], deg=fit_deg)
            roots = np.roots(fit)
            subpixel_crossings.append(roots[np.argmin((roots-i)**2)])
        
        #fractional_shift = abs(y[i+1])/(abs(y[i])+abs(y[i+1]))
        #subpixel_crossings.append(i+fractional_shift)
    return np.array(subpixel_crossings)


data_group = df.create_group("phase_sweep_%d")
gray_levels = np.linspace(0,1,256)
data_group['gray_levels'] = gray_levels

img = cam.gray_image()
marginal = np.sum(img, axis=1)
template = create_template(marginal)
data_group['template'] = template
data_group['template'].attrs['description'] = "We correlate this against the marginal distribution of the images"
data_group['template_image'] = img
data_group['template_image'].attrs['description'] = "This is the image that the template is generated from"

fringes = phase_throw_image(slm, cam, grays=gray_levels)
data_group['marginals_vs_gray'] = fringes
data_group['marginals_vs_gray'].attrs['description'] = "Each row is the marginal distribution of the image for each gray level"
phases = np.zeros((fringes.shape[0]))
for i in range(fringes.shape[0]):
    marginal = fringes[i,:]
    phases[i], period = find_phase_and_period(marginal, template, crossing_args={'fit_r':0, 'fit_deg':1})

plt.imshow(fringes[:,400:600], aspect="auto")
plt.plot(phases*period/2/np.pi+100, np.arange(len(phases)), 'r-', linewidth=3)
phases = np.zeros((fringes.shape[0]))
for i in range(fringes.shape[0]):
    marginal = fringes[i,:]
    phases[i], period = find_phase_and_period(marginal, template, crossing_args={'fit_r':2, 'fit_deg':2})

plt.imshow(fringes[:,400:600], aspect="auto")
plt.plot(phases*period/2/np.pi+100, np.arange(len(phases)), 'r-', linewidth=3)
plt.plot(gray_levels, phases)
phases = np.zeros((fringes.shape[0]))
pa = np.zeros_like(phases)
for i in range(fringes.shape[0]):
    marginal = fringes[i,:]
    phases[i], period = find_phase_and_period(marginal, template, crossing_args={'fit_r':0, 'fit_deg':1})
    pa[i], period = find_phase_and_period(marginal, template, crossing_args={'fit_r':2, 'fit_deg':2})


plt.plot(gray_levels, phases)
plt.plot(gray_levels, pa)

plt.plot(phases, pa)
plt.plot(phases % 2*np.pi, pa % 2*np.pi)
plt.plot(phases % 2*np.pi, pa % 2*np.pi, '.')
grays, phases, periods = measure_phase_throw(slm, cam, grays=gray_levels, axis=1, repeats=5)
data_group['phases'] = phases
data_group['phases'].attrs['description'] = "5 measurements of phase for each gray level, in radians"
data_group['periods'] = periods
plt.figure()
for i in range(phases.shape[1]):
    plt.plot(grays, phases[:,i], '.')

plt.plot(grays, np.mean(phases, axis=1), '-')
plt.plot(grays, np.mean(phases, axis=1))
data_group.attrs['SLM'] = "Hamamatsu"
data_group.attrs['laser'] = "HeNe"
df.close()
df = nplab.datafile.File("2018-08-15.h5", mode="r")
df = nplab.datafile.DataFile("2018-08-15.h5", mode="r")
df.keys()
g = df['phase_sweep_2']
g.attrs.items()
g.items()
plt.plot(g['gray_levels'], np.mean(g['phases'], axis=1))
plt.imshow(g['template_image'])
np.min(phases)
np.max(phases)
np.cumsum([1,2,3,4])
np.concatenate((np.array([1,2,3]), np.array([4,5,6])))
def unwrap_phase(y):
    """Remove phase wraps from a 1D array of phase values"""
    dy = np.diff(y)
    while np.any(np.abs(dy) > np.pi):
        dy[dy > np.pi] -= 2*np.pi
        dy[dy < -np.pi] += 2*np.pi
    return np.concatenate((np.array([y[0]]), np.cumsum(dy)+y[0]))


plt.plot(g['gray_levels'], unwrap_phase(np.mean(g['phases'], axis=1)))
def unwrap_phase(y):
    """Remove phase wraps from a 1D array of phase values"""
    dy = np.diff(y)
    while np.any(np.abs(dy) > np.pi):
        dy[dy > np.pi] -= 2*np.pi
        dy[dy < -np.pi] += 2*np.pi
    # np.cumsum doesn't prepend a zero (which would undo np.diff more neatly)
    # hence prepending an extra element.
    return np.concatenate((np.array([0]), np.cumsum(dy))) + y[0]


def lookup_table_from_phases(grays, phases, plot=False):
    """Return a 32-element look up table based on a phase measurement."""
    unwrapped_phases = np.zeros_like(phases)
    for i in range(phases.shape[1]):
        unwrapped_phases[:,i] = unwrap_phase(phases[:,i])
    phase = np.mean(unwrapped_phases, axis=1)
    phase -= np.mean(phase)
    
    gradient = np.polyfit(grays, phases)[0]
    phase_sd = np.mean(np.diff(phase)**2)**0.5
    gray_sd = phase_sd/gradient
    
    lut_phase = np.linspace(-np.pi,np.pi,32)
    spline = UnivariateSpline(phase, grays, w=np.ones_like(grays)/gray_sd, k=3, ext="const")
    
    if(plot):
        plt.plot(phase, grays, '+')
        plt.plot(phase, spline(phase), '-')
        plt.plot(lut_phase, spline(lut_phase), 'o')
    
    return lut_phase, spline(lut_phase)


p, g = lookup_table_from_phases(g['gray_levels'], g['phases'], plot=True)
def lookup_table_from_phases(grays, phases, plot=False):
    """Return a 32-element look up table based on a phase measurement."""
    unwrapped_phases = np.zeros_like(phases)
    for i in range(phases.shape[1]):
        unwrapped_phases[:,i] = unwrap_phase(phases[:,i])
    phase = np.mean(unwrapped_phases, axis=1)
    phase -= np.mean(phase)
    
    gradient = np.polyfit(grays, phases, 1)[0]
    phase_sd = np.mean(np.diff(phase)**2)**0.5
    gray_sd = phase_sd/gradient
    
    lut_phase = np.linspace(-np.pi,np.pi,32)
    spline = UnivariateSpline(phase, grays, w=np.ones_like(grays)/gray_sd, k=3, ext="const")
    
    if(plot):
        plt.plot(phase, grays, '+')
        plt.plot(phase, spline(phase), '-')
        plt.plot(lut_phase, spline(lut_phase), 'o')
    
    return lut_phase, spline(lut_phase)


p, g = lookup_table_from_phases(g['gray_levels'], g['phases'], plot=True)
from scipy.interpolate import UnivariateSpline
p, g = lookup_table_from_phases(g['gray_levels'], g['phases'], plot=True)
g['gray_levels'].shape
print("phase shape: {}".format(phase.shape))
def lookup_table_from_phases(grays, phases, plot=False):
    """Return a 32-element look up table based on a phase measurement."""
    unwrapped_phases = np.zeros_like(phases)
    for i in range(phases.shape[1]):
        unwrapped_phases[:,i] = unwrap_phase(phases[:,i])
    phase = np.mean(unwrapped_phases, axis=1)
    phase -= np.mean(phase)
    
    gradient = np.polyfit(grays, phases, 1)[0]
    phase_sd = np.mean(np.diff(phase)**2)**0.5
    gray_sd = phase_sd/gradient
    
    lut_phase = np.linspace(-np.pi,np.pi,32)
    print("phase shape: {}".format(phase.shape))
    print("grays shape: {}".format(grays.shape))
    
    spline = UnivariateSpline(phase, grays, w=np.ones_like(grays)/gray_sd, k=3, ext="const")
    
    if(plot):
        plt.plot(phase, grays, '+')
        plt.plot(phase, spline(phase), '-')
        plt.plot(lut_phase, spline(lut_phase), 'o')
    
    return lut_phase, spline(lut_phase)


p, g = lookup_table_from_phases(g['gray_levels'], g['phases'], plot=True)
phases = g['phases']
grays = g['gray_levels']
unwrapped_phases = np.zeros_like(phases)
for i in range(phases.shape[1]):
    unwrapped_phases[:,i] = unwrap_phase(phases[:,i])

phase = np.mean(unwrapped_phases, axis=1)
phase -= np.mean(phase)

gradient = np.polyfit(grays, phases, 1)[0]
phase_sd = np.mean(np.diff(phase)**2)**0.5
gray_sd = phase_sd/gradient
lut_phase = np.linspace(-np.pi,np.pi,32)
print("phase shape: {}".format(phase.shape))
print("grays shape: {}".format(grays.shape))
spline = UnivariateSpline(phase, grays, w=np.ones_like(grays)/gray_sd, k=3, ext="const")
spline = UnivariateSpline(phase, grays, k=3, ext="const")
def lookup_table_from_phases(grays, phases, plot=False):
    """Return a 32-element look up table based on a phase measurement."""
    unwrapped_phases = np.zeros_like(phases)
    for i in range(phases.shape[1]):
        unwrapped_phases[:,i] = unwrap_phase(phases[:,i])
    phase = np.mean(unwrapped_phases, axis=1)
    phase -= np.mean(phase)
    
    gradient = np.polyfit(grays, phases, 1)[0]
    phase_sd = np.mean(np.diff(phase)**2)**0.5
    gray_sd = phase_sd/gradient
    
    lut_phase = np.linspace(-np.pi,np.pi,32)
    print("phase shape: {}".format(phase.shape))
    print("grays shape: {}".format(grays.shape))
    
    sort_indices = np.argsort(phase)
    
    spline = UnivariateSpline(phase[sort_indices], grays[sort_indices], w=np.ones_like(grays)/gray_sd, k=3, ext="const")
    
    if(plot):
        plt.plot(phase, grays, '+')
        plt.plot(phase, spline(phase), '-')
        plt.plot(lut_phase, spline(lut_phase), 'o')
    
    return lut_phase, spline(lut_phase)


spline = UnivariateSpline(phase, grays, k=3, ext="const")
sort_indices = np.argsort(phase)
np.any(np.diff(phases)>0)
np.any(np.diff(phases)<0)
np.any(np.diff(phases[sort_indices])<0)
sort_indices
phase[sort_indices]
np.any(np.diff(phases[sort_indices])<0)
phases = np.array(phases)
phase[sort_indices]
np.any(np.diff(phase[sort_indices])<0)
def lookup_table_from_phases(grays, phases, plot=False):
    """Return a 32-element look up table based on a phase measurement."""
    unwrapped_phases = np.zeros_like(phases)
    for i in range(phases.shape[1]):
        unwrapped_phases[:,i] = unwrap_phase(phases[:,i])
    phase = np.mean(unwrapped_phases, axis=1)
    phase -= np.mean(phase)
    
    gradient = np.polyfit(grays, phases, 1)[0]
    phase_sd = np.mean(np.diff(phase)**2)**0.5
    gray_sd = phase_sd/gradient
    
    lut_phase = np.linspace(-np.pi,np.pi,32)
    print("phase shape: {}".format(phase.shape))
    print("grays shape: {}".format(grays.shape))
    
    sort_indices = np.argsort(phase)
    
    spline = UnivariateSpline(phase[sort_indices], grays[sort_indices], w=np.ones_like(grays)/gray_sd, k=3, ext="const")
    
    if(plot):
        plt.plot(phase, grays, '+')
        plt.plot(phase, spline(phase), '-')
        plt.plot(lut_phase, spline(lut_phase), 'o')
    
    return lut_phase, spline(lut_phase)


p, g = lookup_table_from_phases(g['gray_levels'], g['phases'], plot=True)
def lookup_table_from_phases(grays, phases, plot=False):
    """Return a 32-element look up table based on a phase measurement."""
    unwrapped_phases = np.zeros_like(phases)
    for i in range(phases.shape[1]):
        unwrapped_phases[:,i] = unwrap_phase(phases[:,i])
    phase = np.mean(unwrapped_phases, axis=1)
    phase -= np.mean(phase)
    
    gradient = np.polyfit(grays, phases, 1)[0]
    phase_sd = np.mean(np.diff(phase)**2)**0.5
    gray_sd = phase_sd/gradient
    
    lut_phase = np.linspace(-np.pi,np.pi,32)
    print("phase shape: {}".format(phase.shape))
    print("grays shape: {}".format(grays.shape))
    
    sort_indices = np.argsort(phase)
    
    spline = UnivariateSpline(phase[sort_indices], np.array(grays)[sort_indices], w=np.ones_like(grays)/gray_sd, k=3, ext="const")
    
    if(plot):
        plt.plot(phase, grays, '+')
        plt.plot(phase, spline(phase), '-')
        plt.plot(lut_phase, spline(lut_phase), 'o')
    
    return lut_phase, spline(lut_phase)


p, g = lookup_table_from_phases(g['gray_levels'], g['phases'], plot=True)
sort_indices = np.argsort(phase)
spline = UnivariateSpline(phase[sort_indices], np.array(grays)[sort_indices], w=np.ones_like(grays)/gray_sd, k=3, ext="const")
phase[sort_indices]
phase[sort_indices].shape
np.array(grays)[sort_indices]
np.array(grays)[sort_indices].shape
spline = UnivariateSpline(phase[sort_indices], np.array(grays)[sort_indices], w=np.ones_like(grays)/gray_sd, k=3, ext="const")
spline = UnivariateSpline(phase[sort_indices], np.array(grays)[sort_indices])
spline = UnivariateSpline(phase[sort_indices], np.array(grays)[sort_indices],w=np.ones_like(grays))
spline = UnivariateSpline(phase[sort_indices], np.array(grays)[sort_indices],w=np.ones_like(grays)/gray_sd)
gray_sd
def lookup_table_from_phases(grays, phases, plot=False):
    """Return a 32-element look up table based on a phase measurement."""
    unwrapped_phases = np.zeros_like(phases)
    for i in range(phases.shape[1]):
        unwrapped_phases[:,i] = unwrap_phase(phases[:,i])
    phase = np.mean(unwrapped_phases, axis=1)
    phase -= np.mean(phase)
    
    gradient = np.polyfit(grays, phase, 1)[0]
    phase_sd = np.mean(np.diff(phase)**2)**0.5
    gray_sd = phase_sd/gradient
    
    lut_phase = np.linspace(-np.pi,np.pi,32)
    print("phase shape: {}".format(phase.shape))
    print("grays shape: {}".format(grays.shape))
    
    sort_indices = np.argsort(phase)
    
    spline = UnivariateSpline(phase[sort_indices], np.array(grays)[sort_indices], w=np.ones_like(grays)/gray_sd, k=3, ext="const")
    
    if(plot):
        plt.plot(phase, grays, '+')
        plt.plot(phase, spline(phase), '-')
        plt.plot(lut_phase, spline(lut_phase), 'o')
    
    return lut_phase, spline(lut_phase)


p, g = lookup_table_from_phases(g['gray_levels'], g['phases'], plot=True)
def lookup_table_from_phases(grays, phases, plot=False):
    """Return a 32-element look up table based on a phase measurement."""
    unwrapped_phases = np.zeros_like(phases)
    for i in range(phases.shape[1]):
        unwrapped_phases[:,i] = unwrap_phase(phases[:,i])
    phase = np.mean(unwrapped_phases, axis=1)
    phase -= np.mean(phase)
    
    gradient = np.polyfit(grays, phase, 1)[0]
    phase_sd = np.mean(np.diff(phase-grays*gradient)**2)**0.5
    gray_sd = phase_sd/gradient
    
    lut_phase = np.linspace(-np.pi,np.pi,32)
    print("phase shape: {}".format(phase.shape))
    print("grays shape: {}".format(grays.shape))
    
    sort_indices = np.argsort(phase)
    
    spline = UnivariateSpline(phase[sort_indices], np.array(grays)[sort_indices], w=np.ones_like(grays)/gray_sd, k=3, ext="const")
    
    if(plot):
        plt.plot(phase, grays, '+')
        plt.plot(phase, spline(phase), '-')
        plt.plot(lut_phase, spline(lut_phase), 'o')
    
    return lut_phase, spline(lut_phase)


p, g = lookup_table_from_phases(g['gray_levels'], g['phases'], plot=True)
def lookup_table_from_phases(grays, phases, plot=False):
    """Return a 32-element look up table based on a phase measurement."""
    grays = np.array(grays)
    unwrapped_phases = np.zeros_like(phases)
    for i in range(phases.shape[1]):
        unwrapped_phases[:,i] = unwrap_phase(phases[:,i])
    phase = np.mean(unwrapped_phases, axis=1)
    phase -= np.mean(phase)
    
    gradient = np.polyfit(grays, phase, 1)[0]
    phase_sd = np.mean(np.diff(phase-grays*gradient)**2)**0.5
    gray_sd = phase_sd/gradient
    
    lut_phase = np.linspace(-np.pi,np.pi,32)
    print("phase shape: {}".format(phase.shape))
    print("grays shape: {}".format(grays.shape))
    
    sort_indices = np.argsort(phase)
    
    spline = UnivariateSpline(phase[sort_indices], grays[sort_indices], w=np.ones_like(grays)/gray_sd, k=3, ext="const")
    
    if(plot):
        plt.plot(phase, grays, '+')
        plt.plot(phase, spline(phase), '-')
        plt.plot(lut_phase, spline(lut_phase), 'o')
    
    return lut_phase, spline(lut_phase)


p, g = lookup_table_from_phases(g['gray_levels'], g['phases'], plot=True)
grays = np.array(grays)
unwrapped_phases = np.zeros_like(phases)
for i in range(phases.shape[1]):
    unwrapped_phases[:,i] = unwrap_phase(phases[:,i])

phase = np.mean(unwrapped_phases, axis=1)
phase -= np.mean(phase)

gradient = np.polyfit(grays, phase, 1)[0]
phase_sd = np.mean(np.diff(phase-grays*gradient)**2)**0.5
gray_sd = phase_sd/gradient

lut_phase = np.linspace(-np.pi,np.pi,32)
print("phase shape: {}".format(phase.shape))
print("grays shape: {}".format(grays.shape))

gray_sd
lut_phase = np.linspace(-np.pi,np.pi,32)
sort_indices = np.argsort(phase)
spline = UnivariateSpline(phase[sort_indices], grays[sort_indices], w=np.ones_like(grays)/gray_sd, k=3, ext="const")
plt.plot(phase, grays, '+')
plt.plot(phase, spline(phase), '-')
plt.plot(lut_phase, spline(lut_phase), 'o')

def lookup_table_from_phases(grays, phases, plot=False):
    """Return a 32-element look up table based on a phase measurement."""
    grays = np.array(grays)
    unwrapped_phases = np.zeros_like(phases)
    for i in range(phases.shape[1]):
        unwrapped_phases[:,i] = unwrap_phase(phases[:,i])
    phase = np.mean(unwrapped_phases, axis=1)
    phase -= np.mean(phase)
    
    gradient = np.polyfit(grays, phase, 1)[0]
    phase_sd = np.mean(np.diff(phase-grays*gradient)**2)**0.5
    gray_sd = phase_sd/gradient
    
    lut_phase = np.linspace(-np.pi,np.pi,32)
    sort_indices = np.argsort(phase)
    spline = UnivariateSpline(phase[sort_indices], grays[sort_indices], w=np.ones_like(grays)/gray_sd, k=3, ext="const")
    
    if(plot):
        plt.plot(phase, grays, '+')
        plt.plot(phase, spline(phase), '-')
        plt.plot(lut_phase, spline(lut_phase), 'o')
    
    return lut_phase, spline(lut_phase)


p, g = lookup_table_from_phases(g['gray_levels'], g['phases'], plot=True)
p, g = lookup_table_from_phases(grays, phases, plot=True)
grays
phases.shape
LUT = lookup_table_from_phases(g['gray_levels'], g['phases'], plot=True)
g = df['phase_sweep_2']
LUT = lookup_table_from_phases(g['gray_levels'], g['phases'], plot=True)
np.savez("hamamatsu_633_lut.npz", phases=LUT[0], grays=LUT[1])
f = np.load("hamamatsu_633_lut.npz")
f['grays']
df.close()
cam.close()
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%gui qt
cam.show_gui(blocking=False)
from measure_orders import POIManager, sum_rois
m = POIManager(cam)
test_spot = [-10,5,0,1]
slm.make_spots([test_spot])
m.labels = ["-3","-2","-2","0","1","2","3"]
m.labels = ["-3","-2","-1","0","1","2","3"]
m.positions
pos = m.positions
m.positions = [(0,0)] + pos
m.positions = pos
m.box_size=(60,60)
m.box_size=(100,100)
m.slices
list(m.slices)
img = snap()
sum_rois(img, m)
plt.plot(sum_rois(img, m))
plt.plot(sum_rois(snap(), m))
plt.plot(sum_rois(snap(), m), log='y')
plt.plot(sum_rois(snap(), m), logy=True)
plt.plot(sum_rois(snap(), m), log_y=True)
plt.plot(sum_rois(snap(), m), ylog=True)
plt.semilogy(sum_rois(snap(), m))
df.items()
df['ThorLabsCamera'].items()
df['ThorLabsCamera'].values()[0]
df['ThorLabsCamera'].values()[0].attrs
df['ThorLabsCamera'].values()[0].attrs.items()
slm.make_spots([40,0,0,0])
slm.make_spots([[40,0,0,0]])
slm.make_spots([[4,0,0,0]])
slm.make_spots([[4,0,0,1]])
slm.make_spots([[40,0,0,1]])
slm.make_spots([[10,0,0,1]])
slm.make_spots([[40,0,0,1]])
slm.make_spots([[10,0,0,1]])
slm.make_spots([[40,0,0,1]])
for e in [0.066, 0.1, 1, 10, 100]:
    cam.exposure = e
    time.sleep(0.5)
    g.create_dataset("exposure_%d", data=cam.gray_image())

g = df.create_group("test_hdr_stack")
for e in [0.066, 0.1, 1, 10, 100]:
    
    cam.exposure = e
    time.sleep(0.5)
    g.create_dataset("exposure_%d", data=cam.gray_image())
    
g.items()
g.values()[0].atrs
g.values()[0].attrs.items()
for e in [0.066, 0.1, 1, 10, 100]:
    cam.exposure = e
    time.sleep(0.5)
    g.create_dataset("exposure_%d", data=cam.gray_image(), attrs=cam.metadata)
    
g.values()[-1].attrs.items()
g.attrs['spots'] = [[40,0,0,1]]
g.attrs['spots']
slm.make_spots([[0,0,0,1]])
%gui qt
cam.show_gui(blocking=False)

## ---(Mon Aug 20 10:15:46 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
cam.exposure = 1
%gui qt
cam.show_gui(blocking=False)
cam.exposure = 1
cam.exposure = 50
snap
hdr = snap()
imshow(hdr)
hdr
matplotlib.pyplot.imshow(hdr)
plt.pyplot.imshow(hdr)
plt.imshow(hdr)
for i in range(1, 100)
for i in range(1, 100) print i
for i in range(1,100)
    print i


for i in range(1,100):
    print i


for i in range(1,100,4):
    print i


for i in range(1,100,4):
    print i*0.1


for i in range(1,1000,4):
    print i*0.1


for i in range(1,1000,10):
    print i*0.1


for i in range(1,1000,20):
    print i*0.1


len(range(1,1000,20))
len(range(1,1000,40))
for i in range(1,1000,40):
    cam.exposure = i
    hdr = snap()
    plt.imshow(hdr)


time.sleep(i)
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
for i in range(1,100,40):
    cam.exposure = i
    hdr = snap()
    #time.sleep(i)
    plt.imshow(hdr)


np.save(hdr)
np.save(test,hdr)
np.save(open(output_file, "w"), hdr)
np.save(open(path + 'test.npy', "w"), hdr)
np.savetxt('file.out', hdr, delimiter=',')
np.loadtext('file.out', test)
np.save('filename.npy', hdr)
testarray = np.load('filename.npy')
plt.imshow(testarray)
np.save('/hdrimagedata/filename.npy', hdr)
np.save('\hdrimagedata\filename.npy', hdr)
testarray = np.load('filename%d.npy', i)
testarray = np.load('filename%d.npy' %i)
testarray = np.save('filename%d.npy' %i)
np.save('filename%d.npy' %i,hdr)
np.save('hdrdata_HeNe_hamatsu_%d.npy' %i,hdr)
for i in range(1,100,40):
    cam.exposure = i*0.1
    hdr = snap()
    time.sleep(i*0.1)
    np.save('hdrdata_HeNe_hamatsu_exp%d.npy' %i,hdr)


for i in range(1,100,20):
    cam.exposure = i*0.1
    hdr = snap()
    print i*0.1


for i in range(1,1000,20):
    cam.exposure = i*0.1
    hdr = snap()
    print i*0.1


count = 1
for i in range(1,1000,30):
    cam.exposure = i*0.1
    hdr = snap()
    count += 1
    print count
    #time.sleep(i*0.1)


count = 1
for i in range(0.1,90,0.5):
    cam.exposure = i
    hdr = snap()
    count += 1


count = 1
for i in range(1,90,5):
    cam.exposure = i*0.1
    hdr = snap()
    count += 1
    #time.sleep(i*0.1)


count
i*0.1
count = 1
for i in range(1,100,5):
    cam.exposure = i*0.1
    hdr = snap()
    count += 1


count
count = 1
for i in range(1,1000,5):
    cam.exposure = i*0.1
    hdr = snap()
    count += 1


count
count = 1
for i in range(1,500,10):
    cam.exposure = i*0.1
    hdr = snap()
    count += 1


count
count = 1
for i in range(1,500,10):
    cam.exposure = i*0.1
    hdr = snap()
    count += 1
    print i*0.1


count = 1
for i in range(1,500,7):
    cam.exposure = i*0.1
    hdr = snap()
    count += 1
    print i*0.1


count = 1
for i in range(1,50):
    cam.exposure = 2*i*0.1
    hdr = snap()
    count += 1
    print 2*i*0.1
    #time.sleep(2*i*0.1)


count = 1
for i in range(1,50):
    cam.exposure = 4*i*0.1
    hdr = snap()
    count += 1
    print 4*i*0.1
    #time.sleep(4*i*0.1)


count = 1
for i in range(1,50):
    exptime = 4*i*0.1
    cam.exposure = exptime
    hdr = snap()
    count += 1
    print exptime
    time.sleep(exptime)
    #np.save('hdrdata_HeNe_hamatsu_exp%d.npy' %i,hdr)


count = 1
for i in range(1,10):
    exptime = 2*i*0.1
    cam.exposure = exptime
    hdr = snap()
    count += 1
    print exptime //


count = 1
for i in range(1,10):
    exptime = 2*i*0.1
    cam.exposure = exptime
    hdr = snap()
    count += 1
    print exptime\\


count = 1
for i in range(1,10):
    exptime = 2*i*0.1
    cam.exposure = exptime
    hdr = snap()
    count += 1
    print exptime\
    time.sleep(exptime)


count = 1
for i in range(1,10):
    exptime = 2*i*0.1
    cam.exposure = exptime
    hdr = snap()
    count += 1
    print exptime\


count = 1
for i in range(1,20):
    exptime = 2*i*0.1
    cam.exposure = exptime
    hdr = snap()
    count += 1
    print exptime\


count = 1
for i in range(1,50):
    exptime = 2*i*0.1
    cam.exposure = exptime
    hdr = snap()
    count += 1
    print exptime\
    time.sleep(exptime)


count = 1
for i in range(1,50):
    exptime = 2*i*0.1
    cam.exposure = exptime
    hdr = snap()
    count += 1
    print exptime\


count = 1
for i in range(1,80):
    exptime = 2*i*0.1
    cam.exposure = exptime
    hdr = snap()
    count += 1
    print exptime,


count = 1
for i in range(1,80):
    exptime = 2*i*0.1
    cam.exposure = exptime
    hdr = snap()
    count += 1
    print exptime,
    time.sleep(exptime)


count = 1
for i in range(1,80):
    exptime = 3*i*0.1
    cam.exposure = exptime
    hdr = snap()
    count += 1
    print exptime,
    time.sleep(exptime)
    np.save('hdrdata_HeNe_hamatsu_exp%d.npy' %i,hdr)


plt.imshow(hdr)
count = 1
for i in range(1,80):
    exptime = 3*i*0.1
    cam.exposure = exptime
    hdr = snap()
    count += 1
    print exptime,
    time.sleep(exptime)
    hdr = hdr/exptime
    np.save('hdrdata_HeNe_hamatsu_exp%d.npy' %i,hdr)


%gui qt
cam.show_gui(blocking=False)

count = 1
for i in range(1,100):
    exptime = 3*i*0.1
    cam.exposure = exptime
    hdr = snap()
    count += 1
    print exptime,
    time.sleep(exptime)
    hdr = hdr/exptime
    np.save('hdrdata_HeNe_hamatsu_exp%d.npy' %i,hdr)


%gui qt
cam.show_gui(blocking=False)



%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%gui qt
cam.show_gui(blocking=False)





for i in range(1,10):
    exptime = 4*i*0.1
    cam.exposure = exptime
    hdr = snap()
    count += 1
    print exptime,
    time.sleep(exptime)
    hdr = hdr/exptime
    hdrsum += hdr


count = 1

for i in range(1,10):
    exptime = 4*i*0.1
    cam.exposure = exptime
    hdr = snap()
    count += 1
    print exptime,
    time.sleep(exptime)
    hdr = hdr/exptime
    hdrsum += hdr


np.zeros_like(hdr)
count = 1
hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,10):
    exptime = 4*i*0.1
    cam.exposure = exptime
    hdr = snap()
    count += 1
    print exptime,
    time.sleep(exptime)
    hdr = hdr/exptime
    hdrsum += hdr
    #np.save('hdrdata_HeNe_hamatsu_exp%d.npy' %i,hdr)


plt.imshow(hdrsum)
count = 1
hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,100):
    exptime = 4*i*0.1
    cam.exposure = exptime
    hdr = snap()
    count += 1
    print exptime,
    time.sleep(exptime)
    hdr = hdr/exptime
    hdrsum += hdr


count = 1
hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,100):
    exptime = 5*i*0.1
    cam.exposure = exptime
    hdr = snap()
    count += 1
    print exptime,
    time.sleep(exptime)
    hdr = hdr/exptime
    hdrsum += hdr
    #np.save('hdrdata_HeNe_hamatsu_exp%d.npy' %i,hdr)


%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%gui qt
cam.show_gui(blocking=False)

count = 1
hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,100):
    exptime = 5*i*0.1
    cam.exposure = exptime
    hdr = snap()
    count += 1
    print exptime,
    time.sleep(exptime)
    hdr = hdr/exptime
    hdrsum += hdr
    #np.save('hdrdata_HeNe_hamatsu_exp%d.npy' %i,hdr)


count = 1
hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,100):
    exptime = 5*i*0.1
    cam.exposure = exptime
    hdr = snap()
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr
    #np.save('hdrdata_HeNe_hamatsu_exp%d.npy' %i,hdr)


count = 1
hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,100):
    exptime = 6*i*0.1
    cam.exposure = exptime
    hdr = snap()
    time.sleep(exptime)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr
    #np.save('hdrdata_HeNe_hamatsu_exp%d.npy' %i,hdr)


count = 1
hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,100):
    exptime = 6*i*0.1
    cam.exposure = exptime
    hdr = snap()
    time.sleep(0.5)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr
    #np.save('hdrdata_HeNe_hamatsu_exp%d.npy' %i,hdr)


plt.imshow(hdrsum)
%gui qt
cam.show_gui(blocking=False)

test_spot = [-10,5,0,1]
slm.make_spots([test_spot])

count = 1
hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,100):
    exptime = 5*i*0.1
    cam.exposure = exptime
    hdr = snap()
    time.sleep(0.5)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr
    #np.save('hdrdata_HeNe_hamatsu_exp%d.npy' %i,hdr)


plt.imshow(hdrsum)
count = 1
hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,200):
    exptime = 5*i*0.1
    cam.exposure = exptime
    hdr = snap()
    time.sleep(0.5)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr
    #np.save('hdrdata_HeNe_hamatsu_exp%d.npy' %i,hdr)


count = 1
hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,200):
    exptime = 2*i*0.1
    cam.exposure = exptime
    hdr = snap()
    time.sleep(0.5)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr
    #np.save('hdrdata_HeNe_hamatsu_exp%d.npy' %i,hdr)


plt.imshow(hdrsum)
%gui qt
cam.show_gui(blocking=False)

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,200):
    exptime = 2*i*0.1
    cam.exposure = exptime
    hdr = snap()
    time.sleep(0.5)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr


exprun += 1
np.save('hdrsumdata_HeNe_hamatsu_exp%d.npy' %i,hdrsum)
exprun = 0;
exprun += 1
np.save('hdrsumdata_HeNe_hamatsu_exp%d.npy' %i,hdrsum)
plt.imshow(hdrsum)
hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,200):
    exptime = 4*i*0.1
    cam.exposure = exptime
    hdr = snap()
    time.sleep(0.5)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr


exprun += 1
np.save('hdrsumdata_HeNe_hamatsu_exp%d.npy' %i,hdrsum)
plt.imshow(hdrsum)
hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,200):
    exptime = 5*i*0.1
    cam.exposure = exptime
    hdr = snap()
    time.sleep(0.5)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr


exprun += 1
np.save('hdrsumdata_HeNe_hamatsu_exp%d.npy' %i,hdrsum)
np.save('hdrsumdata_HeNe_hamatsu_expmin%d_expmax%d_expstep%d.npy' %exptimemin exptimemax en*0.1,hdrsum)
np.save('hdrsumdata_HeNe_hamatsu_expmin%d_expmax%d_expstep%d.npy' % exptimemin exptimemax en*0.1,hdrsum)
np.save('hdrsumdata_HeNe_hamatsu_expmin%d_expmax%d_expstep%d.npy' %exptimemin %exptimemax %en*0.1,hdrsum)
count = 1
exprun = 0;

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,200):
    en = 2
    exptime = en*i*0.1
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    hdr = snap()
    time.sleep(0.5)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr


exprun += 1
np.save('hdrsumdata_HeNe_hamatsu_expmin%d_expmax%d_expstep%d.npy' %exptimemin %exptimemax %en*0.1,hdrsum)
np.save('hdrsumdata_HeNe_hamatsu_expmin%d_expmax%d_expstep%d.npy' %exptimemin %exptimemax %en,hdrsum)
en
exptimemin
np.save('hdrsumdata_HeNe_hamatsu_expstep%d.npy' %en,hdrsum)
plt.imshow(hdrsum)
count = 1
exprun = 0;

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,200):
    en = 3
    exptime = en*i*0.1
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    hdr = snap()
    time.sleep(0.5)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr


exprun += 1
np.save('hdrsumdata_HeNe_hamatsu_expstep%d.npy' %en,hdrsum)
plt.imshow(hdrsum)
hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,200):
    en = 5
    exptime = en*i*0.1
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    hdr = snap()
    time.sleep(0.5)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr


exprun += 1
np.save('hdrsumdata_HeNe_hamatsu_expstep%d.npy' %en,hdrsum)
plt.imshow(hdrsum)

%gui qt
cam.show_gui(blocking=False)

test_spot = [-10,5,0,10]
test_spot = [-10,50,0,1]
test_spot = [-10,5,0,10]
slm.make_spots([test_spot])
test_spot = [-10,50,0,1]
slm.make_spots([test_spot])
test_spot = [-10,5,0,10]
slm.make_spots([test_spot])
test_spot = [-10,5,1,1]
slm.make_spots([test_spot])
test_spot = [-10,5,10,1]
slm.make_spots([test_spot])
test_spot = [-1,5,10,1]
slm.make_spots([test_spot])
test_spot = [-10,5,10,1]
test_spot = [-10,5,0,1]
slm.make_spots([test_spot])
test_spot = [-10,5,0,20]
slm.make_spots([test_spot])
count = 1
exprun = 0;

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,200):
    en = 5
    exptime = en*i*0.1
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    hdr = snap()
    time.sleep(0.5)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr


exprun += 1
np.save('hdrsumdata_HeNe_hamatsu_expstep%d.npy' %en,hdrsum)
plt.imshow(hdrsum)
count = 1
exprun = 0;

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,200):
    en = 3
    exptime = en*i*0.1
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    hdr = snap()
    time.sleep(0.5)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr


exprun += 1
np.save('hdrsumdata_HeNe_hamatsu_expstep%d.npy' %en,hdrsum)
plt.imshow(hdrsum)
count = 1
exprun = 0;

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,200):
    en = 2
    exptime = en*i*0.1
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    hdr = snap()
    time.sleep(0.5)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr


exprun += 1
np.save('hdrsumdata_HeNe_hamatsu_expstep%dNDfiltremoved.npy' %en,hdrsum)
plt.imshow(hdrsum)
hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,400):
    en = 2
    exptime = en*i*0.1
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    hdr = snap()
    time.sleep(0.5)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr


exprun += 1
np.save('hdrsumdata_HeNe_hamatsu_expstep%dNDfiltremoved_rangeto80.npy' %en,hdrsum)
plt.imshow(hdrsum)
count = 1
exprun = 0;

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,400):
    en = 5
    exptime = en*i*0.1
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    hdr = snap()
    time.sleep(0.5)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr


exprun += 1
np.save('hdrsumdata_HeNe_hamatsu_expstep%dNDfiltremoved_rangeto80.npy' %en,hdrsum)
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
test_spot = [-10,5,0,20]
slm.make_spots([test_spot])

%gui qt
cam.show_gui()
count = 1
exprun = 0;

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,200):
    en = 5
    exptime = en*i*0.1
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    hdr = snap()
    time.sleep(0.5)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr


exprun += 1
np.save('hdrsumdata_HeNe_hamatsu_expstep%dNDfiltremoved_rangeto80.npy' %en,hdrsum)
plt.imshow(hdrsum)
cam.show_gui()
count = 1
exprun = 0;

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,200):
    en = 5
    exptime = en*i*0.1
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    hdr = snap()
    time.sleep(0.5)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr


exprun += 1
np.save('hdrsumdata_HeNe_hamatsu_expstep%d_ND40atcameraonly.npy' %en,hdrsum)
plt.imshow(hdrsum)
cam.show_gui()
count = 1
exprun = 0;

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,200):
    en = 5
    exptime = en*i*0.1
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    hdr = snap()
    time.sleep(0.5)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr


exprun += 1
np.save('hdrsumdata_HeNe_hamatsu_expstep%d_ND50atcameraonly.npy' %en,hdrsum)
plt.imshow(hdrsum)
cam.show_gui()
count = 1
exprun = 0;

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,200):
    en = 5
    exptime = en*i*0.1
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    hdr = snap()
    time.sleep(0.5)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr


exprun += 1
np.save('hdrsumdata_HeNe_hamatsu_expstep%d_ND40atcameraonly.npy' %en,hdrsum)
plt.imshow(hdrsum)
hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,100):
    en = 2
    exptime = en*i*0.1
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    hdr = snap()
    time.sleep(0.5)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr
    np.save('hdrdata_HeNe_hamatsu_exp_%d.npy' %exptime,hdrsum)


plt.imshow(hdrsum)
count = 1

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,60):
    en = 1
    exptime = en*i*0.1
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    hdr = snap()
    time.sleep(0.5)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr
    np.save('hdrdata_HeNe_hamatsu_exp_%d.npy' %exptime,hdrsum)



plt.imshow(hdrsum)
count = 1

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,100):
    en = 1
    exptime = en*i*0.1
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    hdr = snap()
    time.sleep(0.5)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr
    np.save('hdrdata_HeNe_hamatsu_exp_%d.npy' %exptime,hdrsum)


plt.imshow(hdrsum)
count = 1

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,100):
    en = 1
    exptime = en*i*0.05
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    hdr = snap()
    time.sleep(0.5)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr
    np.save('hdrdata_HeNe_hamatsu_exp_%d.npy' %exptime,hdrsum)


plt.imshow(hdrsum)
count = 1

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,200):
    en = 1
    exptime = en*i*0.05
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    hdr = snap()
    time.sleep(0.5)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr
    np.save('hdrdata_HeNe_hamatsu_exp_%d.npy' %exptime,hdrsum)


plt.imshow(hdrsum)
count = 1

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,300):
    en = 1
    exptime = en*i*0.05
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    hdr = snap()
    time.sleep(0.5)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr
    np.save('hdrdata_HeNe_hamatsu_exp_%d.npy' %exptime,hdrsum)


plt.imshow(hdrsum)
count = 1

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,300):
    en = 1
    exptime = en*i*0.05
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    hdr = snap()
    time.sleep(0.5)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr
    np.save('hdrdata_HeNe_hamatsu_exp_%d.npy' %(exptime*100),hdrsum)


plt.imshow(hdrsum)


test_spot = [20,-10,0,1];
test_spot = [20,-10,0,1];
distance = 2900e3
slm.make_spots([test_spot + [0,0,0.075,0]])
test_spot = [20,-10,0,1];
#distance = 2900e3
#for hamatsu set up
distance = 600e3
slm.make_spots([test_spot + [0,0,0.075,0]])
test_spot = [20,-10,0,1];
#distance = 2900e3
#for hamatsu set up
distance = 500e3
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%gui qt
cam.show_gui()
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
test_spot = [20,-10,0,1];
#distance = 2900e3
#for hamatsu set up
distance = 500e3

%gui qt
cam.show_gui()
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)

print zernike_coefficients
modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m - flat, discard_edges=1)


flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m - flat, discard_edges=1)
    
results.shape[0]
m - flat
m
flat
m - flat
slm_size = 6.9
initial_r = 1.9
N = res.shape[0]
x = (np.arange(N)-(N-1)/2.0)/N * slm_size #centres of apertures
gaussian = np.exp(-x**2/initial_r**2)
gaussian /= np.mean(gaussian)
f, axes = plt.subplots(1,2)
# plot the data and a Gaussian fit
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(x, data[:,i], '+', color=plt.cm.gist_rainbow(float(i)/N))
        m = np.polyfit(gaussian, data[:,i], 1)
        ax.plot(x, gaussian*m[0]+m[1], '-', color=plt.cm.gist_rainbow(float(i)/N))

# plot the data against the Gaussian
f, axes = plt.subplots(1,2)
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(gaussian, data[:,i], '-+', color=plt.cm.gist_rainbow(float(i)/N))


r = np.sqrt(x[:,np.newaxis]**2 + x[np.newaxis,:]**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')

plt.figure()
s=slm_size/2.0
plt.imshow(res[:,:,2],extent=(-s,s,-s,s))
for thresh in [0.0,0.1,0.2,0.5,0.9]:
    I = res[:,:,2].copy()
    I /= np.max(I)
    I -= thresh
    I[I<0] = 0
    cx = np.sum(x[:,np.newaxis]*I)/np.sum(I)
    cy = np.sum(x[np.newaxis,:]*I)/np.sum(I)
    hide = plt.plot(cy,cx,'+')
    print "found centroid at {}, {} with threshold {}".format(cx, cy, thresh)


r = np.sqrt((x[:,np.newaxis]-cx)**2 + (x[np.newaxis,:]-cy)**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')
radii = r.flatten()
I = res[:,:,2].flatten()/I.max()*10
from scipy.interpolate import UnivariateSpline
spl = UnivariateSpline(np.concatenate([radii,-radii]), np.tile(I,2))
rr = np.linspace(0,slm_size/np.sqrt(2),100)
plt.plot(rr,spl(rr))
plt.plot(radii,I,'.')
slm.centre=(cx,cy)
slm.radial_blaze_function = np.ones(384)
inner_edge_i = 1500//18 #bad
sd = 400/18.0
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#dim_slm(1)
#dim_slm(0.75)
#dim_slm(0.5)
#dim_slm(0.2)
#dim_slm(0.1)
#cam.exposure=-2
def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))

def brightest_g():
    time.sleep(0.1)
    cam.color_image()
    img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.2,0.15,0.1,0.07]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.2,0.15,0.1,0.07]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})

"""

"""
# Really thorough optimisation of defocus
# Start with a visible, nicely-focused spot
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
focus_stack(50,5, snap=snap)

"""
"""
# Scan through a parameter, plotting sections of the beam
xsection = np.zeros((30,640,3),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],480,3),dtype=np.uint8)
rs = np.linspace(-5,5,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    img = cam.color_image()
    img = cam.color_image()
    xsection[i,:,:] = np.mean(img[230:250,:,:], axis=0)
    ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot])
%gui qt
cam.show_gui()
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.2,0.15,0.1,0.07]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)


zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)

zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
zernike_coefficients









zernike_coefficients











%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%gui qt
cam.show_gui()
test_spot = [20,-10,0,1];
#distance = 2900e3
#for hamatsu set up
distance = 500e3
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)

zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
print modes
flat = modes[12]
print flat
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m - flat, discard_edges=1)


for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m, discard_edges=1)


modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m, discard_edges=1)


zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#dim_slm(1)
#dim_slm(0.75)
#dim_slm(0.5)
#dim_slm(0.2)
#dim_slm(0.1)
#cam.exposure=-2
def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))

def brightest_g():
    time.sleep(0.1)
    cam.color_image()
    img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])

# Start by autofocusing (optimising mode 2)
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.2,0.15,0.1,0.07]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})

"""

"""
# Really thorough optimisation of defocus
# Start with a visible, nicely-focused spot
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
focus_stack(50,5, snap=snap)

"""
"""
# Scan through a parameter, plotting sections of the beam
xsection = np.zeros((30,640,3),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],480,3),dtype=np.uint8)
rs = np.linspace(-5,5,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    img = cam.color_image()
    img = cam.color_image()
    xsection[i,:,:] = np.mean(img[230:250,:,:], axis=0)
    ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))

count = 1

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,300):
    en = 1
    exptime = en*i*0.05
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    hdr = snap()
    time.sleep(0.5)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr
    np.save('hdrdata_HeNe_hamatsu_exp_%d.npy' %(exptime*100),hdrsum)



"""
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#dim_slm(1)
#dim_slm(0.75)
#dim_slm(0.5)
#dim_slm(0.2)
#dim_slm(0.1)
#cam.exposure=-2
def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))

def brightest_g():
    time.sleep(0.1)
    cam.color_image()
    img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])

# Start by autofocusing (optimising mode 2)
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.2,0.15,0.1,0.07]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})

"""

"""
# Really thorough optimisation of defocus
# Start with a visible, nicely-focused spot
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
focus_stack(50,5, snap=snap)

"""
"""
# Scan through a parameter, plotting sections of the beam
xsection = np.zeros((30,640,3),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],480,3),dtype=np.uint8)
rs = np.linspace(-5,5,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    img = cam.color_image()
    img = cam.color_image()
    xsection[i,:,:] = np.mean(img[230:250,:,:], axis=0)
    ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))

count = 1

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,300):
    en = 1
    exptime = en*i*0.05
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    hdr = snap()
    time.sleep(0.5)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr
    np.save('hdrdata_HeNe_hamatsu_exp_%d.npy' %(exptime*100),hdrsum)



len([test_spot + [0,0,0.5,0]])
len(test_spot + [0,0,0.5,0])
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)

cam.show_gui()
slm.make_spots([test_spot + [0,0,0.075,0]])
test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.075,0]])
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)

test_spot = [20,-10,0,1];
#distance = 2900e3
#for hamatsu set up
distance = 500e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)

res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)

plot_shack_hartmann(res)

res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)

plot_shack_hartmann(res)

test_spot = [20,-10,0,1];
#distance = 2900e3
#for hamatsu set up
distance = 500e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)

plot_shack_hartmann(res)

res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)

plot_shack_hartmann(res)

res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)


plot_shack_hartmann(res)

res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)


plot_shack_hartmann(res)

res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)


plot_shack_hartmann(res)

res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)


plot_shack_hartmann(res)

test_spot = [20,-10,0,1];
#distance = 2900e3
#for hamatsu set up
distance = 500e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)


plot_shack_hartmann(res)

modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m, discard_edges=1)


zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))


def beam_sd():
    cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.2,0.15,0.1,0.07]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
print zernike_coefficients
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})
np.save('hamatsu_zernike_coefficients_f150mm.npy', zernike_coefficients)
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
focus_stack(50,5, snap=snap)

"""
"""
# Scan through a parameter, plotting sections of the beam
xsection = np.zeros((30,640,3),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],480,3),dtype=np.uint8)
rs = np.linspace(-5,5,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    img = cam.color_image()
    img = cam.color_image()
    xsection[i,:,:] = np.mean(img[230:250,:,:], axis=0)
    ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))

test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
focus_stack(50,5, snap=snap)

"""
"""
# Scan through a parameter, plotting sections of the beam
xsection = np.zeros((30,640,3),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],480,3),dtype=np.uint8)
rs = np.linspace(-5,5,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    xsection[i,:,:] = np.mean(img[230:250,:,:], axis=0)
    ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))
img = snap()
plt.imshow(img)
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.2,0.15,0.1,0.07]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
print zernike_coefficients
np.save('hamatsu_zernike_coefficients_f150mm-repeat1.npy', zernike_coefficients)
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.2,0.15,0.1,0.07]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
print zernike_coefficients
np.save('hamatsu_zernike_coefficients_f150mm-repeat2.npy', zernike_coefficients)
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.2,0.15,0.1,0.07]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
print zernike_coefficients
np.save('hamatsu_zernike_coefficients_f150mm-repeat3.npy', zernike_coefficients)
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.2,0.15,0.1,0.07]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
print zernike_coefficients
np.save('hamatsu_zernike_coefficients_f150mm-repeat3-1.npy', zernike_coefficients)
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.2,0.15,0.1,0.07]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
print zernike_coefficients
plt.imshow(cam.color_image())
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#dim_slm(1)
#dim_slm(0.75)
#dim_slm(0.5)
#dim_slm(0.2)
#dim_slm(0.1)
#cam.exposure=-2
def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))

def brightest_g():
    time.sleep(0.1)
    cam.color_image()
    img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])

# Start by autofocusing (optimising mode 2)
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.2,0.15,0.1,0.07]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
print zernike_coefficients
cam.color_image()
time.sleep(0.1)
hdr = snap()
cam.color_image()
hdr
hdr = snap()
plt.imshow(hdr)
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#dim_slm(1)
#dim_slm(0.75)
#dim_slm(0.5)
#dim_slm(0.2)
#dim_slm(0.1)
#cam.exposure=-2
def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))

def brightest_g():
    time.sleep(0.1)
    cam.color_image()
    img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    #cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])

# Start by autofocusing (optimising mode 2)
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.2,0.15,0.1,0.07]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
print zernike_coefficients
np.save('hamatsu_zernike_coefficients_f150mm-repeat4.npy', zernike_coefficients)
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.2,0.15,0.1,0.07]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
print zernike_coefficients
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
test_spot = [-10,5,0,1]
slm.make_spots([test_spot])

%gui qt
cam.show_gui()
count = 1

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,300):
    en = 1
    exptime = en*i*0.05
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    hdr = snap()
    time.sleep(0.5)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr


plt.imshow(hdrsum)
np.save('hdrdata_HeNe_hamatsu_f150mm_hdrsumto14p95_no%d.npy' %count,hdrsum)
count = 1

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,300):
    en = 2
    exptime = en*i*0.05
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    hdr = snap()
    time.sleep(0.5)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr


plt.imshow(hdrsum)
np.save('hdrdata_HeNe_hamatsu_f150mm_hdrsumto30_no%d-repeat1.npy' %count,hdrsum)
count = 1

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,350):
    en = 3
    exptime = en*i*0.05
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    hdr = snap()
    time.sleep(0.5)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr


plt.imshow(hdrsum)
np.save('hdrdata_HeNe_hamatsu_f150mm_hdrsumto52p3_no%d-repeat2.npy' %count,hdrsum)
count = 1

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,400):
    en = 2
    exptime = en*i*0.05
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    hdr = snap()
    time.sleep(0.5)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr
    np.save('hdrdata_HeNe_hamatsu_f150mm_hdrdata_exp%d.npy' %(exptime*100),hdrsum)


plt.imshow(hdrsum)
test_spot = [-10,5,100,1]
slm.make_spots([test_spot])

test_spot = [-10,5,200,1]
slm.make_spots([test_spot])

test_spot = [-10,5,500,1]
slm.make_spots([test_spot])

test_spot = [-10,5,1000,1]
slm.make_spots([test_spot])

%gui qt
cam.show_gui()
print cam.exposure
cam.exposure = 0.1
print cam.exposure
rexp = cam.exposure
print rexp
rexp*100
rexp*1000
rexp*1e5
test_spot = [-10,5,0,1]
slm.make_spots([test_spot])

count = 1

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,400):
    en = 2
    exptime = en*i*0.05
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    #real exposure set read
    rexp = cam.exposure
    hdr = snap()
    time.sleep(0.5)
    count += 1
    print exptime,
    hdr = hdr/exptime
    hdrsum += hdr
    np.save('hdrdata_HeNe_hamatsu_f150mm_hdrdata_exp%d.npy' %(rexp*1e5),hdrsum)


plt.imshow(hdrsum)
count = 1

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,400):
    en = 2
    exptime = en*i*0.05
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    #real exposure set read
    rexp = cam.exposure
    hdr = snap()
    time.sleep(0.3)
    count += 1
    print exptime,
    hdrtemp = hdr/rexp
    hdrsum += hdrtemp
    np.save('hdrdata_HeNe_hamatsu_f150mm_hdrdata_exp%d.npy' %(rexp*1e5),hdr)


plt.imshow(hdrsum)
np.save('hdrdata_HeNe_hamatsu_f150mm_hdrSUMdata_exp%d.npy' %(rexp*1e5),hdrsum)
test_spot = [-10,5,50,1]
slm.make_spots([test_spot])

test_spot = [-10,5,100,1]
slm.make_spots([test_spot])

count = 1

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,400):
    en = 2
    exptime = en*i*0.05
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    #real exposure set read
    rexp = cam.exposure
    hdr = snap()
    time.sleep(0.3)
    count += 1
    print exptime,
    hdrtemp = hdr/rexp
    hdrsum += hdrtemp
    np.save('hdrdata_HeNe_hamatsu_f150mm_hdrdata_testspot100_exp%d.npy' %(rexp*1e5),hdr)


plt.imshow(hdrsum)
np.save('hdrdata_HeNe_hamatsu_f150mm_hdrSUMdata_exp%d.npy' %(rexp*1e5),hdrsum)
test_spot = [-10,5,250,1]
slm.make_spots([test_spot])

count = 1

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,400):
    en = 2
    exptime = en*i*0.05
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    #real exposure set read
    rexp = cam.exposure
    hdr = snap()
    time.sleep(0.3)
    count += 1
    print exptime,
    hdrtemp = hdr/rexp
    hdrsum += hdrtemp
    np.save('hdrdata_HeNe_hamatsu_f150mm_hdrdata_testspot100_exp%d.npy' %(rexp*1e5),hdr)


plt.imshow(hdrsum)
np.save('hdrdata_HeNe_hamatsu_f150mm_hdrSUMdata_exp%d.npy' %(rexp*1e5),hdrsum)
test_spot = [-10,5,300,1]
slm.make_spots([test_spot])

count = 1

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,400):
    en = 2
    exptime = en*i*0.05
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    #real exposure set read
    rexp = cam.exposure
    hdr = snap()
    time.sleep(0.3)
    count += 1
    print exptime,
    hdrtemp = hdr/rexp
    hdrsum += hdrtemp
    np.save('hdrdata_HeNe_hamatsu_f150mm_hdrdata_testspot100_exp%d.npy' %(rexp*1e5),hdr)


plt.imshow(hdrsum)
np.save('hdrdata_HeNe_hamatsu_f150mm_hdrSUMdata_exp%d.npy' %(rexp*1e5),hdrsum)
test_spot = [-10,5,500,1]
slm.make_spots([test_spot])

count = 1

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,400):
    en = 2
    exptime = en*i*0.05
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    #real exposure set read
    rexp = cam.exposure
    hdr = snap()
    time.sleep(0.3)
    count += 1
    print exptime,
    hdrtemp = hdr/rexp
    hdrsum += hdrtemp
    np.save('hdrdata_HeNe_hamatsu_f150mm_hdrdata_testspot100_exp%d.npy' %(rexp*1e5),hdr)


plt.imshow(hdrsum)
np.save('hdrdata_HeNe_hamatsu_f150mm_hdrSUMdata_exp%d.npy' %(rexp*1e5),hdrsum)
test_spot = [-10,5,2000,1]
slm.make_spots([test_spot])

count = 1

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,400):
    en = 2
    exptime = en*i*0.05
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    #real exposure set read
    rexp = cam.exposure
    hdr = snap()
    time.sleep(0.3)
    count += 1
    print exptime,
    hdrtemp = hdr/rexp
    hdrsum += hdrtemp
    np.save('hdrdata_HeNe_hamatsu_f150mm_hdrdata_testspot100_exp%d.npy' %(rexp*1e5),hdr)


plt.imshow(hdrsum)
np.save('hdrdata_HeNe_hamatsu_f150mm_hdrSUMdata_exp%d.npy' %(rexp*1e5),hdrsum)
test_spot = [-10,5,-2000,1]
slm.make_spots([test_spot])

test_spot = [-10,5,-200,1]
slm.make_spots([test_spot])

count = 1

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,400):
    en = 2
    exptime = en*i*0.05
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    #real exposure set read
    rexp = cam.exposure
    hdr = snap()
    time.sleep(0.3)
    count += 1
    print exptime,
    hdrtemp = hdr/rexp
    hdrsum += hdrtemp
    np.save('hdrdata_HeNe_hamatsu_f150mm_hdrdata_testspot100_exp%d.npy' %(rexp*1e5),hdr)


test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
focus_stack(50,5, snap=snap)
distance = 1e3
test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
focus_stack(50,5, snap=snap)
zernike_coefficients = np.zeros(12)
test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
focus_stack(50,5, snap=snap)
slm.radial_blaze_function = np.ones(384)
slm.blaze_function = np.ones(32)
slm.n=0
slm.make_spots([[0,0,0,1]])
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
slm.make_spots([[0,0,0,1]])
slm.make_spots([[0,0,0,5]])
slm.make_spots([[0,0,0,0]])
slm.make_spots([[0,0,0,1]])
slm.make_spots([[0,0,4,1]])
slm.make_spots([[1,0,0,1]])
%gui qt
cam.show_gui()
slm.make_spots([[10,0,0,1]])
slm.make_spots([[50,0,0,1]])
slm.make_spots([[-50,0,0,1]])
slm.make_spots([[0,0,0,1]])
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%gui qt
cam.show_gui()
slm.make_spots([[0,0,0,1]])
slm.make_spots([[0,0,0,10]])
slm.make_spots([[1,0,0,1]])
slm.make_spots([[10,0,0,1]])
count = 1

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,400):
    en = 2
    exptime = en*i*0.05
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    #real exposure set read
    rexp = cam.exposure
    hdr = snap()
    time.sleep(0.3)
    count += 1
    print exptime,
    hdrtemp = hdr/rexp
    hdrsum += hdrtemp
    np.save('hdrdata_HeNe_hamatsu_f150mm_hdrdata_testspot100_exp%d.npy' %(rexp*1e5),hdr)


plt.imshow(hdrsum)
np.save('hdrdata_HeNe_hamatsu_f150mm_hdrSUMdata_exp%d.npy' %(rexp*1e5),hdrsum)
slm.make_spots([[20,0,0,1]])
slm.make_spots([[20,0,0,0]])
slm.make_spots([[20,0,0,2]])
slm.make_spots([[20,0,0,1]])
count = 1

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,400):
    en = 2
    exptime = en*i*0.05
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    #real exposure set read
    rexp = cam.exposure
    hdr = snap()
    time.sleep(0.3)
    count += 1
    print exptime,
    hdrtemp = hdr/rexp
    hdrsum += hdrtemp
    np.save('hdrdata_HeNe_hamatsu_f150mm_hdrdata_testspot100_exp%d.npy' %(rexp*1e5),hdr)
plt.imshow(hdrsum)
slm.make_spots([[20,0,0,1]])
np.save('hdrdata_HeNe_hamatsu_f150mm_hdrSUMdata_exp%d.npy' %(rexp*1e5),hdrsum)
slm.make_spots([[30,0,0,1]])
slm.make_spots([[-30,0,0,1]])
slm.make_spots([[5,0,0,1]])
count = 1

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,400):
    en = 2
    exptime = en*i*0.05
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    #real exposure set read
    rexp = cam.exposure
    hdr = snap()
    time.sleep(0.3)
    count += 1
    print exptime,
    hdrtemp = hdr/rexp
    hdrsum += hdrtemp
    np.save('hdrdata_HeNe_hamatsu_f150mm_hdrdata_testspot100_exp%d.npy' %(rexp*1e5),hdr)


np.save('hdrdata_HeNe_hamatsu_f150mm_hdrSUMdata_exp%d.npy' %(rexp*1e5),hdrsum)
plt.imshow(hdrsum)
slm.make_spots([[0,5,0,1]])
count = 1

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,400):
    en = 2
    exptime = en*i*0.05
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    #real exposure set read
    rexp = cam.exposure
    hdr = snap()
    time.sleep(0.3)
    count += 1
    print exptime,
    hdrtemp = hdr/rexp
    hdrsum += hdrtemp
    np.save('hdrdata_HeNe_hamatsu_f150mm_hdrdata_testspot100_exp%d.npy' %(rexp*1e5),hdr)


plt.imshow(hdrsum)



np.save('hdrdata_HeNe_hamatsu_f150mm_hdrSUMdata_exp%d.npy' %(rexp*1e5),hdrsum)
count = 1

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,600):
    en = 2
    exptime = en*i*0.05
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    #real exposure set read
    rexp = cam.exposure
    hdr = snap()
    time.sleep(0.3)
    count += 1
    print exptime,
    hdrtemp = hdr/rexp
    hdrsum += hdrtemp
    np.save('hdrdata_HeNe_hamatsu_f150mm_hdrdata_testspot100_exp%d.npy' %(rexp*1e5),hdr)
    
np.save('hdrdata_HeNe_hamatsu_f150mm_hdrSUMdata_exp%d.npy' %(rexp*1e5),hdrsum)
plt.imshow(hdrsum)
count = 1

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,7
00):
    en = 2
    exptime = en*i*0.05
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    #real exposure set read
    rexp = cam.exposure
    hdr = snap()
    time.sleep(0.3)
    count += 1
    print exptime,
    hdrtemp = hdr/rexp
    hdrsum += hdrtemp
    np.save('hdrdata_HeNe_hamatsu_f150mm_hdrdata_testspot100_exp%d.npy' %(rexp*1e5),hdr)
count = 1

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,700):
    en = 2
    exptime = en*i*0.05
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    #real exposure set read
    rexp = cam.exposure
    hdr = snap()
    time.sleep(0.3)
    count += 1
    print exptime,
    hdrtemp = hdr/rexp
    hdrsum += hdrtemp
    np.save('hdrdata_HeNe_hamatsu_f150mm_hdrdata_testspot100_exp%d.npy' %(rexp*1e5),hdr)
    
plt.imshow(hdrsum)
np.save('hdrdata_HeNe_hamatsu_f150mm_hdrSUMdata_exp%d.npy' %(rexp*1e5),hdrsum)
slm.make_spots([[0,10,0,1]])
count = 1

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,700):
    en = 2
    exptime = en*i*0.05
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    #real exposure set read
    rexp = cam.exposure
    hdr = snap()
    time.sleep(0.3)
    count += 1
    print exptime,
    hdrtemp = hdr/rexp
    hdrsum += hdrtemp
    np.save('hdrdata_HeNe_hamatsu_f150mm_hdrdata_testspot100_exp%d.npy' %(rexp*1e5),hdr)
    
plt.imshow(hdrsum)
np.save('hdrdata_HeNe_hamatsu_f150mm_hdrSUMdata_exp%d.npy' %(rexp*1e5),hdrsum)
slm.make_spots([[0,20,0,1]])
count = 1

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,400):
    en = 2
    exptime = en*i*0.05
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    #real exposure set read
    rexp = cam.exposure
    hdr = snap()
    time.sleep(0.3)
    count += 1
    print exptime,
    hdrtemp = hdr/rexp
    hdrsum += hdrtemp
    np.save('hdrdata_HeNe_hamatsu_f150mm_hdrdata_testspot100_exp%d.npy' %(rexp*1e5),hdr)
    
plt.imshow(hdrsum)
slm.make_spots([[0,2,0,1]])
slm.make_spots([[0,7,0,1]])
count = 1

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,700):
    en = 2
    exptime = en*i*0.05
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    #real exposure set read
    rexp = cam.exposure
    hdr = snap()
    time.sleep(0.3)
    count += 1
    print exptime,
    hdrtemp = hdr/rexp
    hdrsum += hdrtemp
    np.save('hdrdata_HeNe_hamatsu_f150mm_hdrdata_testspot100_exp%d.npy' %(rexp*1e5),hdr)
    
plt.imshow(hdrsum)
np.save('hdrdata_HeNe_hamatsu_f150mm_hdrSUMdata_exp%d.npy' %(rexp*1e5),hdrsum)
count = 1

hdr = snap()
hdrsum = np.zeros_like(hdr)
for i in range(1,700):
    en = 4
    exptime = en*i*0.05
    exptimemin = en*0.1
    exptimemax = en*i*0.1
    cam.exposure = exptime
    #real exposure set read
    rexp = cam.exposure
    hdr = snap()
    time.sleep(0.3)
    count += 1
    print exptime,
    hdrtemp = hdr/rexp
    hdrsum += hdrtemp
    np.save('hdrdata_HeNe_hamatsu_f150mm_hdrdata_testspot100_exp%d.npy' %(rexp*1e5),hdr)
    
plt.imshow(hdrsum)
np.save('hdrdata_HeNe_hamatsu_f150mm_hdrSUMdata_exp%d.npy' %(rexp*1e5),hdrsum)
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
distance = 30e3
3e3
distance = 3e2
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
distance = 3e2
%gui qt
cam.show_gui()
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)

cam.show_gui()
def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))

def brightest_g():
    time.sleep(0.1)
    cam.color_image()
    img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    #cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.2,0.15,0.1,0.07]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
print zernike_coefficients
past_zernike_coefficients
past_zernike_coefficients = zernike_coefficients
for dz in [0.3,0.2,0.15,0.1,0.07,0.05]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)
past_zernike_coefficients = zernike_coefficients
print zernike_coefficients
for dz in [0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)


print zernike_coefficients
for dz in [0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)
print zernike_coefficients
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
cam.show_gui()
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
distance = 1e3
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=2e2)

slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=5e2)

slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
test_spot = [20,-10,0,1];
#distance = 2900e3
#for hamatsu set up
distance = 500e3
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm_size = 6.9
initial_r = 1.9
N = res.shape[0]
x = (np.arange(N)-(N-1)/2.0)/N * slm_size #centres of apertures
gaussian = np.exp(-x**2/initial_r**2)
gaussian /= np.mean(gaussian)
f, axes = plt.subplots(1,2)
# plot the data and a Gaussian fit
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(x, data[:,i], '+', color=plt.cm.gist_rainbow(float(i)/N))
        m = np.polyfit(gaussian, data[:,i], 1)
        ax.plot(x, gaussian*m[0]+m[1], '-', color=plt.cm.gist_rainbow(float(i)/N))

# plot the data against the Gaussian
f, axes = plt.subplots(1,2)
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(gaussian, data[:,i], '-+', color=plt.cm.gist_rainbow(float(i)/N))


r = np.sqrt(x[:,np.newaxis]**2 + x[np.newaxis,:]**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')

plt.figure()
s=slm_size/2.0
plt.imshow(res[:,:,2],extent=(-s,s,-s,s))
for thresh in [0.0,0.1,0.2,0.5,0.9]:
    I = res[:,:,2].copy()
    I /= np.max(I)
    I -= thresh
    I[I<0] = 0
    cx = np.sum(x[:,np.newaxis]*I)/np.sum(I)
    cy = np.sum(x[np.newaxis,:]*I)/np.sum(I)
    hide = plt.plot(cy,cx,'+')
    print "found centroid at {}, {} with threshold {}".format(cx, cy, thresh)


r = np.sqrt((x[:,np.newaxis]-cx)**2 + (x[np.newaxis,:]-cy)**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')
radii = r.flatten()
I = res[:,:,2].flatten()/I.max()*10
from scipy.interpolate import UnivariateSpline
spl = UnivariateSpline(np.concatenate([radii,-radii]), np.tile(I,2))
rr = np.linspace(0,slm_size/np.sqrt(2),100)
plt.plot(rr,spl(rr))
plt.plot(radii,I,'.')
slm.centre=(cx,cy)
slm.radial_blaze_function = np.ones(384)
inner_edge_i = 1500//18 #bad
sd = 400/18.0
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))

def brightest_g():
    time.sleep(0.1)
    cam.color_image()
    img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    #cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
print zernike_coefficients
prev_zc = zernike_coefficients
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
print zernike_coefficients

test_spot = [20,-10,0,1];
#distance = 2900e3
#for hamatsu set up
distance = 900e3

slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m, discard_edges=1)


slm_size = 6.9
initial_r = 1.9
N = res.shape[0]
x = (np.arange(N)-(N-1)/2.0)/N * slm_size #centres of apertures
gaussian = np.exp(-x**2/initial_r**2)
gaussian /= np.mean(gaussian)
f, axes = plt.subplots(1,2)
# plot the data and a Gaussian fit
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(x, data[:,i], '+', color=plt.cm.gist_rainbow(float(i)/N))
        m = np.polyfit(gaussian, data[:,i], 1)
        ax.plot(x, gaussian*m[0]+m[1], '-', color=plt.cm.gist_rainbow(float(i)/N))

# plot the data against the Gaussian
f, axes = plt.subplots(1,2)
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(gaussian, data[:,i], '-+', color=plt.cm.gist_rainbow(float(i)/N))


r = np.sqrt(x[:,np.newaxis]**2 + x[np.newaxis,:]**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')

plt.figure()
s=slm_size/2.0
plt.imshow(res[:,:,2],extent=(-s,s,-s,s))
for thresh in [0.0,0.1,0.2,0.5,0.9]:
    I = res[:,:,2].copy()
    I /= np.max(I)
    I -= thresh
    I[I<0] = 0
    cx = np.sum(x[:,np.newaxis]*I)/np.sum(I)
    cy = np.sum(x[np.newaxis,:]*I)/np.sum(I)
    hide = plt.plot(cy,cx,'+')
    print "found centroid at {}, {} with threshold {}".format(cx, cy, thresh)


r = np.sqrt((x[:,np.newaxis]-cx)**2 + (x[np.newaxis,:]-cy)**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')
radii = r.flatten()
I = res[:,:,2].flatten()/I.max()*10
from scipy.interpolate import UnivariateSpline
spl = UnivariateSpline(np.concatenate([radii,-radii]), np.tile(I,2))
rr = np.linspace(0,slm_size/np.sqrt(2),100)
plt.plot(rr,spl(rr))
plt.plot(radii,I,'.')
slm.centre=(cx,cy)
slm.radial_blaze_function = np.ones(384)
inner_edge_i = 1500//18 #bad
sd = 400/18.0
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))

def brightest_g():
    time.sleep(0.1)
    cam.color_image()
    img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    #cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})

print zernike_coefficients
prev_cz = zernike_coefficients
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})

print zernike_coefficients

print prev_zc
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#dim_slm(1)
#dim_slm(0.75)
#dim_slm(0.5)
#dim_slm(0.2)
#dim_slm(0.1)
#cam.exposure=-2
def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))

def brightest_g():
    time.sleep(0.1)
    cam.color_image()
    img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    #cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])

# Start by autofocusing (optimising mode 2)
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})

print zernike_coefficients
print prev_zc
test_spot = [20,-10,0,1];
#distance = 2900e3
#for hamatsu set up
distance = 1300e3
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m, discard_edges=1)


slm_size = 6.9
initial_r = 1.9
N = res.shape[0]
x = (np.arange(N)-(N-1)/2.0)/N * slm_size #centres of apertures
gaussian = np.exp(-x**2/initial_r**2)
gaussian /= np.mean(gaussian)
f, axes = plt.subplots(1,2)
# plot the data and a Gaussian fit
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(x, data[:,i], '+', color=plt.cm.gist_rainbow(float(i)/N))
        m = np.polyfit(gaussian, data[:,i], 1)
        ax.plot(x, gaussian*m[0]+m[1], '-', color=plt.cm.gist_rainbow(float(i)/N))

# plot the data against the Gaussian
f, axes = plt.subplots(1,2)
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(gaussian, data[:,i], '-+', color=plt.cm.gist_rainbow(float(i)/N))


r = np.sqrt(x[:,np.newaxis]**2 + x[np.newaxis,:]**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')

plt.figure()
s=slm_size/2.0
plt.imshow(res[:,:,2],extent=(-s,s,-s,s))
for thresh in [0.0,0.1,0.2,0.5,0.9]:
    I = res[:,:,2].copy()
    I /= np.max(I)
    I -= thresh
    I[I<0] = 0
    cx = np.sum(x[:,np.newaxis]*I)/np.sum(I)
    cy = np.sum(x[np.newaxis,:]*I)/np.sum(I)
    hide = plt.plot(cy,cx,'+')
    print "found centroid at {}, {} with threshold {}".format(cx, cy, thresh)


r = np.sqrt((x[:,np.newaxis]-cx)**2 + (x[np.newaxis,:]-cy)**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')
slm.centre=(cx,cy)
slm.radial_blaze_function = np.ones(384)
inner_edge_i = 1500//18 #bad
sd = 400/18.0
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#dim_slm(1)
#dim_slm(0.75)
#dim_slm(0.5)
#dim_slm(0.2)
#dim_slm(0.1)
#cam.exposure=-2
def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))

def brightest_g():
    time.sleep(0.1)
    cam.color_image()
    img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    #cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])

# Start by autofocusing (optimising mode 2)
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})

print zernike_coefficients

prev_zcs = zernike_coefficients
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})

print zernike_coefficients
prev_zcs = zernike_coefficients
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})

print zernike_coefficients

print prev_zcs









zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)


zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)


prev_zcs = zernike_coefficients
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)


print zernike_coefficients
np.save('zernike_coefficients_d130_1.npy',prev_zcs)
np.save('zernike_coefficients_d130_1.npy',zernike_coefficients)
prev_zcs
np.save('zernike_coefficients_d130_1.npy',prev_zcs)
np.save('zernike_coefficients_d130_2.npy',zernike_coefficients)
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)
np.save('zernike_coefficients_d130_3.npy',zernike_coefficients)
print zernike_coefficients
runfile('C:/local/dev/slm_interference_lithography/double_slit_holograms.py', wdir='C:/local/dev/slm_interference_lithography')
np.load('hamamatsu_633_lut.npz')
print np.load('hamamatsu_633_lut.npz')
test = np.load('hamamatsu_633_lut.npz')
test[1]
print test
test.keys
test.keys()
test.keys.f.'phases'
test.keys.f.phases
test.keys.phases
test.keys(phases)
test.keys('phases')
test.keys()
test.f.phases
runfile('C:/local/dev/slm_interference_lithography/double_slit_holograms.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%qt gui
%gui qt
cam.show_gui()
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%gui qt
cam.show_gui()
test_spot = [20,-10,0,1];
#distance = 2900e3
#for hamatsu set up
distance = 1300e3
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)

test_spot = [20,-10,0,1];
#distance = 2900e3
#for hamatsu set up
distance = 1000e3
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
test_spot = [20,-10,0,1];
#distance = 2900e3
#for hamatsu set up
distance = 800e3

slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
test_spot = [20,-10,0,1];
#distance = 2900e3
#for hamatsu set up
distance = 800e3

slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
test_spot = [20,-10,0,1];
#distance = 2900e3
#for hamatsu set up
distance = 800e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
## TURN LIGHTS OFF!
#cam.exposure=-2
#snap = calibrate_hdr()

# Sequential Shack-Hartmann sensor
slm.make_spots([test_spot + [0,0,0.075,0]])
test_spot = [20,-10,0,1];
#distance = 2900e3
#for hamatsu set up
distance = 1300e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
## TURN LIGHTS OFF!
#cam.exposure=-2
#snap = calibrate_hdr()

# Sequential Shack-Hartmann sensor
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5

## ---(Thu Sep 13 17:47:50 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%gui qt
cam.show_gui()
test_spot = [20,-10,0,1];
#distance = 2900e3
#for hamatsu set up
distance = 1300e3

## ---(Fri Sep 14 12:14:22 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
test_spot = [20,-10,0,1];
#distance = 2900e3
#for hamatsu set up
distance = 1300e3
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
test_spot = [20,-10,0,1];
#distance = 2900e3
#for hamatsu set up
distance = 1300e3
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
test_spot = [20,-10,0,1];
#distance = 2900e3
#for hamatsu set up
distance = 1300e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
## TURN LIGHTS OFF!
#cam.exposure=-2
#snap = calibrate_hdr()
test_spot = [20,-10,0,1];
#distance = 2900e3
#for hamatsu set up
distance = 1300e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
## TURN LIGHTS OFF!
#cam.exposure=-2
#snap = calibrate_hdr()


## ---(Fri Sep 14 12:21:19 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')

## ---(Thu Oct 04 18:23:39 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
cam.show_gui()

## ---(Tue Oct 09 13:21:18 2018)---
import glob
filelist = glob.glob('C:\local\dev\slm_interference_lithography\Hamatsudata\hdrimagedata\testspot1\*.npy')
filelist
import numpy as np
import matplotlib.pyplot as plt
import time
import scipy.ndimage
from rgb_to_hdr import calibrate_hdr_from_rgb, hdr_from_rgb, fit_channels
import nplab.utils.gui
import nplab
import glob

# Loading exposure images into a list
#address C:\local\dev\slm_interference_lithography\Hamatsudata\hdrimagedata\testspot1
filelist = glob.glob('C:\local\dev\slm_interference_lithography\Hamatsudata\hdrimagedata\testspot1\*.npy')
import numpy as np
import matplotlib.pyplot as plt
import time
import scipy.ndimage
import nplab.utils.gui
import nplab
import glob

# Loading exposure images into a list
#address C:\local\dev\slm_interference_lithography\Hamatsudata\hdrimagedata\testspot1
filelist = glob.glob('C:\local\dev\slm_interference_lithography\Hamatsudata\hdrimagedata\testspot1\*.npy')
filelist
filelist(1)
filelist[1]
filelist = glob.glob('*.np[yz]')
filelist
numpy_vars = {}
for np_name in glob.glob('*.np[yz]'):
    numpy_vars[np_name] = np.load(np_name)


numpy_vars
glob.glob('*.np[yz]')
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot1/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot1')
numpy_vars
np_name
import re
re.findall(r'\d+', 'hello 42 I\'m a 32 string 30')
re.findall(r'\d+', np_name)
exposure_times = np.array()
exposure_times = np.array([], dtype = np.float32)
string_nos = re.findall(r'\d+', np_name)
string_nos
string_nos[2]
string_nos[1]
exposure_times = np.array([], dtype = np.float32)
numpy_vars = {}
for np_name in glob.glob('*.np[yz]'):
    numpy_vars[np_name] = np.load(np_name)
    #Get exposure times from filename
    string_nos = re.findall(r'\d+', np_name)
    exposure_times.append(string_nos[1])


exposure_times = np.array([], dtype = np.float32)
numpy_vars = {}
for np_name in glob.glob('*.np[yz]'):
    numpy_vars[np_name] = np.load(np_name)
    #Get exposure times from filename
    string_nos = re.findall(r'\d+', np_name)
    exposure_times.append(string_nos[1])


exposure_times = np.array([], dtype = np.float32)
exposure_times
exposure_times.extend(string_nos[1])
exposure_times = []
exposure_times.extend(string_nos[1])
exposure_times
exposure_times.append(string_nos[1])
exposure_times
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot1/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot1')
exposure_times
exposure_times = exposure_times*1e-5
exposure_times = exposure_times[1]*1e-5
[float(i) for i in exposure_times]
expt_float = [float(i) for i in exposure_times]
expt_float = [float(i) for i in exposure_times]
expt_float = expt_float*1e-5
expt_float = expt_float[1]*1e-5
expt_float = [float(i)*1e-5 for i in exposure_times]
expt_float
"""
Created on Tue Oct 09 13:22:46 2018

@author: kh302
"""

import numpy as np
import matplotlib.pyplot as plt
import time
import scipy.ndimage
import nplab.utils.gui
import nplab
import glob
import re

# Loading exposure images into a list
#address C:\local\dev\slm_interference_lithography\Hamatsudata\hdrimagedata\testspot1
exposure_times = []
numpy_vars = {}
for np_name in glob.glob('*.np[yz]'):
    numpy_vars[np_name] = np.load(np_name)
    #Get exposure times from filename
    string_nos = re.findall(r'\d+', np_name)
    exposure_times.append(string_nos[1])


#divide exposure_times to get back to decimal places
expt_float = [float(i)*1e-5 for i in exposure_times]
exposure_times = expt_float

# Merge exposures to HDR image
 merge_debvec = cv2.createMergeDebevec()
 hdr_debvec = merge_debvec.process(numpy_vars, times=exposure_times.copy())
 merge_robertson = cv2.createMergeRobertson()
 hdr_robertson = merge_robertson.process(img_list, times=exposure_times.copy())
merge_debvec = cv2.createMergeDebevec()
hdr_debvec = merge_debvec.process(numpy_vars, times=exposure_times.copy())
merge_robertson = cv2.createMergeRobertson()
hdr_robertson = merge_robertson.process(img_list, times=exposure_times.copy())
"""
Created on Tue Oct 09 13:22:46 2018

@author: kh302
"""

import numpy as np
import matplotlib.pyplot as plt
import time
import scipy.ndimage
import nplab.utils.gui
import nplab
import glob
import re
import cv2

# Loading exposure images into a list
#address C:\local\dev\slm_interference_lithography\Hamatsudata\hdrimagedata\testspot1
exposure_times = []
numpy_vars = {}
for np_name in glob.glob('*.np[yz]'):
    numpy_vars[np_name] = np.load(np_name)
    #Get exposure times from filename
    string_nos = re.findall(r'\d+', np_name)
    exposure_times.append(string_nos[1])


#divide exposure_times to get back to decimal places
expt_float = [float(i)*1e-5 for i in exposure_times]
exposure_times = expt_float

# Merge exposures to HDR image
merge_debvec = cv2.createMergeDebevec()
hdr_debvec = merge_debvec.process(numpy_vars, times=exposure_times.copy())
merge_robertson = cv2.createMergeRobertson()
hdr_robertson = merge_robertson.process(img_list, times=exposure_times.copy())
numpy_vars
numpy_vars[np_name]
exposure_times[0]
i = 0
i += 1
i
hdr_array = np.full_like(numpy_vars[np_name], 0)
hdr_array = np.full_like(numpy_vars[np_name], 0)
i = 0
for np_name in numpy_vars:
    hdr_contribution = (numpy_vars[np_name])/exposure_times[i]
    i += 1
    hdr_array += hdr_contribution


plt.imshow(hdr_array)
max(hdr_array)
hdr_array
hdr_array.amax
hdr_array.amax()
np.amax(hdr_array)
import numpy as np
import matplotlib.pyplot as plt
import time
import scipy.ndimage
import nplab.utils.gui
import nplab
import glob
import re
import cv2

# Loading exposure images into a list
#address C:\local\dev\slm_interference_lithography\Hamatsudata\hdrimagedata\testspot1
exposure_times = []
numpy_vars = {}
for np_name in glob.glob('*.np[yz]'):
    numpy_vars[np_name] = np.load(np_name)
    #Get exposure times from filename
    string_nos = re.findall(r'\d+', np_name)
    exposure_times.append(string_nos[1])


#divide exposure_times to get back to decimal places
expt_float = [float(i)*1e-5 for i in exposure_times]
exposure_times = expt_float

# Merge exposures to HDR image
hdr_array = np.full_like(numpy_vars[np_name], 0)
i = 0
for np_name in numpy_vars:
    hdr_contribution = (numpy_vars[np_name])/exposure_times[i]
    i += 1
    hdr_array += hdr_contribution


#for plotting purposes only
normval = np.amax(hdr_array)
hdr_array_norm = hdr_array/normval
plt.imshow(hdr_array)
np.amax(hdr_array_norm)
plt.imshow(hdr_array_norm)
original = cv2.imread(hdr_array_norm, cv2.CV_LOAD_IMAGE_GRAYSCALE)
scipy.misc.imsave('outfile.jpg', hdr_array_norm)
original = cv2.imread("outfile.jpg", cv2.CV_LOAD_IMAGE_GRAYSCALE)
retval, image = cv2.threshold(original, 50, 255, cv2.cv.CV_THRESH_BINARY)

el = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
image = cv2.dilate(image, el, iterations=6)

cv2.imwrite("dilated.png", image)

contours, hierarchy = cv2.findContours(
    image,
    cv2.cv.CV_RETR_LIST,
    cv2.cv.CV_CHAIN_APPROX_SIMPLE
)

drawing = cv2.imread("outfile.jpg")

centers = []
radii = []
for contour in contours:
    area = cv2.contourArea(contour)
    
    # there is one contour that contains all others, filter it out
    if area > 500:
        continue
    
    br = cv2.boundingRect(contour)
    radii.append(br[2])
    
    m = cv2.moments(contour)
    center = (int(m['m10'] / m['m00']), int(m['m01'] / m['m00']))
    centers.append(center)


print("There are {} circles".format(len(centers)))

radius = int(np.average(radii)) + 5

for center in centers:
    cv2.circle(drawing, center, 3, (255, 0, 0), -1)
    cv2.circle(drawing, center, radius, (0, 255, 0), 1)


cv2.imwrite("drawing.png", drawing)
original = cv2.imread("outfile.jpg", cv2.CV_LOAD_IMAGE_GRAYSCALE)
retval, image = cv2.threshold(original, 50, 255, cv2.cv.CV_THRESH_BINARY)
el = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
image = cv2.dilate(image, el, iterations=6)

cv2.imwrite("dilated.png", image)
plt.imshow(dilated.png)
plt.imshow('dilated.png')
contours, hierarchy = cv2.findContours(
    image,
    cv2.cv.CV_RETR_LIST,
    cv2.cv.CV_CHAIN_APPROX_SIMPLE
)
drawing = cv2.imread("outfile.jpg")

centers = []
radii = []
for contour in contours:
    area = cv2.contourArea(contour)


if area > 500:
    continue


for contour in contours:
    area = cv2.contourArea(contour)
    
    # there is one contour that contains all others, filter it out
    if area > 500:
        continue
    
    br = cv2.boundingRect(contour)
    radii.append(br[2])
    
    m = cv2.moments(contour)
    center = (int(m['m10'] / m['m00']), int(m['m01'] / m['m00']))
    centers.append(center)


print("There are {} circles".format(len(centers)))

br = cv2.boundingRect(contour)
radii.append(br[2])

m = cv2.moments(contour)
center = (int(m['m10'] / m['m00']), int(m['m01'] / m['m00']))
centers.append(center)
print("There are {} circles".format(len(centers)))

radius = int(np.average(radii)) + 5

for center in centers:
    cv2.circle(drawing, center, 3, (255, 0, 0), -1)
    cv2.circle(drawing, center, radius, (0, 255, 0), 1)


cv2.imwrite("drawing.png", drawing)
centers = []
radii = []
for contour in contours:
    area = cv2.contourArea(contour)
    br = cv2.boundingRect(contour)
    radii.append(br[2])
    
    m = cv2.moments(contour)
    center = (int(m['m10'] / m['m00']), int(m['m01'] / m['m00']))
    centers.append(center)


print("There are {} circles".format(len(centers)))

radius = int(np.average(radii)) + 5

for center in centers:
    cv2.circle(drawing, center, 3, (255, 0, 0), -1)
    cv2.circle(drawing, center, radius, (0, 255, 0), 1)


cv2.imwrite("drawing.png", drawing)
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot1/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot1')
center
centers
radii
y = centers(1)
y = centers[1]
y
centers[1](0)
centers[1][1]
for order in centers:
    y = centers[order][0] - max(radii)
    x = centers[order][1] - max(radii)
    h = max(radii)
    crop_img = img[y:y+h, x:x+h]
    cv2.imshow("cropped", crop_img)


y = centers[order][0] - max(radii)
for order in centers:
    print order


len(centers)
for circleno in len(centers):
    y = centers[circleno][0] - max(radii)
    x = centers[circleno][1] - max(radii)
    h = max(radii)
    crop_img = img[y:y+h, x:x+h]
    cv2.imshow("cropped", crop_img)


for circleno from 0 to len(centers):


for circleno from 0:len(centers):
    y = centers[circleno][0] - max(radii)
    x = centers[circleno][1] - max(radii)
    h = max(radii)
    crop_img = img[y:y+h, x:x+h]
    cv2.imshow("cropped", crop_img)


for circleno in 0:len(centers):
    y = centers[circleno][0] - max(radii)
    x = centers[circleno][1] - max(radii)
    h = max(radii)
    crop_img = img[y:y+h, x:x+h]
    cv2.imshow("cropped", crop_img)


for circleno in range(0, len(radii) - 1):
    y = centers[circleno][0] - max(radii)
    x = centers[circleno][1] - max(radii)
    h = max(radii)
    crop_img = img[y:y+h, x:x+h]
    cv2.imshow("cropped", crop_img)


for circleno in range(0, len(radii) - 1):
    print circleno


len(radii)
for circleno in range(0, len(radii)):
    print circleno


plt.imshow(original)
for circleno in range(0, len(radii)):
    print circleno
    y = centers[circleno][0] - max(radii)
    x = centers[circleno][1] - max(radii)
    h = max(radii)
    crop_img = original[y:y+h, x:x+h]
    cv2.imshow("cropped", crop_img)


for circleno in range(0, len(radii)):
    print circleno
    y = centers[circleno][0] - max(radii)*0.5
    x = centers[circleno][1] - max(radii)*0.5
    h = max(radii)*0.5
    crop_img = original[y:y+h, x:x+h]
    cv2.imshow("cropped", crop_img)


y
int(y)
for circleno in range(0, len(radii)):
    print circleno
    y = int(centers[circleno][0] - max(radii)*0.5)
    x = int(centers[circleno][1] - max(radii)*0.5)
    h = max(radii)*0.5
    crop_img = original[y:y+h, x:x+h]
    cv2.imshow("cropped", crop_img)


for circleno in range(0, len(radii)):
    print circleno
    y = int(centers[circleno][0] - max(radii)*0.5)
    x = int(centers[circleno][1] - max(radii)*0.5)
    h = int(max(radii)*0.5)
    crop_img = original[y:y+h, x:x+h]
    cv2.imshow("cropped", crop_img)


cropsize = max(radii)*0.9
for circleno in range(0, len(radii)):
    print circleno
    y = int(centers[circleno][0] - cropsize*0.5)
    x = int(centers[circleno][1] - cropsize*0.5)
    h = cropsize
    crop_img = original[y:y+h, x:x+h]
    cv2.imshow("cropped", crop_img)


cropsize = int(max(radii)*0.9)
for circleno in range(0, len(radii)):
    print circleno
    y = int(centers[circleno][0] - cropsize*0.5)
    x = int(centers[circleno][1] - cropsize*0.5)
    h = cropsize
    crop_img = original[y:y+h, x:x+h]
    cv2.imshow("cropped", crop_img)


y
x
plt.imcrop(original)
cv2.imcrop(original)

## ---(Tue Oct 09 18:19:36 2018)---
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot1/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot1')
crop_img = im.crop((0, 0, 500, 500))
crop_img = original.crop((0, 0, 500, 500))
im = Image.open('outfile.jpg')
crop_img = im.crop((0, 0, 500, 500))
plt.imshow(crop_img)
plt.imcrop(original)
crop_img.show()
cropsize = int(max(radii)*0.95)
im = Image.open('outfile.jpg')
for circleno in range(0, len(radii)):
    print circleno
    y = int(centers[circleno][0] - cropsize*0.5)
    x = int(centers[circleno][1] - cropsize*0.5)
    h = cropsize*0.5
    crop_img = im.crop((y, x, y + h, x + h))


crop_img.show()
cropsize = int(max(radii)*0.95)
im = Image.open('outfile.jpg')
for circleno in range(0, len(radii)):
    y = int(centers[circleno][0] - cropsize*0.5)
    x = int(centers[circleno][1] - cropsize*0.5)
    h = cropsize*0.5
    #upper left, lower right
    crop_img = im.crop((x, y, x + h, y + h))
    crop_img.show()


cropsize = int(max(radii)*0.95)
im = Image.open('outfile.jpg')
for circleno in range(0, len(radii)):
    y = int(centers[circleno][0] - cropsize*0.5)
    x = int(centers[circleno][1] - cropsize*0.5)
    h = cropsize*0.5
    #upper left, lower right
    crop_img = im.crop((y, x, y + h, x + h))
    crop_img.show()


cropsize = int(max(radii)*0.95)
im = Image.open('outfile.jpg')
for circleno in range(0, len(radii)):
    x = int(centers[circleno][0] - cropsize*0.5)
    y = int(centers[circleno][1] - cropsize*0.5)
    h = cropsize*0.5
    #upper left, lower right
    crop_img = im.crop((y, x, y + h, x + h))
    crop_img.show()


cropsize = int(max(radii)*0.95)
im = Image.open('outfile.jpg')
for circleno in range(0, len(radii)):
    x = int(centers[circleno][0] - cropsize*0.5)
    y = int(centers[circleno][1] - cropsize*0.5)
    h = cropsize*0.5
    #upper left, lower right
    crop_img = im.crop((x, y, x + h, y + h))
    crop_img.show()


cropsize = int(max(radii)*0.95)
im = Image.open('outfile.jpg')
for circleno in range(0, len(radii)):
    x = int(centers[circleno][0] - cropsize*0.5)
    y = int(centers[circleno][1] - cropsize*0.5)
    h = cropsize*0.5
    #upper left, lower right
    crop_img = im.crop((x, y+h, x + h, y))
    crop_img.show()


cropsize = int(max(radii)*0.95)
im = Image.open('outfile.jpg')
for circleno in range(0, len(radii)):
    x = int(centers[circleno][0] - cropsize*0.5)
    y = int(centers[circleno][1] - cropsize*0.5)
    h = cropsize*0.5
    #upper left, lower right
    crop_img = im.crop((x, y + h, x + h, y))
    crop_img.show()


cropsize = int(max(radii)*0.9)
im = Image.open('outfile.jpg')
for circleno in range(0, len(radii)):
    x = int(centers[circleno][0] - cropsize*0.5)
    y = int(centers[circleno][1] - cropsize*0.5)
    h = cropsize*0.5
    #upper left, lower right
    crop_img = im.crop((x, y + h, x + h, y))
    crop_img.show()


cropsize = int(max(radii)*0.8)
im = Image.open('outfile.jpg')
for circleno in range(0, len(radii)):
    x = int(centers[circleno][0] - cropsize*0.5)
    y = int(centers[circleno][1] - cropsize*0.5)
    h = cropsize*0.5
    #upper left, lower right
    crop_img = im.crop((x, y + h, x + h, y))
    crop_img.show()


cropsize = int(max(radii)*0.5)
im = Image.open('outfile.jpg')
for circleno in range(0, len(radii)):
    x = int(centers[circleno][0] - cropsize*0.5)
    y = int(centers[circleno][1] - cropsize*0.5)
    h = cropsize*0.5
    #upper left, lower right
    crop_img = im.crop((x, y + h, x + h, y))
    crop_img.show()


x
y
cropsize = int(max(radii)*0.95)
im = Image.open('outfile.jpg')
for circleno in range(0, len(radii)):
    x = int(centers[circleno][0] - cropsize*0.5)
    y = int(centers[circleno][1] - cropsize*0.5)
    h = cropsize*0.5
    #upper left, lower right
    crop_img = im.crop((y+h, x, y, x+h))
    crop_img.show()


cropsize = int(max(radii)*0.95)
im = Image.open('outfile.jpg')
for circleno in range(0, len(radii)):
    y = int(centers[circleno][0] - cropsize*0.5)
    x = int(centers[circleno][1] - cropsize*0.5)
    h = cropsize*0.5
    #upper left, lower right
    crop_img = im.crop((y+h, x, y, x+h))
    crop_img.show()


cropsize = int(max(radii)*0.95)
im = Image.open('outfile.jpg')
for circleno in range(0, len(radii)):
    y = int(centers[circleno][0] - cropsize*0.5)
    x = int(centers[circleno][1] - cropsize*0.5)
    h = cropsize*0.5
    #upper left, lower right
    crop_img = im.crop((x, y+h, x+h, y))
    crop_img.show()


runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot1/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot1')

## ---(Wed Oct 10 11:21:32 2018)---
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot1/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot1')
plt.imshow(crop_img)
cropsize = int(max(radii)*0.95)
im = Image.open('outfile.jpg')
for circleno in range(0, len(radii)):
    y = int(centers[circleno][0] - cropsize*0.5)
    x = int(centers[circleno][1] - cropsize*0.5)
    h = cropsize*0.5
    #upper left, lower right
    #crop_img = im.crop((x, y+h, x+h, y))
    #crop_img.show()
    crop_img = im[x:x+h, y:y+h]


cropsize = int(max(radii)*0.95)
im = Image.open('outfile.jpg')
for circleno in range(0, len(radii)):
    y = int(centers[circleno][0] - cropsize*0.5)
    x = int(centers[circleno][1] - cropsize*0.5)
    h = cropsize*0.5
    #upper left, lower right
    #crop_img = im.crop((x, y+h, x+h, y))
    #crop_img.show()
    crop_img = (im)[x:x+h, y:y+h]


runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot1/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot1')
crop_img = (original)[x:x+h, y:y+h]
crop_img = (img)[x:x+h, y:y+h]
plt.imshow(im)
plt.imshow(original)
crop_img = (original)[x:x+h, y:y+h]
cropsize = int(max(radii)*0.95)
im = Image.open('outfile.jpg')
for circleno in range(0, len(radii)):
    y = int(centers[circleno][0] - cropsize*0.5)
    x = int(centers[circleno][1] - cropsize*0.5)
    h = int(cropsize*0.5)
    #upper left, lower right
    #crop_img = im.crop((x, y+h, x+h, y))
    #crop_img.show()
    crop_img = (original)[x:x+h, y:y+h]


plt.imshow(crop_img)
cropsize = max(radii)*0.95*0.5
im = Image.open('outfile.jpg')
for circleno in range(0, len(radii)):
    y = centers[circleno][0]
    x = centers[circleno][1]
    h = int(cropsize)
    #upper left, lower right
    #crop_img = im.crop((x, y+h, x+h, y))
    #crop_img.show()
    crop_img = (original)[x-h:x+h, y-h:y+h]


plt.imshow(crop_img)
cropsize = max(radii)*0.95*0.5
im = Image.open('outfile.jpg')
for circleno in range(0, len(radii)):
    y = centers[circleno][0]
    x = centers[circleno][1]
    h = int(cropsize)
    #upper left, lower right
    #crop_img = im.crop((x, y+h, x+h, y))
    #crop_img.show()
    crop_img = (original)[x-h:x+h, y-h:y+h]
    plt.imshow(crop_img)


runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot1/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot1')
print('Circle %d', circleno)
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot1/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot1')
print('Circle %i', circleno)
print'Circle %i', circleno
print'Circle %i', %circleno
print('Circle %i', %circleno)
print('Circle %i', % circleno)
print('Circle %s', %circleno)
print('Circle %s' %circleno)
cropsize = max(radii)*0.95*0.5
for circleno in range(0, len(radii)):
    print('Circle %s' %circleno)
    y = centers[circleno][0]
    x = centers[circleno][1]
    h = int(cropsize)
    #upper left, lower right
    #crop_img = im.crop((x, y+h, x+h, y))
    #crop_img.show()
    crop_img[circleno] = (original)[x-h:x+h, y-h:y+h]


cropsum = sum(crop_img)
cropsum
cropsum = numpy.sum(crop_img)
cropsum = np.sum(crop_img)
cropsum
cropsize = max(radii)*0.95*0.5
for circleno in range(0, len(radii)):
    print('Circle %s' %circleno)
    y = centers[circleno][0]
    x = centers[circleno][1]
    h = int(cropsize)
    #upper left, lower right
    #crop_img = im.crop((x, y+h, x+h, y))
    #crop_img.show()
    crop_img = (original)[x-h:x+h, y-h:y+h]
    plt.imshow(crop_img)
    #sum values in cropped image
    cropsum = np.sum(crop_img)
    allsums[circleno] = cropsum


allsums = []
cropsize = max(radii)*0.95*0.5
for circleno in range(0, len(radii)):
    print('Circle %s' %circleno)
    y = centers[circleno][0]
    x = centers[circleno][1]
    h = int(cropsize)
    #upper left, lower right
    #crop_img = im.crop((x, y+h, x+h, y))
    #crop_img.show()
    crop_img = (original)[x-h:x+h, y-h:y+h]
    plt.imshow(crop_img)
    #sum values in cropped image
    cropsum = np.sum(crop_img)
    allsums[circleno] = cropsum


allsums[0]
allsums = {}
cropsize = max(radii)*0.95*0.5
for circleno in range(0, len(radii)):
    print('Circle %s' %circleno)
    y = centers[circleno][0]
    x = centers[circleno][1]
    h = int(cropsize)
    #upper left, lower right
    #crop_img = im.crop((x, y+h, x+h, y))
    #crop_img.show()
    crop_img = (original)[x-h:x+h, y-h:y+h]
    plt.imshow(crop_img)
    #sum values in cropped image
    cropsum = np.sum(crop_img)
    allsums{circleno} = cropsum


allsums = ()
cropsize = max(radii)*0.95*0.5
for circleno in range(0, len(radii)):
    print('Circle %s' %circleno)
    y = centers[circleno][0]
    x = centers[circleno][1]
    h = int(cropsize)
    #upper left, lower right
    #crop_img = im.crop((x, y+h, x+h, y))
    #crop_img.show()
    crop_img = (original)[x-h:x+h, y-h:y+h]
    plt.imshow(crop_img)
    #sum values in cropped image
    cropsum = np.sum(crop_img)
    allsums(circleno) = cropsum


allsums = []
cropsize = max(radii)*0.95*0.5
for circleno in range(0, len(radii)):
    print('Circle %s' %circleno)
    y = centers[circleno][0]
    x = centers[circleno][1]
    h = int(cropsize)
    #upper left, lower right
    #crop_img = im.crop((x, y+h, x+h, y))
    #crop_img.show()
    crop_img = (original)[x-h:x+h, y-h:y+h]
    plt.imshow(crop_img)
    #sum values in cropped image
    cropsum = np.sum(crop_img)
    allsums[circleno+1] = cropsum


allsums = []
cropsize = max(radii)*0.95*0.5
for circleno in range(0, len(radii)):
    print('Circle %s' %circleno)
    y = centers[circleno][0]
    x = centers[circleno][1]
    h = int(cropsize)
    #upper left, lower right
    #crop_img = im.crop((x, y+h, x+h, y))
    #crop_img.show()
    crop_img = (original)[x-h:x+h, y-h:y+h]
    plt.imshow(crop_img)
    #sum values in cropped image
    cropsum = np.sum(crop_img)
    allsums.append(cropsum)


allsums
max(original)
amax.original
original
plt.imshow(original)
np.amax(original)
size(crop_img)
len(crop_img)
np.shape(crop_img)
crop_img_size = np.shape(crop_img)
crop_img_size(0)*crop_img_size(1)
crop_img_size[0]*crop_img_size[1]
int(crop_img_size[0]*crop_img_size[1])
cropsum = np.sum(crop_img)/(255*int(crop_img_size[0]*crop_img_size[1]))
cropsum
allsums = []
cropsize = max(radii)*0.95*0.5
for circleno in range(0, len(radii)):
    print('Circle %s' %circleno)
    y = centers[circleno][0]
    x = centers[circleno][1]
    h = int(cropsize)
    #upper left, lower right
    #crop_img = im.crop((x, y+h, x+h, y))
    #crop_img.show()
    crop_img = (original)[x-h:x+h, y-h:y+h]
    plt.imshow(crop_img)
    crop_img_size = np.shape(crop_img)
    #sum values in cropped image
    cropsum = np.sum(crop_img)/(255*int(crop_img_size[0]*crop_img_size[1]))
    allsums.append(cropsum)


allsums
np.sum(crop_img)
np.sum(crop_img)/(255*int(crop_img_size[0]*crop_img_size[1]))
int(crop_img_size[0]*crop_img_size[1])
np.sum(crop_img)/(255*float(crop_img_size[0]*crop_img_size[1]))
allsums = []
cropsize = max(radii)*0.95*0.5
for circleno in range(0, len(radii)):
    print('Circle %s' %circleno)
    y = centers[circleno][0]
    x = centers[circleno][1]
    h = int(cropsize)
    #upper left, lower right
    #crop_img = im.crop((x, y+h, x+h, y))
    #crop_img.show()
    crop_img = (original)[x-h:x+h, y-h:y+h]
    plt.imshow(crop_img)
    crop_img_size = np.shape(crop_img)
    #sum values in cropped image
    cropsum = np.sum(crop_img)/(255*float(crop_img_size[0]*crop_img_size[1]))
    allsums.append(cropsum)


allsums
allsums = []
cropsize = max(radii)*0.95*0.5
for circleno in range(0, len(radii)):
    print('Circle %s' %circleno)
    y = centers[circleno][0]
    x = centers[circleno][1]
    h = int(cropsize)
    #upper left, lower right
    #crop_img = im.crop((x, y+h, x+h, y))
    #crop_img.show()
    crop_img = (original)[x-h:x+h, y-h:y+h]
    print(plt.imshow(crop_img))
    crop_img_size = np.shape(crop_img)
    #sum values in cropped image
    cropsum = np.sum(crop_img)/(255*float(crop_img_size[0]*crop_img_size[1]))
    allsums.append(cropsum)


allsums = []
all_crop_img = {}
cropsize = max(radii)*0.95*0.5
for circleno in range(0, len(radii)):
    print('Circle %s' %circleno)
    y = centers[circleno][0]
    x = centers[circleno][1]
    h = int(cropsize)
    #upper left, lower right
    #crop_img = im.crop((x, y+h, x+h, y))
    #crop_img.show()
    crop_img = (original)[x-h:x+h, y-h:y+h]
    all_crop_img[circleno] = crop_img
    crop_img_size = np.shape(crop_img)
    #sum values in cropped image
    cropsum = np.sum(crop_img)/(255*float(crop_img_size[0]*crop_img_size[1]))
    allsums.append(cropsum)


all_crop_img
plt.imshow(all_crop_img{1})
plt.imshow(all_crop_img[1])
plt.imshow(all_crop_img[2])
plt.imshow(all_crop_img[3])
plt.imshow(all_crop_img[4])
plt.imshow(all_crop_img[5])
plt.imshow(all_crop_img[6])
allsums = {}
all_crop_img = {}
cropsize = max(radii)*0.95*0.5
for circleno in range(0, len(radii)):
    print('Circle %s' %circleno)
    y = centers[circleno][0]
    x = centers[circleno][1]
    h = int(cropsize)
    #upper left, lower right
    #crop_img = im.crop((x, y+h, x+h, y))
    #crop_img.show()
    crop_img = (original)[x-h:x+h, y-h:y+h]
    all_crop_img[circleno] = crop_img
    crop_img_size = np.shape(crop_img)
    #sum values in cropped image
    cropsum = np.sum(crop_img)/(255*float(crop_img_size[0]*crop_img_size[1]))
    allsums[circleno] = cropsum


allsums]
allsums
plt.imshow(all_crop_img[2])
max(allsums)
allsums/allsums[5]
for item in allsums.values() print item
for item in allsums.values(): print item
zeroordercircle = max(allsums)
orderratios = {}
for ckey in allsums.keys():
    orderratios[ckey] = allsums[ckey]/allsums[zeroordercircle]


orderratios
zeroordercircle = max(allsums)
max(allsums.values())
def keywithmaxval(d):
     """ a) create a list of the dict's keys and values; 
         b) return the key with the max value"""  
     v=list(d.values())
     k=list(d.keys())
     return k[v.index(max(v))]


keywithmaxval(allsums)
zeroordercircle = keywithmaxval(allsums)
orderratios = {}
for ckey in allsums.keys():
    orderratios[ckey] = allsums[ckey]/allsums[zeroordercircle]


orderratios
np.save('orderratios.npy', orderratios) 
read_dictionary = np.load('orderratios.npy').item()
read_dictionary
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot2/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot2')
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot3/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot3')
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot2/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot2')
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot1/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot1')
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot4/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot4')
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot5/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot5')
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot6/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot6')
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot7/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot7')
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/horizontal/testspot5/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/horizontal/testspot5')
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/horizontal/testspot10/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/horizontal/testspot10')
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/horizontal/testspot20/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/horizontal/testspot20')
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/vertical/testspot5/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/vertical/testspot5')
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/vertical/testspot7/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/vertical/testspot7')
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/vertical/testspot10/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/vertical/testspot10')
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/vertical/testspot20/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/vertical/testspot20')
runfile('C:/local/dev/slm_interference_lithography/BNS/Pictures/450nmtestspoth5/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/BNS/Pictures/450nmtestspoth5')
runfile('C:/local/dev/slm_interference_lithography/BNS/Pictures/450nmttestspoth10/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/BNS/Pictures/450nmttestspoth10')
runfile('C:/local/dev/slm_interference_lithography/BNS/Pictures/700nmtestspot10-1/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/BNS/Pictures/700nmtestspot10-1')
runfile('C:/local/dev/slm_interference_lithography/BNS/Pictures/700nmtestspot20/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/BNS/Pictures/700nmtestspot20')
runfile('C:/local/dev/slm_interference_lithography/BNS/Pictures/testspoth5/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/BNS/Pictures/testspoth5')
runfile('C:/local/dev/slm_interference_lithography/BNS/Pictures/testspoth10/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/BNS/Pictures/testspoth10')
runfile('C:/local/dev/slm_interference_lithography/BNS/Pictures/testspoth20/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/BNS/Pictures/testspoth20')
runfile('C:/local/dev/slm_interference_lithography/BNS/Pictures/testspotv5/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/BNS/Pictures/testspotv5')
runfile('C:/local/dev/slm_interference_lithography/BNS/Pictures/testspotv5-2/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/BNS/Pictures/testspotv5-2')
runfile('C:/local/dev/slm_interference_lithography/BNS/Pictures/testspotv7/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/BNS/Pictures/testspotv7')
runfile('C:/local/dev/slm_interference_lithography/BNS/Pictures/testspotv10/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/BNS/Pictures/testspotv10')
plt.imshow(hdr_array)
np.amax(hdr_array)
plt.imshow(hdr_array_norm)
imshow(numpy_vars{1})
numpy_vars[1]
numpy_vars(1)
numpy_vars(np_name)
numpy_vars[np_name]
plt.imshow(numpy_vars[np_name])
np_name
plt.imshow(numpy_vars[hdrdata_HeNe_BNS_f150mm_hdrdata_testspot100_exp13350.npy])
plt.imshow(numpy_vars['hdrdata_HeNe_BNS_f150mm_hdrdata_testspot100_exp13350.npy'])
np.amax(numpy_vars[np_name])
expt_float = [float(i)*1e-5 for i in exposure_times]
exposure_times = expt_float

#norm images
for np_name in glob.glob('*.np[yz]'):
    tempmaxval = np.amax(numpy_vars[np_name])
    norm_imgs = numpy_vars[np_name]/norm_imgs


norm_imgs = []
for np_name in glob.glob('*.np[yz]'):
    tempmaxval = np.amax(numpy_vars[np_name])
    norm_imgs = numpy_vars[np_name]/norm_imgs


norm_imgs = []
for np_name in glob.glob('*.np[yz]'):
    tempmaxval = np.amax(numpy_vars[np_name])
    norm_imgs = numpy_vars[np_name]/tempmaxval


plt.imshow(norm_imgs)
np.amax(norm_imgs)
norm_imgs = []
for np_name in glob.glob('*.np[yz]'):
    tempmaxval = np.amax(numpy_vars[np_name])
    norm_imgs.append(numpy_vars[np_name]/tempmaxval)


plt.imshow(norm_img[1])
plt.imshow(norm_imgs[1])
plt.imshow(norm_imgs[0])
exposure_times = []
numpy_vars = {}
for np_name in glob.glob('*.np[yz]'):
    numpy_vars[np_name] = np.load(np_name)
    #Get exposure times from filename
    string_nos = re.findall(r'\d+', np_name)
    exposure_times.append(string_nos[1])


#divide exposure_times to get back to decimal places
expt_float = [float(i)*1e-5 for i in exposure_times]
exposure_times = expt_float

#norm images
norm_imgs = []
for np_name in numpy_vars:
    tempmaxval = np.amax(numpy_vars[np_name])
    norm_imgs.append(numpy_vars[np_name]/tempmaxval)


plt.imshow(norm_imgs[0])
plt.imshow(norm_imgs[len(norm_imgs)])
plt.imshow(norm_imgs[len(norm_imgs)-1])
runfile('C:/local/dev/slm_interference_lithography/BNS/Pictures/testspotv10/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/BNS/Pictures/testspotv10')
exposure_times
max(exposure_times)
min(exposure_times)
runfile('C:/local/dev/slm_interference_lithography/BNS/Pictures/testspotv10/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/BNS/Pictures/testspotv10')
min(exposure_times)
max(exposure_times)
exposure_times = []
numpy_vars = {}
for np_name in glob.glob('*.np[yz]'):
    numpy_vars[np_name] = np.load(np_name)
    #Get exposure times from filename
    string_nos = re.findall(r'\d+', np_name)
    exposure_times.append(string_nos[1])


exposure_times = []
numpy_vars = {}
for np_name in glob.glob('*.np[yz]'):
    numpy_vars[np_name] = np.load(np_name)
    #Get exposure times from filename
    string_nos = re.findall(r'\d+', np_name)
    exposure_times.append(string_nos[1])


exposure_times
np_name
numpy_vars[np_name] = np.load(np_name)
string_nos = re.findall(r'\d+', np_name)
string_nos
len(string_nos)
runfile('C:/local/dev/slm_interference_lithography/BNS/Pictures/testspotv10/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/BNS/Pictures/testspotv10')
len(string_nos)
string_nos[3]
string_nos[2]
exposure_times = []
numpy_vars = {}
for np_name in glob.glob('*.np[yz]'):
    numpy_vars[np_name] = np.load(np_name)
    #Get exposure times from filename
    string_nos = re.findall(r'\d+', np_name)
    #always last number in file name
    exposure_times.append(string_nos[len(string_nos)-1])


runfile('C:/local/dev/slm_interference_lithography/BNS/Pictures/testspotv10/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/BNS/Pictures/testspotv10')
exposure_times
plt.imshow(hdr_array_norm)
tempmaxval
runfile('C:/local/dev/slm_interference_lithography/BNS/Pictures/testspotv10/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/BNS/Pictures/testspotv10')
plt.imshow(hdr_array_norm)
for np_name in numpy_vars:
    hdr_contribution = (numpy_vars[np_name])/exposure_times[i]
    print(exposure_times[i])
    i += 1
    hdr_array += hdr_contribution


hdr_array = np.full_like(numpy_vars[np_name], 0)
i = 0
for np_name in numpy_vars:
    hdr_contribution = (numpy_vars[np_name])/exposure_times[i]
    print(exposure_times[i])
    i += 1
    hdr_array += hdr_contribution


numpy_vars
numpy_vars{1}
numpy_varsp1]
numpy_vars[1]






numpy_vars[1]
exposure_times = []
numpy_vars = {}
hdr_array = []
for np_name in glob.glob('*.np[yz]'):
    numpy_vars[np_name] = np.load(np_name)
    #Get exposure times from filename
    string_nos = re.findall(r'\d+', np_name)
    #always last number in file name
    exposure_times.append(string_nos[len(string_nos)-1])
    exp_float = string_nos*1e-5
    hdr_contribution = (numpy_vars[np_name])/exp_float
    hdr_array += hdr_contribution


string_nos
exposure_times = []
numpy_vars = {}
hdr_array = []
for np_name in glob.glob('*.np[yz]'):
    numpy_vars[np_name] = np.load(np_name)
    #Get exposure times from filename
    string_nos = re.findall(r'\d+', np_name)
    #always last number in file name
    exposure_times.append(string_nos[len(string_nos)-1])
    exp_float = (string_nos[len(string_nos)-1])*1e-5
    hdr_contribution = (numpy_vars[np_name])/exp_float
    hdr_array += hdr_contribution


(string_nos[len(string_nos)-1])
exp_float = float(string_nos[len(string_nos)-1])*1e-5
exp_float
exposure_times = []
numpy_vars = {}
hdr_array = []
for np_name in glob.glob('*.np[yz]'):
    numpy_vars[np_name] = np.load(np_name)
    #Get exposure times from filename
    string_nos = re.findall(r'\d+', np_name)
    #always last number in file name
    exposure_times.append(string_nos[len(string_nos)-1])
    exp_float = float(string_nos[len(string_nos)-1])*1e-5
    hdr_contribution = (numpy_vars[np_name])/exp_float
    hdr_array += hdr_contribution


hdr_contribution
plt.imshow(hdr_array)
plt.imshow(hdr_contribution)
hdr_array
type(hdr_array)
hdr_array = ()
type(hdr_array)
exposure_times = []
numpy_vars = {}
assignswitch = 0
for np_name in glob.glob('*.np[yz]'):
    numpy_vars[np_name] = np.load(np_name)
    #Get exposure times from filename
    string_nos = re.findall(r'\d+', np_name)
    #always last number in file name
    exposure_times.append(string_nos[len(string_nos)-1])
    exp_float = float(string_nos[len(string_nos)-1])*1e-5
    hdr_contribution = (numpy_vars[np_name])/exp_float
    if assignswitch = 0 :
        hdr_array = np.full_like(numpy_vars[np_name], 0)
        assignswitch = 1
    hdr_array += hdr_contribution


exposure_times = []
numpy_vars = {}
assignswitch = 0
for np_name in glob.glob('*.np[yz]'):
    numpy_vars[np_name] = np.load(np_name)
    #Get exposure times from filename
    string_nos = re.findall(r'\d+', np_name)
    #always last number in file name
    exposure_times.append(string_nos[len(string_nos)-1])
    exp_float = float(string_nos[len(string_nos)-1])*1e-5
    hdr_contribution = (numpy_vars[np_name])/exp_float
    if assignswitch == 0 :
        hdr_array = np.full_like(numpy_vars[np_name], 0)
        assignswitch = 1
    hdr_array += hdr_contribution


exposure_times = []
numpy_vars = {}
assignswitch = 0
for np_name in glob.glob('*.np[yz]'):
    numpy_vars[np_name] = np.load(np_name)
    #Get exposure times from filename
    string_nos = re.findall(r'\d+', np_name)
    #always last number in file name
    exposure_times.append(string_nos[len(string_nos)-1])
    exp_float = float(string_nos[len(string_nos)-1])*1e-5
    hdr_contribution = (numpy_vars[np_name])/exp_float
    if assignswitch == 0 :
        hdr_array = np.full_like(numpy_vars[np_name], 0)
        assignswitch = 1
    hdr_array += hdr_contribution


plt.imshow(hdr_array)
max(hdr_array)
np.amax(hdr_array)
normval = np.amax(hdr_array)
hdr_array_norm = hdr_array*255/normval
plt.imshow(hdr_array_norm)
runfile('C:/local/dev/slm_interference_lithography/BNS/Pictures/testspotv10/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/BNS/Pictures/testspotv10')
runfile('C:/local/dev/slm_interference_lithography/BNS/Pictures/testspotv7/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/BNS/Pictures/testspotv7')
(255*float(crop_img_size[0]*crop_img_size[1])
np.sum(crop_img)/(255*float(crop_img_size[0]*crop_img_size[1]))
crop_img_size
crop_img_size[0]
float(crop_img_size[0]*crop_img_size[1])
max(radii)
h = int(cropsize)
cropsize = max(radii)*0.95*0.5
cropsize
y = centers[circleno][0]
x = centers[circleno][1]
h = int(cropsize)
h
crop_img = (original)[x-h:x+h, y-h:y+h]
all_crop_img[circleno] = crop_img
crop_img_size = np.shape(crop_img)
crop_img_size
plt.imshow(crop_img)
plt.imshow(original)
x-h:x+h, y-h:y+h
[x-h:x+h, y-h:y+h]
x
y
crop_img = (original)[x-h:x+h, y-h:y+h]
crop_img
x
x-h
allsums = {}
all_crop_img = {}
cropsize = max(radii)*0.95*0.5
for circleno in range(0, len(radii)):
    print('Circle %s' %circleno)
    y = centers[circleno][0]
    x = centers[circleno][1]
    h = int(cropsize)
    #upper left, lower right
    #crop_img = im.crop((x, y+h, x+h, y))
    #crop_img.show()
    #need to check for crops that go outside of range
    if h < x or h < y:
        #ignore this order as it is outside of range
        continue 
    crop_img = (original)[x-h:x+h, y-h:y+h]
    all_crop_img[circleno] = crop_img
    crop_img_size = np.shape(crop_img)
    #sum values in cropped image
    cropsum = np.sum(crop_img)/(255*float(crop_img_size[0]*crop_img_size[1]))
    allsums[circleno] = cropsum


plt.imshow(crop_img)
crop_img
allsums = {}
all_crop_img = {}
cropsize = max(radii)*0.95*0.5
for circleno in range(0, len(radii)):
    print('Circle %s' %circleno)
    y = centers[circleno][0]
    x = centers[circleno][1]
    h = int(cropsize)
    #upper left, lower right
    #crop_img = im.crop((x, y+h, x+h, y))
    #crop_img.show()
    #need to check for crops that go outside of range
    if x < h or y < h:
        #ignore this order as it is outside of range
        continue 
    crop_img = (original)[x-h:x+h, y-h:y+h]
    all_crop_img[circleno] = crop_img
    crop_img_size = np.shape(crop_img)
    #sum values in cropped image
    cropsum = np.sum(crop_img)/(255*float(crop_img_size[0]*crop_img_size[1]))
    allsums[circleno] = cropsum


crop_img
plt.imshow(allsums[0])
allsums[0]
plt.imshow(all_crop_img[0])
plt.imshow(all_crop_img[1])
plt.imshow(all_crop_img[2])
plt.imshow(all_crop_img[3])
plt.imshow(all_crop_img[4])
plt.imshow(all_crop_img[5])
plt.imshow(all_crop_img[6])
runfile('C:/local/dev/slm_interference_lithography/BNS/Pictures/testspotv7/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/BNS/Pictures/testspotv7')
orderratios
runfile('C:/local/dev/slm_interference_lithography/BNS/Pictures/testspotv10/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/BNS/Pictures/testspotv10')
orderratios
runfile('C:/local/dev/slm_interference_lithography/BNS/Pictures/testspotv5-2/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/BNS/Pictures/testspotv5-2')
runfile('C:/local/dev/slm_interference_lithography/BNS/Pictures/testspotv5/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/BNS/Pictures/testspotv5')
runfile('C:/local/dev/slm_interference_lithography/BNS/Pictures/testspoth20/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/BNS/Pictures/testspoth20')
runfile('C:/local/dev/slm_interference_lithography/BNS/Pictures/testspoth10/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/BNS/Pictures/testspoth10')
runfile('C:/local/dev/slm_interference_lithography/BNS/Pictures/testspoth5/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/BNS/Pictures/testspoth5')
runfile('C:/local/dev/slm_interference_lithography/BNS/Pictures/700nmtestspot20/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/BNS/Pictures/700nmtestspot20')
runfile('C:/local/dev/slm_interference_lithography/BNS/Pictures/700nmtestspot10-2/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/BNS/Pictures/700nmtestspot10-2')
runfile('C:/local/dev/slm_interference_lithography/BNS/Pictures/700nmtestspot10-1/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/BNS/Pictures/700nmtestspot10-1')
runfile('C:/local/dev/slm_interference_lithography/BNS/Pictures/450nmttestspoth10/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/BNS/Pictures/450nmttestspoth10')
runfile('C:/local/dev/slm_interference_lithography/BNS/Pictures/450nmtestspoth5/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/BNS/Pictures/450nmtestspoth5')
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/horizontal/testspot5/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/horizontal/testspot5')
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/horizontal/testspot10/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/horizontal/testspot10')
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/horizontal/testspot20/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/horizontal/testspot20')
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot1/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot1')
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot2/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot2')
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot3/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot3')
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot4/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot4')
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot5/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot5')
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot6/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot6')
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot7/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/testspot7')
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/vertical/testspot5/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/vertical/testspot5')
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/vertical/testspot5-1/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/vertical/testspot5-1')
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/vertical/testspot5-2/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/vertical/testspot5-2')
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/vertical/testspot7/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/vertical/testspot7')
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/vertical/testspot7-1/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/vertical/testspot7-1')
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/vertical/testspot10/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/vertical/testspot10')
runfile('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/vertical/testspot20/hdrproc.py', wdir='C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/vertical/testspot20')
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
cam.show_gui()
%gui qt
cam.show_gui()
test_spot = [20,-10,0,1];
#distance = 2900e3
#for hamatsu set up
distance = 1300e3
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
slm.make_spots([test_spot + [0,0,0.075,0]])
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.075,0]])
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m, discard_edges=1)


slm_size = 6.9
initial_r = 1.9
N = res.shape[0]
x = (np.arange(N)-(N-1)/2.0)/N * slm_size #centres of apertures
gaussian = np.exp(-x**2/initial_r**2)
gaussian /= np.mean(gaussian)
f, axes = plt.subplots(1,2)
# plot the data and a Gaussian fit
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(x, data[:,i], '+', color=plt.cm.gist_rainbow(float(i)/N))
        m = np.polyfit(gaussian, data[:,i], 1)
        ax.plot(x, gaussian*m[0]+m[1], '-', color=plt.cm.gist_rainbow(float(i)/N))

# plot the data against the Gaussian
f, axes = plt.subplots(1,2)
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(gaussian, data[:,i], '-+', color=plt.cm.gist_rainbow(float(i)/N))


r = np.sqrt(x[:,np.newaxis]**2 + x[np.newaxis,:]**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')
plt.figure()
s=slm_size/2.0
plt.imshow(res[:,:,2],extent=(-s,s,-s,s))
for thresh in [0.0,0.1,0.2,0.5,0.9]:
    I = res[:,:,2].copy()
    I /= np.max(I)
    I -= thresh
    I[I<0] = 0
    cx = np.sum(x[:,np.newaxis]*I)/np.sum(I)
    cy = np.sum(x[np.newaxis,:]*I)/np.sum(I)
    hide = plt.plot(cy,cx,'+')
    print "found centroid at {}, {} with threshold {}".format(cx, cy, thresh)


r = np.sqrt((x[:,np.newaxis]-cx)**2 + (x[np.newaxis,:]-cy)**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')

radii = r.flatten()
I = res[:,:,2].flatten()/I.max()*10
from scipy.interpolate import UnivariateSpline
spl = UnivariateSpline(np.concatenate([radii,-radii]), np.tile(I,2))
rr = np.linspace(0,slm_size/np.sqrt(2),100)
plt.plot(rr,spl(rr))
plt.plot(radii,I,'.')
slm.centre=(cx,cy)
slm.radial_blaze_function = np.ones(384)
inner_edge_i = 1500//18 #bad
sd = 400/18.0
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#dim_slm(1)
#dim_slm(0.75)
#dim_slm(0.5)
#dim_slm(0.2)
#dim_slm(0.1)
#cam.exposure=-2
def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))

def brightest_g():
    time.sleep(0.1)
    cam.color_image()
    img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    #cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})

test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
focus_stack(50,5, snap=snap)
test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
xsection = np.zeros((30,640,3),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],480,3),dtype=np.uint8)
rs = np.linspace(-5,5,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    xsection[i,:,:] = np.mean(img[230:250,:,:], axis=0)
    ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)

# A brutal attempt at modal decomposition (not used)
modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m, discard_edges=1)

"""
"""
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)

# A brutal attempt at modal decomposition (not used)
modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m, discard_edges=1)


slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.5,0]])
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')

## ---(Mon Oct 15 12:40:06 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%gui qt
cam.show_gui()
test_spot = [20,-10,0,1];
#distance = 2900e3
#for hamatsu set up
distance = 1300e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.075,0]])
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.update_gaussian_to_tophat(1900,1, distance=distance)
distance = 1500e3
slm.update_gaussian_to_tophat(1900,1, distance=distance)
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')

## ---(Mon Oct 15 12:59:02 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%gui qt
cam.show_gui()
test_spot = [20,-10,0,1];
#distance = 2900e3
#for hamatsu set up
distance = 1500e3
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
test_spot = [20,-10,0,1];
#distance = 2900e3
#for hamatsu set up
distance = 1500e3
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m, discard_edges=1)


slm_size = 6.9
initial_r = 1.9
N = res.shape[0]
x = (np.arange(N)-(N-1)/2.0)/N * slm_size #centres of apertures
gaussian = np.exp(-x**2/initial_r**2)
gaussian /= np.mean(gaussian)
f, axes = plt.subplots(1,2)
# plot the data and a Gaussian fit
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(x, data[:,i], '+', color=plt.cm.gist_rainbow(float(i)/N))
        m = np.polyfit(gaussian, data[:,i], 1)
        ax.plot(x, gaussian*m[0]+m[1], '-', color=plt.cm.gist_rainbow(float(i)/N))

# plot the data against the Gaussian
f, axes = plt.subplots(1,2)
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(gaussian, data[:,i], '-+', color=plt.cm.gist_rainbow(float(i)/N))


r = np.sqrt(x[:,np.newaxis]**2 + x[np.newaxis,:]**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')
plt.figure()
s=slm_size/2.0
plt.imshow(res[:,:,2],extent=(-s,s,-s,s))
for thresh in [0.0,0.1,0.2,0.5,0.9]:
    I = res[:,:,2].copy()
    I /= np.max(I)
    I -= thresh
    I[I<0] = 0
    cx = np.sum(x[:,np.newaxis]*I)/np.sum(I)
    cy = np.sum(x[np.newaxis,:]*I)/np.sum(I)
    hide = plt.plot(cy,cx,'+')
    print "found centroid at {}, {} with threshold {}".format(cx, cy, thresh)


r = np.sqrt((x[:,np.newaxis]-cx)**2 + (x[np.newaxis,:]-cy)**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')
radii = r.flatten()
I = res[:,:,2].flatten()/I.max()*10
from scipy.interpolate import UnivariateSpline
spl = UnivariateSpline(np.concatenate([radii,-radii]), np.tile(I,2))
rr = np.linspace(0,slm_size/np.sqrt(2),100)
plt.plot(rr,spl(rr))
plt.plot(radii,I,'.')
slm.centre=(cx,cy)
slm.radial_blaze_function = np.ones(384)
inner_edge_i = 1500//18 #bad
sd = 400/18.0
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function
test_spot = [20,-10,0,1];
#distance = 2900e3
#for hamatsu set up
distance = 1500e3

slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#dim_slm(1)
#dim_slm(0.75)
#dim_slm(0.5)
#dim_slm(0.2)
#dim_slm(0.1)
#cam.exposure=-2
def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))

def brightest_g():
    time.sleep(0.1)
    cam.color_image()
    img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    #cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})

"""
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})

test_spot = [20,-10,0,1];
#distance = 2900e3
#for hamatsu set up
distance = 1500e3

slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
## TURN LIGHTS OFF!
#cam.exposure=-2
#snap = calibrate_hdr()

slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
focus_stack(50,5, snap=snap)
test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(50,10, snap=snap)
test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(50,20, snap=snap)
test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
focus_stack(50,20, snap=snap)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
test_spot = [20,-10,0,1];
#distance = 2900e3
#for hamatsu set up
distance = 1500e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(50,20, snap=snap)
test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(100,5, snap=snap)
xsection = np.zeros((30,640,3),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],480,3),dtype=np.uint8)
rs = np.linspace(-5,5,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    xsection[i,:,:] = np.mean(img[230:250,:,:], axis=0)
    ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))
focus_stack(50,5, snap=snap)
xsection = np.zeros((30,640,3),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],480,3),dtype=np.uint8)
rs = np.linspace(-5,5,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    xsection[i,:,:] = np.mean(img[230:250,:,:], axis=0)
    ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))
xsection = np.zeros((30,640,3),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],480,3),dtype=np.uint8)
rs = np.linspace(-5,5,xsection.shape[0])
or i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    xsection[i,:,:] = np.mean(img[230:250,:,:], axis=0)
    ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    xsection[i,:,:] = np.mean(img[230:250,:,:], axis=0)
    ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)


img
len(img)
size(img)
plt.imshow(img)
np.shape(img)
test = np.shape(img)
test(1)
test[1]
centroid
cx
cy
plt.imshow(res[:,:,2],extent=(-s,s,-s,s))
int(test[1])/10
imgsize = np.shape(img)
width = int(imgsize/10)
img = snap()
imgsize = np.shape(img)
width = int(imgsize/10)
ximgcentre = int(imgsize[1])/2
width = int(imgsize)/10
int(imgsize[1])/10
int(imgsize[1])/2
xsection = np.zeros((30,640,3),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],480,3),dtype=np.uint8)
rs = np.linspace(-5,5,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    imgsize = np.shape(img)
    width = int(imgsize[1])/10
    ximgcentre = int(imgsize[1])/2
    yimgcentre = int(imgsize[2])/2
    xsection[i,:,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:,:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width),:], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))
xsection = np.zeros((30,640,3),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],480,3),dtype=np.uint8)
rs = np.linspace(-5,5,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:,:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width),:], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))

(ximgcentre-width):(ximgcentre+width)
(ximgcentre-width)
(ximgcentre+width)
test_spot = [20,-10,0,1];
#distance = 2900e3
#for hamatsu set up
distance = 1500e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
np.mean(img[(ximgcentre-width):(ximgcentre+width),:,:], axis=0)
img[(ximgcentre-width):(ximgcentre+width),:,:]
xsection[i,:,:] = np.mean(img[(yimgcentre-width):(yimgcentre+width),:,:], axis=0)
xsection[i,:,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
#previously 230 and 250
#ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)
img = snap()
imgsize = np.shape(img)
width = int(imgsize[0])/10
imgsize[0]
xsection = np.zeros((width,int(imgsize[0])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[1])),dtype=np.uint8)
imgsize[1]
img = snap()
imgsize = np.shape(img)
width = int(imgsize[0])/10

xsection = np.zeros((width,int(imgsize[0])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[1])),dtype=np.uint8)
rs = np.linspace(-5,5,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))
shape(xsection)
np.shape(xsection)
np.shape(img)
int(imgsize[0])/10
ximgcentre
(ximgcentre-width)
(ximgcentre+width)
rs
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})

test_spot = [20,-10,0,1];
#distance = 2900e3
#for hamatsu set up
distance = 1500e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(50,5, snap=snap)
test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
distance = 1300e3
test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
distance = 2900e3
test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
focus_stack(50,5, snap=snap)
distance = 2300e3
test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(50,5, snap=snap)
distance = 3000e3
test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(50,5, snap=snap)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
np.load('C:\local\dev\slm_interference_lithography\BNS\Pictures\testspotv5\orderratios.npy')
np.load('C:/local/dev/slm_interference_lithography/BNS/Pictures/testspotv5/orderratios.npy')
np.load('C:/local/dev/slm_interference_lithography/Hamatsudata/hdrimagedata/vertical/testspot10/orderratios.npy')
enumerate(rs)
rs
xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
size(xsection[0])
len(xsection[0])
xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
np.load('hamamatsu_633_lut.npz')
test = np.load('hamamatsu_633_lut.npz')
test
test.keys
test.keys()
plt.plot(test['grays'], test['phases'])
df = 
import nplab
import nplab.datafile
df = nplab.datafile.DataFile("2018-08-24-2.h5","r")
df = nplab.datafile.DataFile("2018-08-24.h5","r")
df = nplab.datafile.DataFile("2018-08-15.h5","r")
%gui qt
df.show_gui(block=False)
xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
np.shape(img)
img.transpose()
xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:].tranpose(), axis=0)
xsection[i,:] = np.mean(np.transpose(img[(ximgcentre-width):(ximgcentre+width)),:], axis=0)
xsection[i,:] = np.mean(np.transpose(img[(ximgcentre-width):(ximgcentre+width),:]), axis=0)
np.shape(xsection)
xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
xsection[i,:] = np.mean(np.transpose(img[(ximgcentre-width):(ximgcentre+width),:]), axis=0)
xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[1])),dtype=np.uint8)
rs = np.linspace(-5,5,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(np.transpose(img[(ximgcentre-width):(ximgcentre+width),:]), axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))
xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[1])),dtype=np.uint8)
rs = np.linspace(-5,5,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width), axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))
img = snap()
imgsize = np.shape(img)
width = int(imgsize[0])/10

xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[1])),dtype=np.uint8)
rs = np.linspace(-5,5,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))
xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
rs = np.linspace(-5,5,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))

%qt gui
cam.show_gui()
test_spot = [20,-10,0,1];
#distance = 2900e3
#for hamatsu set up
distance = 3000e3
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
rs = np.linspace(-5,5,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))

distance = 1300e3
xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
rs = np.linspace(-5,5,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))
distance = 1500e3
xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
rs = np.linspace(-5,5,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))
test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(50,5, snap=snap)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m, discard_edges=1)


slm_size = 6.9
initial_r = 1.9
N = res.shape[0]
x = (np.arange(N)-(N-1)/2.0)/N * slm_size #centres of apertures
gaussian = np.exp(-x**2/initial_r**2)
gaussian /= np.mean(gaussian)
f, axes = plt.subplots(1,2)
# plot the data and a Gaussian fit
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(x, data[:,i], '+', color=plt.cm.gist_rainbow(float(i)/N))
        m = np.polyfit(gaussian, data[:,i], 1)
        ax.plot(x, gaussian*m[0]+m[1], '-', color=plt.cm.gist_rainbow(float(i)/N))

# plot the data against the Gaussian
f, axes = plt.subplots(1,2)
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(gaussian, data[:,i], '-+', color=plt.cm.gist_rainbow(float(i)/N))


r = np.sqrt(x[:,np.newaxis]**2 + x[np.newaxis,:]**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')
plt.figure()
s=slm_size/2.0
plt.imshow(res[:,:,2],extent=(-s,s,-s,s))
for thresh in [0.0,0.1,0.2,0.5,0.9]:
    I = res[:,:,2].copy()
    I /= np.max(I)
    I -= thresh
    I[I<0] = 0
    cx = np.sum(x[:,np.newaxis]*I)/np.sum(I)
    cy = np.sum(x[np.newaxis,:]*I)/np.sum(I)
    hide = plt.plot(cy,cx,'+')
    print "found centroid at {}, {} with threshold {}".format(cx, cy, thresh)


r = np.sqrt((x[:,np.newaxis]-cx)**2 + (x[np.newaxis,:]-cy)**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')
radii = r.flatten()
I = res[:,:,2].flatten()/I.max()*10
from scipy.interpolate import UnivariateSpline
spl = UnivariateSpline(np.concatenate([radii,-radii]), np.tile(I,2))
rr = np.linspace(0,slm_size/np.sqrt(2),100)
plt.plot(rr,spl(rr))
plt.plot(radii,I,'.')

slm.centre=(cx,cy)
slm.radial_blaze_function = np.ones(384)
inner_edge_i = 1500//18 #bad
sd = 400/18.0
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})
test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(50,5, snap=snap)
test_spot = [20,-10,0,1];
#distance = 2900e3
distance = 1500e3
cam.show_gui()
test_spot = [20,-10,0,1];
#distance = 2900e3
distance = 2000e3
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
## TURN LIGHTS OFF!
#cam.exposure=-2
#snap = calibrate_hdr()
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)

modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m, discard_edges=1)


slm_size = 6.9
initial_r = 1.9
N = res.shape[0]
x = (np.arange(N)-(N-1)/2.0)/N * slm_size #centres of apertures
gaussian = np.exp(-x**2/initial_r**2)
gaussian /= np.mean(gaussian)
f, axes = plt.subplots(1,2)
# plot the data and a Gaussian fit
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(x, data[:,i], '+', color=plt.cm.gist_rainbow(float(i)/N))
        m = np.polyfit(gaussian, data[:,i], 1)
        ax.plot(x, gaussian*m[0]+m[1], '-', color=plt.cm.gist_rainbow(float(i)/N))

# plot the data against the Gaussian
f, axes = plt.subplots(1,2)
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(gaussian, data[:,i], '-+', color=plt.cm.gist_rainbow(float(i)/N))


r = np.sqrt(x[:,np.newaxis]**2 + x[np.newaxis,:]**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')
plt.figure()
s=slm_size/2.0
plt.imshow(res[:,:,2],extent=(-s,s,-s,s))
for thresh in [0.0,0.1,0.2,0.5,0.9]:
    I = res[:,:,2].copy()
    I /= np.max(I)
    I -= thresh
    I[I<0] = 0
    cx = np.sum(x[:,np.newaxis]*I)/np.sum(I)
    cy = np.sum(x[np.newaxis,:]*I)/np.sum(I)
    hide = plt.plot(cy,cx,'+')
    print "found centroid at {}, {} with threshold {}".format(cx, cy, thresh)


r = np.sqrt((x[:,np.newaxis]-cx)**2 + (x[np.newaxis,:]-cy)**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')
radii = r.flatten()
I = res[:,:,2].flatten()/I.max()*10
from scipy.interpolate import UnivariateSpline
spl = UnivariateSpline(np.concatenate([radii,-radii]), np.tile(I,2))
rr = np.linspace(0,slm_size/np.sqrt(2),100)
plt.plot(rr,spl(rr))
plt.plot(radii,I,'.')
slm.centre=(cx,cy)
slm.radial_blaze_function = np.ones(384)
inner_edge_i = 1500//18 #bad
sd = 400/18.0
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#dim_slm(1)
#dim_slm(0.75)
#dim_slm(0.5)
#dim_slm(0.2)
#dim_slm(0.1)
#cam.exposure=-2
def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))

def brightest_g():
    time.sleep(0.1)
    cam.color_image()
    img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    #cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})
test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(50,5, snap=snap)
cam.show_gui()
test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(50,5, snap=snap)
xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
rs = np.linspace(-5,5,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    plt.imshow(img)
    raw_input('Press <ENTER> to continue')
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))

## ---(Tue Oct 16 15:17:04 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
test_spot = [20,-10,0,1];
#distance = 2900e3
distance = 2000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
## TURN LIGHTS OFF!
#cam.exposure=-2
#snap = calibrate_hdr()

# Sequential Shack-Hartmann sensor
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
%qt gui
%gui qt
cam.show_gui()
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)

res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)

res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)

res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)

slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m, discard_edges=1)

"""
"""
# Analysis of the intensity distribution on the SLM
# NB slmsize is set at 6.9mm for the CC SLM
slm_size = 6.9
initial_r = 1.9
N = res.shape[0]
x = (np.arange(N)-(N-1)/2.0)/N * slm_size #centres of apertures
gaussian = np.exp(-x**2/initial_r**2)
gaussian /= np.mean(gaussian)
f, axes = plt.subplots(1,2)
# plot the data and a Gaussian fit
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(x, data[:,i], '+', color=plt.cm.gist_rainbow(float(i)/N))
        m = np.polyfit(gaussian, data[:,i], 1)
        ax.plot(x, gaussian*m[0]+m[1], '-', color=plt.cm.gist_rainbow(float(i)/N))

# plot the data against the Gaussian
f, axes = plt.subplots(1,2)
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(gaussian, data[:,i], '-+', color=plt.cm.gist_rainbow(float(i)/N))


# plot the data vs r
r = np.sqrt(x[:,np.newaxis]**2 + x[np.newaxis,:]**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')

plt.figure()
s=slm_size/2.0
plt.imshow(res[:,:,2],extent=(-s,s,-s,s))
for thresh in [0.0,0.1,0.2,0.5,0.9]:
    I = res[:,:,2].copy()
    I /= np.max(I)
    I -= thresh
    I[I<0] = 0
    cx = np.sum(x[:,np.newaxis]*I)/np.sum(I)
    cy = np.sum(x[np.newaxis,:]*I)/np.sum(I)
    hide = plt.plot(cy,cx,'+')
    print "found centroid at {}, {} with threshold {}".format(cx, cy, thresh)


r = np.sqrt((x[:,np.newaxis]-cx)**2 + (x[np.newaxis,:]-cy)**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')
slm.centre=(cx,cy)
slm.radial_blaze_function = np.ones(384)
inner_edge_i = 1500//18 #bad
sd = 400/18.0
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})

"""

"""
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#dim_slm(1)
#dim_slm(0.75)
#dim_slm(0.5)
#dim_slm(0.2)
#dim_slm(0.1)
#cam.exposure=-2
def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))

def brightest_g():
    time.sleep(0.1)
    cam.color_image()
    img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    #cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])

# Start by autofocusing (optimising mode 2)
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})
test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(50,5, snap=snap)
distance = 2300e3

test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(50,5, snap=snap)
distance = 1800e3
test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(50,5, snap=snap)
distance = 1500e3
test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(50,5, snap=snap)
distance = 3000e3
test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(50,5, snap=snap)
xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
rs = np.linspace(-5,5,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    #plt.imshow(img)
    #raw_input('Press <ENTER> to continue')
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))

img = snap()
imgsize = np.shape(img)
width = int(imgsize[0])/10

xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
rs = np.linspace(-5,5,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    #plt.imshow(img)
    #raw_input('Press <ENTER> to continue')
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))

test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
test_spot = [20,-10,0,1];
#distance = 2900e3
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
focus_stack(50,5, snap=snap)
img = snap()
plt.imshow(img)
focus_stack[i,:,:] = snap()
focus_stack[i,:] = snap()
focus_stack = ArrayWithAttrs(np.zeros((N,)+img.shape, dtype=img.dtype))
focus_stack[i,:] = snap()
for i, d in enumerate(np.linspace(-dz,dz,N)):
    z = zernike_coefficients.copy()
    z[1] += d
    slm.zernike_coefficients = z
    #focus_stack[i,:,:] = snap()
    focus_stack[i,:] = snap()


focus_stack(50,5, snap=snap)
ArrayWithAttrs(np.zeros((N,)+img.shape, dtype=img.dtype))
def focus_stack(N, dz, snap=None):
    """Shift the focus (using Zernike modes) and acquire images."""
    if snap is None:
        global cam
        snap = lambda: cam.color_image()[:,:,2]
    img = snap()
    focus_stack = ArrayWithAttrs(np.zeros((N,)+img.shape, dtype=img.dtype))
    for i, d in enumerate(np.linspace(-dz,dz,N)):
        z = zernike_coefficients.copy()
        z[1] += d
        slm.zernike_coefficients = z
        #focus_stack[i,:,:] = snap()
        focus_stack[i,:] = snap()
    slm.zernike_coefficients=zernike_coefficients
    plt.figure()
    plt.imshow(focus_stack[:,240,:],aspect="auto")
    focus_stack.attrs["dz"]=dz
    focus_stack.attrs["zernike_coefficients"]=zernike_coefficients
    dset = nplab.current_datafile().create_dataset("zstack_%d",data=focus_stack)
    return dset


focus_stack(50,5, snap=snap)
def focus_stack(N, dz, snap=None):
    """Shift the focus (using Zernike modes) and acquire images."""
    if snap is None:
        global cam
        snap = lambda: cam.color_image()[:,:,2]
    img = snap()
    focus_stack = ArrayWithAttrs(np.zeros((N,)+img.shape, dtype=img.dtype))
    for i, d in enumerate(np.linspace(-dz,dz,N)):
        z = zernike_coefficients.copy()
        z[1] += d
        slm.zernike_coefficients = z
        #focus_stack[i,:,:] = snap()
        focus_stack[i,:] = snap()
    slm.zernike_coefficients=zernike_coefficients
    plt.figure()
    #plt.imshow(focus_stack[:,240,:],aspect="auto")
    plt.imshow(focus_stack[:,240],aspect="auto")
    focus_stack.attrs["dz"]=dz
    focus_stack.attrs["zernike_coefficients"]=zernike_coefficients
    dset = nplab.current_datafile().create_dataset("zstack_%d",data=focus_stack)
    return dset


focus_stack(50,5, snap=snap)
img
np.shape(img)
1024/2
def focus_stack(N, dz, snap=None):
    """Shift the focus (using Zernike modes) and acquire images."""
    if snap is None:
        global cam
        snap = lambda: cam.color_image()[:,:,2]
    img = snap()
    focus_stack = ArrayWithAttrs(np.zeros((N,)+img.shape, dtype=img.dtype))
    for i, d in enumerate(np.linspace(-dz,dz,N)):
        z = zernike_coefficients.copy()
        z[1] += d
        slm.zernike_coefficients = z
        #focus_stack[i,:,:] = snap()
        focus_stack[i,:] = snap()
    slm.zernike_coefficients=zernike_coefficients
    plt.figure()
    #plt.imshow(focus_stack[:,240,:],aspect="auto")
    plt.imshow(focus_stack[:,512],aspect="auto")
    focus_stack.attrs["dz"]=dz
    focus_stack.attrs["zernike_coefficients"]=zernike_coefficients
    dset = nplab.current_datafile().create_dataset("zstack_%d",data=focus_stack)
    return dset


focus_stack(50,5, snap=snap)
xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
rs = np.linspace(-5,5,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    #plt.imshow(img)
    #raw_input('Press <ENTER> to continue')
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))
xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
#rs = np.linspace(-5,5,xsection.shape[0])
rs = np.linspace(-50,50,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    #plt.imshow(img)
    #raw_input('Press <ENTER> to continue')
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))
img = snap()
imgsize = np.shape(img)
width = int(imgsize[0])/10

xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
#rs = np.linspace(-5,5,xsection.shape[0])
rs = np.linspace(-100,100,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    #plt.imshow(img)
    #raw_input('Press <ENTER> to continue')
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))

%gui qt
cam.show_gui()
img = snap()
imgsize = np.shape(img)
width = int(imgsize[0])/10

xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
#rs = np.linspace(-5,5,xsection.shape[0])
rs = np.linspace(-100,100,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    #plt.imshow(img)
    #raw_input('Press <ENTER> to continue')
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))

xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
#rs = np.linspace(-5,5,xsection.shape[0])
rs = np.linspace(-100,100,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    #plt.imshow(img)
    #raw_input('Press <ENTER> to continue')
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))
test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(50,5, snap=snap)

test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot + [0,0,0.075,0]])
xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
#rs = np.linspace(-5,5,xsection.shape[0])
rs = np.linspace(-100,100,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    #plt.imshow(img)
    #raw_input('Press <ENTER> to continue')
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
#rs = np.linspace(-5,5,xsection.shape[0])
rs = np.linspace(-100,100,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    #plt.imshow(img)
    #raw_input('Press <ENTER> to continue')
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))
test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(50,5, snap=snap)

## ---(Fri Oct 19 11:54:12 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%qt gui
%gui qt
cam.show_gui()
test_spot = [20,-10,0,1];
#distance = 2900e3
distance = 3000e3
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
distance = 2000e3
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
## TURN LIGHTS OFF!
#cam.exposure=-2
#snap = calibrate_hdr()
test_spot = [20,-10,0,1];
#distance = 2900e3
distance = 2000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)

## ---(Fri Oct 19 12:00:55 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%gui qt
cam.show_gui()
test_spot = [20,-10,0,1];
#distance = 2900e3
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
from nplab.instrument import Instrument
from nplab.instrument.light_sources.ondax_laser import OndaxLaser
from nplab.instrument.shutter.southampton_custom import ILShutter
from nplab.instrument.camera.opencv import OpenCVCamera
from nplab.instrument.camera.thorlabs_uc480 import ThorLabsCamera
from slm_interference_lithography import VeryCleverBeamsplitter
from nplab.utils.gui import show_guis
import numpy as np
import matplotlib.pyplot as plt
import time
import scipy.ndimage
from rgb_to_hdr import calibrate_hdr_from_rgb, hdr_from_rgb, fit_channels
import nplab.utils.gui
import nplab
from nplab.utils.array_with_attrs import ArrayWithAttrs
from measure_orders import POIManager, sum_rois

def beam_profile_on_SLM(slm, cam, spot, N, overlap=0.0):
    """Scan a spot over the SLM, recording intensities as we go"""
    intensities = np.zeros((N, N))
    for i in range(N):
        for j in range(N):
            slm.make_spots([spot + [float(i-N/2.0)/N, float(j-N/2.0)/N, 
                                (0.5 + overlap/2.0)/N, 0]])
            time.sleep(0.1);
            cam.color_image()
            time.sleep(0.1);
            intensities[i,j] = cam.color_image()[:,:,2].astype(np.float).sum()
    return intensities


def centroid(img, threshold = 0.5):
    """Return the centroid and peak intensity of the current camera image.
    
    NB the image is assumed to be monochrome and floating-point.
    """
    thresholded = img.astype(np.float) - img.min() - (img.max() - img.min())*threshold
    thresholded[thresholded < 0] = 0
    return scipy.ndimage.measurements.center_of_mass(thresholded)


def snapshot_fn(cam, o, s):
    """Create a callable that will return an HDR image"""
    def snap():
        cam.color_image()
        time.sleep(0.1)
        cam.color_image()
        time.sleep(0.1)
        return hdr_from_rgb(o, s, cam.color_image())
    return snap


def sequential_shack_hartmann(slm, snapshot_fn, spot, N, overlap=0.0, other_spots=[], pause=False,save=True):
    """Scan a spot over the SLM, recording intensities as we go"""
    results = ArrayWithAttrs(np.zeros((N, N, 3))) # For each position, find X,Y,I
    results.attrs['spot'] = spot
    results.attrs['n_apertures'] = N
    results.attrs['overlap'] = overlap
    results.attrs['other_spots'] = other_spots
    results.attrs['pause_between_spots'] = pause
    if pause:
        app = nplab.utils.gui.get_qt_app()
    for i in range(N):
        for j in range(N):
            slm.make_spots([spot + [float(i+0.5-N/2.0)/N, float(j+0.5-N/2.0)/N, 
                                (0.5 + overlap/2.0)/N, 0]] + other_spots)
            hdr = snapshot_fn()
            results[i,j,2] = hdr.sum()
            results[i,j,:2] = centroid(hdr)
            if pause:
                raw_input("spot %d, %d (hit enter for next)" % (i, j))
                app.processEvents()
            print '.',
    if save:
        dset = nplab.current_datafile().create_dataset("sequential_shack_hartmann_%d", data=results)
        return dset
    else:
        return results


def plot_shack_hartmann(results, threshold=0.1):
    """Plot the results of the above wavefront sensor"""
    N = results.shape[0]
    weights = results[:,:,2] > results[:,:,2].max()*threshold
    centre = np.mean(results[:,:,:2]*weights[:,:,np.newaxis], axis=(0,1))/np.mean(weights)
    r = np.max(np.abs((results[:,:,:2]-centre)*weights[:,:,np.newaxis]))
    f, ax = plt.subplots(1,2)
    for i in range(N):
        for j in range(N):
            if weights[i,j] > 0:
                u = (i+0.5)/N - 0.5
                v = (j+0.5)/N - 0.5
                shift = (results[i,j,:2] - centre)/r/N
                ax[0].plot([u,u+shift[0]],[v,v+shift[1]],'o-')
    ax[1].imshow(results[:,:,2], cmap='cubehelix')


def plot_sh_shifts(ax, results, discard_edges=0):
    """Plot the results of the above wavefront sensor"""
    e = discard_edges
    N = results.shape[0]
    centre = np.mean(results[:,:,:2], axis=(0,1))
    r = np.max(np.abs(results[:,:,:2]-centre))
    for i in range(N):
        for j in range(N):
            if i >= e and j >= e and i<N-e and j<N-e:
                u = (i+0.5)/N - 0.5
                v = (j+0.5)/N - 0.5
                shift = (results[i,j,:2] - centre)/r/N
                ax.plot([u,u+shift[0]],[v,v+shift[1]],'o-')


def measure_modes(slm, snapshot_fn, spot, N, dz=1, **kwargs):
    """Repeat sequential shack hartmann for each Zernike mode"""
    out = []
    for i in range(13):
        z = np.zeros(12)
        if i < len(z):
            z[i] = dz
        slm.zernike_coefficients = z
        time.sleep(0.2)
        print ("Mode %d" % i),
        out.append(sequential_shack_hartmann(slm, snapshot_fn, spot, N, **kwargs))
        print
    return out


def optimise_aberration_correction(slm, cam, zernike_coefficients, merit_function, dz=1, modes=None):
    """Tweak the Zernike coefficients incrementally to optimise them."""
    
    def test_coefficients(coefficients):
        slm.zernike_coefficients = coefficients
        return merit_function()
    
    coefficients = np.array(zernike_coefficients)
    for i in (range(len(coefficients)) if modes is None else modes):
        values = np.array([-1,0,1]) * dz + coefficients[i]
        merits = np.zeros(values.shape[0])
        for j, v in enumerate(values):
            coefficients[i] = v
            merits[j] = test_coefficients(coefficients)
        if merits.argmax() == 0:
            pass # might want to go round for another try?
        elif merits.argmax() == len(merits) - 1:
            pass
        coefficients[i] = values[merits.argmax()]
        test_coefficients(coefficients)
    return coefficients



def calibrate_hdr():
    """Fit the red channel vs the blue channel to calibrate the camera
    
    We return a snapshot function that yields an HDR image, made by using the 
    red pixels in the Bayer patern to reconstruct the image when the blue
    channel is saturated.
    """
    s = [0,0,0]
    o = [0,0,1]
    img = cam.color_image()
    s[0], o[0] = fit_channels(img, 0, 2, amin=10, amax=50, plot=True)
    df.create_dataset("hdr_calibration_image_%d",data=img, attrs={'slopes':s,'offsets':o})
    hdr = hdr_from_rgb(o,s,cam.color_image())
    for y in [200,210,220,230,240,250,260,270,280]:
        plt.plot(hdr[y,:])
    df.create_dataset("hdr_calibration_image_%d",data=img, attrs={'slopes':s,'offsets':o})
    return snapshot_fn(cam, s, o)


def focus_stack(N, dz, snap=None):
    """Shift the focus (using Zernike modes) and acquire images."""
    if snap is None:
        global cam
        snap = lambda: cam.color_image()[:,:,2]
    img = snap()
    focus_stack = ArrayWithAttrs(np.zeros((N,)+img.shape, dtype=img.dtype))
    for i, d in enumerate(np.linspace(-dz,dz,N)):
        z = zernike_coefficients.copy()
        z[1] += d
        slm.zernike_coefficients = z
        #focus_stack[i,:,:] = snap()
        focus_stack[i,:] = snap()
    slm.zernike_coefficients=zernike_coefficients
    plt.figure()
    #plt.imshow(focus_stack[:,240,:],aspect="auto")
    plt.imshow(focus_stack[:,512],aspect="auto")
    focus_stack.attrs["dz"]=dz
    focus_stack.attrs["zernike_coefficients"]=zernike_coefficients
    dset = nplab.current_datafile().create_dataset("zstack_%d",data=focus_stack)
    return dset






if __name__ == '__main__':
    slm = VeryCleverBeamsplitter()
    #shutter = ILShutter("COM1")
    #laser = OndaxLaser("COM4")
    cam = ThorLabsCamera()
    slm.move_hologram(1920,0,1024,768)
    #previously
    #slm.move_hologram(-800,0,800,600)
    # set uniform values so it has a blazing function and no aberration correction
    blazing_function = np.array([  0,   0,   0,   0,   0,   0,   0,   0,   0,  12,  69,  92, 124,
       139, 155, 171, 177, 194, 203, 212, 225, 234, 247, 255, 255, 255,
       255, 255, 255, 255, 255, 255]).astype(np.float)/255.0 #np.linspace(0,1,32)
    #blazing_function = np.load("hamamatsu_633_lut.npz")['grays']
    def dim_slm(dimming):
        slm.blazing_function = (blazing_function - 0.5)*dimming + 0.5
    slm.blazing_function = blazing_function
    slm.zernike_coefficients = np.zeros(12)
    #distance = 2325e3
    #slm.update_gaussian_to_tophat(1900,3000, distance=distance)
    #slm.update_gaussian_to_tophat(1900,1, distance=distance)
    slm.disable_gaussian_to_tophat()
    slm.make_spots([[20,10,0,1],[-20,10,0,1]])
    test_spot = [-20,10,0,1]
    slm.make_spots([test_spot])
    #shutter.open_shutter()
    #guis = show_guis([shutter, cam], block=False)
    def snap():
        cam.gray_image()
        time.sleep(0.1)
        cam.gray_image()
        return cam.gray_image()
    
    df = nplab.current_datafile()


"""
# These variables need to be defined to match the geometry of your set-up
test_spot = [20,-10,0,1];
#distance = 2900e3
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
## TURN LIGHTS OFF!
#cam.exposure=-2
#snap = calibrate_hdr()

# Sequential Shack-Hartmann sensor
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)

# A brutal attempt at modal decomposition (not used)
modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m, discard_edges=1)

"""
"""
# Analysis of the intensity distribution on the SLM
# NB slmsize is set at 6.9mm for the CC SLM
slm_size = 6.9
initial_r = 1.9
N = res.shape[0]
x = (np.arange(N)-(N-1)/2.0)/N * slm_size #centres of apertures
gaussian = np.exp(-x**2/initial_r**2)
gaussian /= np.mean(gaussian)
f, axes = plt.subplots(1,2)
# plot the data and a Gaussian fit
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(x, data[:,i], '+', color=plt.cm.gist_rainbow(float(i)/N))
        m = np.polyfit(gaussian, data[:,i], 1)
        ax.plot(x, gaussian*m[0]+m[1], '-', color=plt.cm.gist_rainbow(float(i)/N))

# plot the data against the Gaussian
f, axes = plt.subplots(1,2)
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(gaussian, data[:,i], '-+', color=plt.cm.gist_rainbow(float(i)/N))


# plot the data vs r
r = np.sqrt(x[:,np.newaxis]**2 + x[np.newaxis,:]**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')

# find the centroid
plt.figure()
s=slm_size/2.0
plt.imshow(res[:,:,2],extent=(-s,s,-s,s))
for thresh in [0.0,0.1,0.2,0.5,0.9]:
    I = res[:,:,2].copy()
    I /= np.max(I)
    I -= thresh
    I[I<0] = 0
    cx = np.sum(x[:,np.newaxis]*I)/np.sum(I)
    cy = np.sum(x[np.newaxis,:]*I)/np.sum(I)
    hide = plt.plot(cy,cx,'+')
    print "found centroid at {}, {} with threshold {}".format(cx, cy, thresh)


# pick the right values for cx and cy...

# plot the data vs r
r = np.sqrt((x[:,np.newaxis]-cx)**2 + (x[np.newaxis,:]-cy)**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')

radii = r.flatten()
I = res[:,:,2].flatten()/I.max()*10
from scipy.interpolate import UnivariateSpline
spl = UnivariateSpline(np.concatenate([radii,-radii]), np.tile(I,2))
rr = np.linspace(0,slm_size/np.sqrt(2),100)
plt.plot(rr,spl(rr))
plt.plot(radii,I,'.')

slm.centre=(cx,cy)
slm.radial_blaze_function = np.ones(384)
inner_edge_i = 1500//18 #bad
sd = 400/18.0
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function
"""
"""



# Optimise SLM for aberrations with modal wavefront sensor
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#dim_slm(1)
#dim_slm(0.75)
#dim_slm(0.5)
#dim_slm(0.2)
#dim_slm(0.1)
#cam.exposure=-2
def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))

def brightest_g():
    time.sleep(0.1)
    cam.color_image()
    img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    #cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])

# Start by autofocusing (optimising mode 2)
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})

"""

"""
# Really thorough optimisation of defocus
# Start with a visible, nicely-focused spot
test_spot = [20,-10,0,1];
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(50,5, snap=snap)

"""
"""
# Scan through a parameter, plotting sections of the beam
#changed this section as camera changed
img = snap()
imgsize = np.shape(img)
width = int(imgsize[0])/10

xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
#rs = np.linspace(-5,5,xsection.shape[0])
rs = np.linspace(-100,100,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    #plt.imshow(img)
    #raw_input('Press <ENTER> to continue')
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))


"""
test_spot = [20,-10,0,1];
#distance = 2900e3
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)

## ---(Fri Oct 19 12:07:14 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%gui qt
cam.show_gui()
test_spot = [20,-10,0,1];
#distance = 2900e3
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m, discard_edges=1)


slm_size = 6.9
initial_r = 1.9
N = res.shape[0]
x = (np.arange(N)-(N-1)/2.0)/N * slm_size #centres of apertures
gaussian = np.exp(-x**2/initial_r**2)
gaussian /= np.mean(gaussian)
f, axes = plt.subplots(1,2)
# plot the data and a Gaussian fit
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(x, data[:,i], '+', color=plt.cm.gist_rainbow(float(i)/N))
        m = np.polyfit(gaussian, data[:,i], 1)
        ax.plot(x, gaussian*m[0]+m[1], '-', color=plt.cm.gist_rainbow(float(i)/N))

# plot the data against the Gaussian
f, axes = plt.subplots(1,2)
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(gaussian, data[:,i], '-+', color=plt.cm.gist_rainbow(float(i)/N))


r = np.sqrt(x[:,np.newaxis]**2 + x[np.newaxis,:]**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')

# find the centroid
plt.figure()
s=slm_size/2.0
plt.imshow(res[:,:,2],extent=(-s,s,-s,s))
for thresh in [0.0,0.1,0.2,0.5,0.9]:
    I = res[:,:,2].copy()
    I /= np.max(I)
    I -= thresh
    I[I<0] = 0
    cx = np.sum(x[:,np.newaxis]*I)/np.sum(I)
    cy = np.sum(x[np.newaxis,:]*I)/np.sum(I)
    hide = plt.plot(cy,cx,'+')
    print "found centroid at {}, {} with threshold {}".format(cx, cy, thresh)


r = np.sqrt((x[:,np.newaxis]-cx)**2 + (x[np.newaxis,:]-cy)**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')

radii = r.flatten()
I = res[:,:,2].flatten()/I.max()*10
from scipy.interpolate import UnivariateSpline
spl = UnivariateSpline(np.concatenate([radii,-radii]), np.tile(I,2))
rr = np.linspace(0,slm_size/np.sqrt(2),100)
plt.plot(rr,spl(rr))
plt.plot(radii,I,'.')
slm.centre=(cx,cy)
slm.radial_blaze_function = np.ones(384)
inner_edge_i = 1500//18 #bad
sd = 400/18.0
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#dim_slm(1)
#dim_slm(0.75)
#dim_slm(0.5)
#dim_slm(0.2)
#dim_slm(0.1)
#cam.exposure=-2
def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))

def brightest_g():
    time.sleep(0.1)
    cam.color_image()
    img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    #cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})

test_spot = [20,-10,0,1];
#distance = 2900e3
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
## TURN LIGHTS OFF!
#cam.exposure=-2
#snap = calibrate_hdr()
%gui qt
cam.show_gui()
test_spot = [20,-10,0,1];
#distance = 2900e3
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
## TURN LIGHTS OFF!
#cam.exposure=-2
#snap = calibrate_hdr()

# Sequential Shack-Hartmann sensor
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)

modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m, discard_edges=1)


r = np.sqrt(x[:,np.newaxis]**2 + x[np.newaxis,:]**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')

# find the centroid
plt.figure()
s=slm_size/2.0
plt.imshow(res[:,:,2],extent=(-s,s,-s,s))
for thresh in [0.0,0.1,0.2,0.5,0.9]:
    I = res[:,:,2].copy()
    I /= np.max(I)
    I -= thresh
    I[I<0] = 0
    cx = np.sum(x[:,np.newaxis]*I)/np.sum(I)
    cy = np.sum(x[np.newaxis,:]*I)/np.sum(I)
    hide = plt.plot(cy,cx,'+')
    print "found centroid at {}, {} with threshold {}".format(cx, cy, thresh)


r = np.sqrt((x[:,np.newaxis]-cx)**2 + (x[np.newaxis,:]-cy)**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')
radii = r.flatten()
I = res[:,:,2].flatten()/I.max()*10
from scipy.interpolate import UnivariateSpline
spl = UnivariateSpline(np.concatenate([radii,-radii]), np.tile(I,2))
rr = np.linspace(0,slm_size/np.sqrt(2),100)
plt.plot(rr,spl(rr))
plt.plot(radii,I,'.')
slm.centre=(cx,cy)
slm.radial_blaze_function = np.ones(384)
inner_edge_i = 1500//18 #bad
sd = 400/18.0
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#dim_slm(1)
#dim_slm(0.75)
#dim_slm(0.5)
#dim_slm(0.2)
#dim_slm(0.1)
#cam.exposure=-2
def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))

def brightest_g():
    time.sleep(0.1)
    cam.color_image()
    img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    #cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])

# Start by autofocusing (optimising mode 2)
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})

%gui qt
cam.show_gui()
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})
%gui qt
cam.show_gui()
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)


test_spot = [20,-10,0,1];
#distance = 2900e3
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m, discard_edges=1)


test_spot = [20,-10,0,1];
#distance = 2900e3
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
#slm.update_gaussian_to_tophat(1900,1, distance=distance)
## TURN LIGHTS OFF!
#cam.exposure=-2
#snap = calibrate_hdr()

# Sequential Shack-Hartmann sensor
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)

modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m, discard_edges=1)


slm_size = 6.9
initial_r = 1.9
N = res.shape[0]
x = (np.arange(N)-(N-1)/2.0)/N * slm_size #centres of apertures
gaussian = np.exp(-x**2/initial_r**2)
gaussian /= np.mean(gaussian)
f, axes = plt.subplots(1,2)
# plot the data and a Gaussian fit
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(x, data[:,i], '+', color=plt.cm.gist_rainbow(float(i)/N))
        m = np.polyfit(gaussian, data[:,i], 1)
        ax.plot(x, gaussian*m[0]+m[1], '-', color=plt.cm.gist_rainbow(float(i)/N))

# plot the data against the Gaussian
f, axes = plt.subplots(1,2)
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(gaussian, data[:,i], '-+', color=plt.cm.gist_rainbow(float(i)/N))


r = np.sqrt(x[:,np.newaxis]**2 + x[np.newaxis,:]**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')

# find the centroid
plt.figure()
s=slm_size/2.0
plt.imshow(res[:,:,2],extent=(-s,s,-s,s))
for thresh in [0.0,0.1,0.2,0.5,0.9]:
    I = res[:,:,2].copy()
    I /= np.max(I)
    I -= thresh
    I[I<0] = 0
    cx = np.sum(x[:,np.newaxis]*I)/np.sum(I)
    cy = np.sum(x[np.newaxis,:]*I)/np.sum(I)
    hide = plt.plot(cy,cx,'+')
    print "found centroid at {}, {} with threshold {}".format(cx, cy, thresh)


r = np.sqrt((x[:,np.newaxis]-cx)**2 + (x[np.newaxis,:]-cy)**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')
radii = r.flatten()
I = res[:,:,2].flatten()/I.max()*10
from scipy.interpolate import UnivariateSpline
spl = UnivariateSpline(np.concatenate([radii,-radii]), np.tile(I,2))
rr = np.linspace(0,slm_size/np.sqrt(2),100)
plt.plot(rr,spl(rr))
plt.plot(radii,I,'.')
slm.centre=(cx,cy)
slm.radial_blaze_function = np.ones(384)
inner_edge_i = 1500//18 #bad
sd = 400/18.0
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#dim_slm(1)
#dim_slm(0.75)
#dim_slm(0.5)
#dim_slm(0.2)
#dim_slm(0.1)
#cam.exposure=-2
def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))

def brightest_g():
    time.sleep(0.1)
    cam.color_image()
    img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    #cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)


zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})


zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)


zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})

def brightest_g():
    time.sleep(0.1)
    #cam.color_image()
    hdr = snap()
    img = hdr[...,0]
    #img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += hdr[...,1]
        #avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))


zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#dim_slm(1)
#dim_slm(0.75)
#dim_slm(0.5)
#dim_slm(0.2)
#dim_slm(0.1)
#cam.exposure=-2
def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))

def brightest_g():
    time.sleep(0.1)
    #cam.color_image()
    hdr = snap()
    img = hdr[...,0]
    #img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += hdr[...,1]
        #avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    #cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])

# Start by autofocusing (optimising mode 2)
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})

zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#dim_slm(1)
#dim_slm(0.75)
#dim_slm(0.5)
#dim_slm(0.2)
#dim_slm(0.1)
#cam.exposure=-2
def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))

def brightest_g():
    time.sleep(0.1)
    #cam.color_image()
    hdr = snap()
    img = hdr[...,0]
    #img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += hdr[...,1]
        #avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    #cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])

# Start by autofocusing (optimising mode 2)
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})

zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
slm.make_spots([test_spot + [0,0,0.75,0]])
slm.make_spots([test_spot])
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%gui qt
cam.show_gui()
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
cam.show_gui()
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')

## ---(Fri Oct 19 16:14:15 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%gui qt
cam.show_gui()
test_spot = [20,-10,0,1];
distance = 2900e3
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.make_spots([test_spot + [0,0,0.075,0]])
#slm.update_gaussian_to_tophat(1900,1, distance=distance)
## TURN LIGHTS OFF!
#cam.exposure=-2
#snap = calibrate_hdr()

# Sequential Shack-Hartmann sensor
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m, discard_edges=1)


slm_size = 6.9
initial_r = 1.9
N = res.shape[0]
x = (np.arange(N)-(N-1)/2.0)/N * slm_size #centres of apertures
gaussian = np.exp(-x**2/initial_r**2)
gaussian /= np.mean(gaussian)
f, axes = plt.subplots(1,2)
# plot the data and a Gaussian fit
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(x, data[:,i], '+', color=plt.cm.gist_rainbow(float(i)/N))
        m = np.polyfit(gaussian, data[:,i], 1)
        ax.plot(x, gaussian*m[0]+m[1], '-', color=plt.cm.gist_rainbow(float(i)/N))

# plot the data against the Gaussian
f, axes = plt.subplots(1,2)
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(gaussian, data[:,i], '-+', color=plt.cm.gist_rainbow(float(i)/N))


r = np.sqrt(x[:,np.newaxis]**2 + x[np.newaxis,:]**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')

# find the centroid
plt.figure()
s=slm_size/2.0
plt.imshow(res[:,:,2],extent=(-s,s,-s,s))
for thresh in [0.0,0.1,0.2,0.5,0.9]:
    I = res[:,:,2].copy()
    I /= np.max(I)
    I -= thresh
    I[I<0] = 0
    cx = np.sum(x[:,np.newaxis]*I)/np.sum(I)
    cy = np.sum(x[np.newaxis,:]*I)/np.sum(I)
    hide = plt.plot(cy,cx,'+')
    print "found centroid at {}, {} with threshold {}".format(cx, cy, thresh)


r = np.sqrt((x[:,np.newaxis]-cx)**2 + (x[np.newaxis,:]-cy)**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')
radii = r.flatten()
I = res[:,:,2].flatten()/I.max()*10
from scipy.interpolate import UnivariateSpline
spl = UnivariateSpline(np.concatenate([radii,-radii]), np.tile(I,2))
rr = np.linspace(0,slm_size/np.sqrt(2),100)
plt.plot(rr,spl(rr))
plt.plot(radii,I,'.')
slm.centre=(cx,cy)
slm.radial_blaze_function = np.ones(384)
inner_edge_i = 1500//18 #bad
sd = 400/18.0
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
cam.show_gui()
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')

## ---(Fri Oct 19 16:52:12 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/opengl_holograms.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%qt gui
%gui qt
cam.show_gui()
test_spot = [20,-10,0,1];
distance = 2900e3


# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
test_spot = [20,-10,0,1];
distance = 2900e3


# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
#slm.update_gaussian_to_tophat(1900,1, distance=distance)
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%gui qt
cam.show_gui()
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')

## ---(Mon Oct 22 16:53:17 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%gui qt
cam.show_gui()
test_spot = [20,-10,0,1];
distance = 2900e3


# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
#slm.update_gaussian_to_tophat(1900,1, distance=distance)
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')

## ---(Mon Oct 22 17:11:40 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%gui qt
cam.show_gui()
test_spot = [20,-10,0,1];
distance = 2900e3


# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
#slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot + [0,0,0.75,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
1.0/self.wavevector
test_spot = [20,-10,0,1];
distance = 2900e3


# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
type(wavevector)
wavevector = UniformProperty(7, max_length=1) #k
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
type(wavevector)
slm.update_gaussian_to_tophat(1900,1, distance=distance)
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
slm.update_gaussian_to_tophat(1900,1, distance=distance)

## ---(Mon Oct 22 17:28:27 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
## TURN LIGHTS OFF!
#cam.exposure=-2
#snap = calibrate_hdr()
test_spot = [20,-10,0,1];
distance = 2900e3


# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
## TURN LIGHTS OFF!
#cam.exposure=-2
#snap = calibrate_hdr()
wavevector = UniformProperty(7, max_length=1)
runfile('C:/local/dev/slm_interference_lithography/opengl_holograms.py', wdir='C:/local/dev/slm_interference_lithography')
wavevector = UniformProperty(7, max_length=1)
type(wavevector)
runfile('C:/local/dev/slm_interference_lithography/opengl_holograms.py', wdir='C:/local/dev/slm_interference_lithography')
UniformProperty.wavevector = 15700
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
test_spot = [20,-10,0,1];
distance = 2900e3


# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
## TURN LIGHTS OFF!
#cam.exposure=-2
#snap = calibrate_hdr()
UniformProperty.radial_phase_dr = 0.009 * 2.0
runfile('C:/local/dev/slm_interference_lithography/opengl_holograms.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
test_spot = [20,-10,0,1];
distance = 2900e3


# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
## TURN LIGHTS OFF!
#cam.exposure=-2
#snap = calibrate_hdr()
u=UniformProperty(1)
import opengl_holograms as oh
u=oh.UniformProperty(1)
dir(u)
u.set(2)
u=2
print u
test_spot = [20,-10,0,1];
distance = 2900e3


# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
## TURN LIGHTS OFF!
#cam.exposure=-2
#snap = calibrate_hdr()
u
print u
dir(u)
print u.uniform_id
type(u)
u=UniformProperty(2)
import opengl_holograms as oh
u=oh.UniformProperty(2)
type(u)
dir(u)
u.uniform_id
test_spot = [20,-10,0,1];
distance = 2900e3


# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
## TURN LIGHTS OFF!
#cam.exposure=-2
#snap = calibrate_hdr()
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
oh
import opengl_holograms as oh
u=oh.UniformProperty(2)
type(u)
dir(u)
u.get()
u.__get__()
u.__get__(self)
u.__get__(uniform_id)
u.__get__(self.uniform_id)
self
wavevector
print(slm)
print slm.wavevector
dir(slm.wavevector)
print slm.wavevector.uniform_id
print slm.wavevector.max_length
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
print slm.wavevector.
print slm
print slm.wavevector
print slm.wavevector.last_value
print slm.wavevector.uniform_id
u=[1,2,3]
u
print u.uniform_id
print u.last_value
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
len(1)
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
1.0/float(self.wavevector)
1.0/wavevector
1/15700
1.0/15700
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
test_spot = [20,-10,0,1];
distance = 2900e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
%qt gui
%gui qt
cam.show_gui()
test_spot = [20,-10,0,1];
distance = 1900e3
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
test_spot = [20,-10,0,1];
distance = 2500e3

slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
test_spot = [20,-10,0,1];
distance = 3000e3
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
1.0/15700
runfile('C:/local/dev/slm_interference_lithography/slm_interference_lithography.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')

## ---(Wed Oct 24 15:28:25 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
test_spot = [20,-10,0,1];
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
test_spot = [20,-10,0,1];
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
%gui qt
cam.show_gui()
test_spot = [5,-10,0,1];
distance = 3000e3
slm.make_spots([test_spot + [0,0,0.075,0]])
test_spot = [50,-10,0,1];
distance = 3000e3
slm.make_spots([test_spot + [0,0,0.075,0]])
test_spot = [80,-10,0,1];
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
test_spot = [100,-10,0,1];
distance = 3000e3
slm.make_spots([test_spot + [0,0,0.075,0]])
test_spot = [100,-100,0,1];
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
test_spot = [20,-10,0,1];
distance = 3000e3
slm.make_spots([test_spot + [0,0,0.075,0]])
test_spot = [20,-10,10,1];
distance = 3000e3
slm.make_spots([test_spot + [0,0,0.075,0]])
test_spot = [20,-10,100,1];
distance = 3000e3
slm.make_spots([test_spot + [0,0,0.075,0]])
test_spot = [20,-10,0,10];
distance = 3000e3
slm.make_spots([test_spot + [0,0,0.075,0]])
test_spot = [80,-80,0,10];
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
test_spot = [80,-80,10,10];
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
test_spot = [80,-80,0,100];
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
test_spot = [80,-80,0,10];
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
test_spot = [80,-80,3000,10];
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
test_spot = [80,-80,0,10];
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.075,0]])
test_spot = [90,-90,0,10];
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
test_spot = [90,-90,0,10];
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
test_spot = [50,-50,0,10];
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
test_spot = [200,-200,0,10];
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
test_spot = [200,-200,100,10];
distance = 3000e3
slm.make_spots([test_spot + [0,0,0.075,0]])

zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients

test_spot = [200,-200,3000,10];
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
test_spot = [200,-200,0,100];
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
test_spot = [200,-200,0,100];
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
res = sequential_shack_hartmann(slm, snap, [20,-10,0,1], 10, overlap=0.5)
plot_shack_hartmann(res)
res = sequential_shack_hartmann(slm, snap, test_spot, 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.075,0]])
res = sequential_shack_hartmann(slm, snap, test_spot, 10, overlap=0.5)
plot_shack_hartmann(res)
test_spot = [200,-200,0,100];
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
res = sequential_shack_hartmann(slm, snap, test_spot, 10, overlap=0.5)
plot_shack_hartmann(res)
modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m, discard_edges=1)


slm_size = 6.9
initial_r = 1.9
N = res.shape[0]
x = (np.arange(N)-(N-1)/2.0)/N * slm_size #centres of apertures
gaussian = np.exp(-x**2/initial_r**2)
gaussian /= np.mean(gaussian)
f, axes = plt.subplots(1,2)
# plot the data and a Gaussian fit
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(x, data[:,i], '+', color=plt.cm.gist_rainbow(float(i)/N))
        m = np.polyfit(gaussian, data[:,i], 1)
        ax.plot(x, gaussian*m[0]+m[1], '-', color=plt.cm.gist_rainbow(float(i)/N))

# plot the data against the Gaussian
f, axes = plt.subplots(1,2)
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(gaussian, data[:,i], '-+', color=plt.cm.gist_rainbow(float(i)/N))


# plot the data vs r
r = np.sqrt(x[:,np.newaxis]**2 + x[np.newaxis,:]**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')

plt.figure()
s=slm_size/2.0
plt.imshow(res[:,:,2],extent=(-s,s,-s,s))
for thresh in [0.0,0.1,0.2,0.5,0.9]:
    I = res[:,:,2].copy()
    I /= np.max(I)
    I -= thresh
    I[I<0] = 0
    cx = np.sum(x[:,np.newaxis]*I)/np.sum(I)
    cy = np.sum(x[np.newaxis,:]*I)/np.sum(I)
    hide = plt.plot(cy,cx,'+')
    print "found centroid at {}, {} with threshold {}".format(cx, cy, thresh)


r = np.sqrt((x[:,np.newaxis]-cx)**2 + (x[np.newaxis,:]-cy)**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')
I = res[:,:,2].flatten()/I.max()*10
from scipy.interpolate import UnivariateSpline
spl = UnivariateSpline(np.concatenate([radii,-radii]), np.tile(I,2))
rr = np.linspace(0,slm_size/np.sqrt(2),100)
plt.plot(rr,spl(rr))
plt.plot(radii,I,'.')

slm.centre=(cx,cy)
slm.radial_blaze_function = np.ones(384)
inner_edge_i = 1500//18 #bad
sd = 400/18.0
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function
radii = r.flatten()
I = res[:,:,2].flatten()/I.max()*10
from scipy.interpolate import UnivariateSpline
spl = UnivariateSpline(np.concatenate([radii,-radii]), np.tile(I,2))
rr = np.linspace(0,slm_size/np.sqrt(2),100)
plt.plot(rr,spl(rr))
plt.plot(radii,I,'.')
slm.centre=(cx,cy)
slm.radial_blaze_function = np.ones(384)
inner_edge_i = 1500//18 #bad
sd = 400/18.0
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.75,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#dim_slm(1)
#dim_slm(0.75)
#dim_slm(0.5)
#dim_slm(0.2)
#dim_slm(0.1)
#cam.exposure=-2
def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))

def brightest_g():
    time.sleep(0.1)
    #cam.color_image()
    hdr = snap()
    img = hdr[...,0]
    #img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += hdr[...,1]
        #avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    #cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})
oldzernike_coefficients = zernike_coefficients


print(oldzernike_coefficients)
slm.make_spots([test_spot])
slm.make_spots([test_spot + [0,0,0.75,0]])
slm.make_spots([test_spot])
test_spot = [200,-200,0,100];
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
zernike_coefficients = np.zeros(12)
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
slm.make_spots([test_spot + [0,0,0.075,0]])
res = sequential_shack_hartmann(slm, snap, test_spot, 10, overlap=0.5)
plot_shack_hartmann(res)

slm.make_spots([test_spot + [0,0,0.075,0]])
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, test_spot, 10, overlap=0.5)
plot_shack_hartmann(res)
modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m, discard_edges=1)


slm_size = 6.9
initial_r = 1.9
N = res.shape[0]
x = (np.arange(N)-(N-1)/2.0)/N * slm_size #centres of apertures
gaussian = np.exp(-x**2/initial_r**2)
gaussian /= np.mean(gaussian)
f, axes = plt.subplots(1,2)
# plot the data and a Gaussian fit
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(x, data[:,i], '+', color=plt.cm.gist_rainbow(float(i)/N))
        m = np.polyfit(gaussian, data[:,i], 1)
        ax.plot(x, gaussian*m[0]+m[1], '-', color=plt.cm.gist_rainbow(float(i)/N))

# plot the data against the Gaussian
f, axes = plt.subplots(1,2)
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(gaussian, data[:,i], '-+', color=plt.cm.gist_rainbow(float(i)/N))


# plot the data vs r
r = np.sqrt(x[:,np.newaxis]**2 + x[np.newaxis,:]**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')
plt.figure()
s=slm_size/2.0
plt.imshow(res[:,:,2],extent=(-s,s,-s,s))
for thresh in [0.0,0.1,0.2,0.5,0.9]:
    I = res[:,:,2].copy()
    I /= np.max(I)
    I -= thresh
    I[I<0] = 0
    cx = np.sum(x[:,np.newaxis]*I)/np.sum(I)
    cy = np.sum(x[np.newaxis,:]*I)/np.sum(I)
    hide = plt.plot(cy,cx,'+')
    print "found centroid at {}, {} with threshold {}".format(cx, cy, thresh)


r = np.sqrt((x[:,np.newaxis]-cx)**2 + (x[np.newaxis,:]-cy)**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')

radii = r.flatten()
I = res[:,:,2].flatten()/I.max()*10
from scipy.interpolate import UnivariateSpline
spl = UnivariateSpline(np.concatenate([radii,-radii]), np.tile(I,2))
rr = np.linspace(0,slm_size/np.sqrt(2),100)
plt.plot(rr,spl(rr))
plt.plot(radii,I,'.')

slm.centre=(cx,cy)
slm.radial_blaze_function = np.ones(384)
inner_edge_i = 1500//18 #bad
sd = 400/18.0
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.75,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#dim_slm(1)
#dim_slm(0.75)
#dim_slm(0.5)
#dim_slm(0.2)
#dim_slm(0.1)
#cam.exposure=-2
def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))

def brightest_g():
    time.sleep(0.1)
    #cam.color_image()
    hdr = snap()
    img = hdr[...,0]
    #img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += hdr[...,1]
        #avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    #cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])

# Start by autofocusing (optimising mode 2)
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})

zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.75,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#dim_slm(1)
#dim_slm(0.75)
#dim_slm(0.5)
#dim_slm(0.2)
#dim_slm(0.1)
#cam.exposure=-2
def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))

def brightest_g():
    time.sleep(0.1)
    #cam.color_image()
    hdr = snap()
    img = hdr[...,0]
    #img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += hdr[...,1]
        #avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    #cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])

# Start by autofocusing (optimising mode 2)
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})

%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')

## ---(Thu Oct 25 11:12:00 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%gui qt
cam.show_gui()
test_spot = [200,-200,0,100];
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, test_spot, 10, overlap=0.5)
plot_shack_hartmann(res)
test_spot = [200,-200,0,100];
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
test_spot = [200,-200,0,100];
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, test_spot, 10, overlap=0.5)
plot_shack_hartmann(res)
modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m, discard_edges=1)


slm_size = 6.9
initial_r = 1.9
N = res.shape[0]
x = (np.arange(N)-(N-1)/2.0)/N * slm_size #centres of apertures
gaussian = np.exp(-x**2/initial_r**2)
gaussian /= np.mean(gaussian)
f, axes = plt.subplots(1,2)
# plot the data and a Gaussian fit
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(x, data[:,i], '+', color=plt.cm.gist_rainbow(float(i)/N))
        m = np.polyfit(gaussian, data[:,i], 1)
        ax.plot(x, gaussian*m[0]+m[1], '-', color=plt.cm.gist_rainbow(float(i)/N))

# plot the data against the Gaussian
f, axes = plt.subplots(1,2)
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(gaussian, data[:,i], '-+', color=plt.cm.gist_rainbow(float(i)/N))


r = np.sqrt(x[:,np.newaxis]**2 + x[np.newaxis,:]**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')

# find the centroid
plt.figure()
s=slm_size/2.0
plt.imshow(res[:,:,2],extent=(-s,s,-s,s))
for thresh in [0.0,0.1,0.2,0.5,0.9]:
    I = res[:,:,2].copy()
    I /= np.max(I)
    I -= thresh
    I[I<0] = 0
    cx = np.sum(x[:,np.newaxis]*I)/np.sum(I)
    cy = np.sum(x[np.newaxis,:]*I)/np.sum(I)
    hide = plt.plot(cy,cx,'+')
    print "found centroid at {}, {} with threshold {}".format(cx, cy, thresh)


r = np.sqrt((x[:,np.newaxis]-cx)**2 + (x[np.newaxis,:]-cy)**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')
radii = r.flatten()
I = res[:,:,2].flatten()/I.max()*10
from scipy.interpolate import UnivariateSpline
spl = UnivariateSpline(np.concatenate([radii,-radii]), np.tile(I,2))
rr = np.linspace(0,slm_size/np.sqrt(2),100)
plt.plot(rr,spl(rr))
plt.plot(radii,I,'.')
slm.centre=(cx,cy)
slm.radial_blaze_function = np.ones(384)
inner_edge_i = 1500//18 #bad
sd = 400/18.0
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.75,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#dim_slm(1)
#dim_slm(0.75)
#dim_slm(0.5)
#dim_slm(0.2)
#dim_slm(0.1)
#cam.exposure=-2
def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))

def brightest_g():
    time.sleep(0.1)
    #cam.color_image()
    hdr = snap()
    img = hdr[...,0]
    #img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += hdr[...,1]
        #avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    #cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)


test_spot = [200,-200,0,100];
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
test_spot = [200,-200,0,100];
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
zernike_coefficients = np.zeros(12)
slm.make_spots([test_spot + [0,0,0.075,0]])
test_spot = [200,-200,0,100];
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, test_spot, 10, overlap=0.5)
plot_shack_hartmann(res)
modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m, discard_edges=1)


test_spot = [200,-200,0,100];
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm_size = 6.9
initial_r = 1.9
N = res.shape[0]
x = (np.arange(N)-(N-1)/2.0)/N * slm_size #centres of apertures
gaussian = np.exp(-x**2/initial_r**2)
gaussian /= np.mean(gaussian)
f, axes = plt.subplots(1,2)
# plot the data and a Gaussian fit
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(x, data[:,i], '+', color=plt.cm.gist_rainbow(float(i)/N))
        m = np.polyfit(gaussian, data[:,i], 1)
        ax.plot(x, gaussian*m[0]+m[1], '-', color=plt.cm.gist_rainbow(float(i)/N))

# plot the data against the Gaussian
f, axes = plt.subplots(1,2)
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(gaussian, data[:,i], '-+', color=plt.cm.gist_rainbow(float(i)/N))


r = np.sqrt(x[:,np.newaxis]**2 + x[np.newaxis,:]**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')
plt.figure()
s=slm_size/2.0
plt.imshow(res[:,:,2],extent=(-s,s,-s,s))
for thresh in [0.0,0.1,0.2,0.5,0.9]:
    I = res[:,:,2].copy()
    I /= np.max(I)
    I -= thresh
    I[I<0] = 0
    cx = np.sum(x[:,np.newaxis]*I)/np.sum(I)
    cy = np.sum(x[np.newaxis,:]*I)/np.sum(I)
    hide = plt.plot(cy,cx,'+')
    print "found centroid at {}, {} with threshold {}".format(cx, cy, thresh)


r = np.sqrt((x[:,np.newaxis]-cx)**2 + (x[np.newaxis,:]-cy)**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')
radii = r.flatten()
I = res[:,:,2].flatten()/I.max()*10
from scipy.interpolate import UnivariateSpline
spl = UnivariateSpline(np.concatenate([radii,-radii]), np.tile(I,2))
rr = np.linspace(0,slm_size/np.sqrt(2),100)
plt.plot(rr,spl(rr))
plt.plot(radii,I,'.')
slm.centre=(cx,cy)
slm.radial_blaze_function = np.ones(384)
inner_edge_i = 1500//18 #bad
sd = 400/18.0
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.75,0]])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot])
test_spot = [200,-200,0,100];
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))

def brightest_g():
    time.sleep(0.1)
    #cam.color_image()
    hdr = snap()
    img = hdr[...,0]
    #img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += hdr[...,1]
        #avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    #cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)


zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})

oldzcs = zernike_coefficients
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
zernike_coefficients
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)


zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})
zernike_coefficients
oldzcs
oldzcs2 = zernike_coefficients
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)


zernike_coefficients
oldzcs2_repeathalf = zernike_coefficients
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})
oldzcs2_repeat = zernike_coefficients
zernike_coefficients
oldzcs
oldzcs2
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})
zernike_coefficients
oldzcs2_repeat
oldzcs2_repeat2 = zernike_coefficients
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})
zernike_coefficients

oldzcs2_repeat2
oldzcs2_repeat3
oldzcs2_repeat3 = zernike_coefficients
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)


oldzcs2_repeat3
zernike_coefficients
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})
zernike_coefficients
oldzcs2_repeat3
slm.make_spots([test_spot + [0,0,0.5,0]])
slm.make_spots([test_spot + [0,0,0.75,0]])
slm.make_spots([test_spot + [0,0,0.25,0]])
slm.make_spots([test_spot + [0,0,0.20,0]])
slm.make_spots([test_spot + [0,0,0.15,0]]
slm.update_gaussian_to_tophat(1900,1, distance=distance)
focus_stack(50,5, snap=snap)
img = snap()
imgsize = np.shape(img)
width = int(imgsize[0])/10

xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
#rs = np.linspace(-5,5,xsection.shape[0])
rs = np.linspace(-100,100,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    #plt.imshow(img)
    #raw_input('Press <ENTER> to continue')
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))

img = snap()
imgsize = np.shape(img)
width = int(imgsize[0])/10

xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
#rs = np.linspace(-5,5,xsection.shape[0])
rs = np.linspace(-100,100,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    #plt.imshow(img)
    #raw_input('Press <ENTER> to continue')
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))

img = snap()
imgsize = np.shape(img)
width = int(imgsize[0])/10

xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
#rs = np.linspace(-5,5,xsection.shape[0])
rs = np.linspace(-50,50,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    #plt.imshow(img)
    #raw_input('Press <ENTER> to continue')
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))

slm.make_spots([test_spot + [0,0,0.15,0]])
zernike_coefficients = oldzcs3_repeat3
zernike_coefficients = oldzcs2_repeat3
slm.make_spots([test_spot + [0,0,0.15,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
test_spot = [200,-200,0,100];
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.make_spots([test_spot + [0,0,0.15,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(50,5, snap=snap)
slm.make_spots([test_spot + [0,0,0.15,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(50,5, snap=snap)

slm.make_spots([test_spot + [0,0,0.15,0]])
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
zernike_coefficents

## ---(Thu Oct 25 17:39:41 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%qt gui
%gui qt
cam.show_gui()
test_spot = [200,-200,0,100];
distance = 3000e3
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, test_spot, 10, overlap=0.5)
plot_shack_hartmann(res)
modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m, discard_edges=1)


lm_size = 6.9
initial_r = 1.9
N = res.shape[0]
x = (np.arange(N)-(N-1)/2.0)/N * slm_size #centres of apertures
gaussian = np.exp(-x**2/initial_r**2)
gaussian /= np.mean(gaussian)
f, axes = plt.subplots(1,2)
# plot the data and a Gaussian fit
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(x, data[:,i], '+', color=plt.cm.gist_rainbow(float(i)/N))
        m = np.polyfit(gaussian, data[:,i], 1)
        ax.plot(x, gaussian*m[0]+m[1], '-', color=plt.cm.gist_rainbow(float(i)/N))

# plot the data against the Gaussian
f, axes = plt.subplots(1,2)
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(gaussian, data[:,i], '-+', color=plt.cm.gist_rainbow(float(i)/N))


slm_size = 6.9
initial_r = 1.9
N = res.shape[0]
x = (np.arange(N)-(N-1)/2.0)/N * slm_size #centres of apertures
gaussian = np.exp(-x**2/initial_r**2)
gaussian /= np.mean(gaussian)
f, axes = plt.subplots(1,2)
# plot the data and a Gaussian fit
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(x, data[:,i], '+', color=plt.cm.gist_rainbow(float(i)/N))
        m = np.polyfit(gaussian, data[:,i], 1)
        ax.plot(x, gaussian*m[0]+m[1], '-', color=plt.cm.gist_rainbow(float(i)/N))

# plot the data against the Gaussian
f, axes = plt.subplots(1,2)
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(gaussian, data[:,i], '-+', color=plt.cm.gist_rainbow(float(i)/N))


r = np.sqrt(x[:,np.newaxis]**2 + x[np.newaxis,:]**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')
plt.figure()
s=slm_size/2.0
plt.imshow(res[:,:,2],extent=(-s,s,-s,s))
for thresh in [0.0,0.1,0.2,0.5,0.9]:
    I = res[:,:,2].copy()
    I /= np.max(I)
    I -= thresh
    I[I<0] = 0
    cx = np.sum(x[:,np.newaxis]*I)/np.sum(I)
    cy = np.sum(x[np.newaxis,:]*I)/np.sum(I)
    hide = plt.plot(cy,cx,'+')
    print "found centroid at {}, {} with threshold {}".format(cx, cy, thresh)


r = np.sqrt((x[:,np.newaxis]-cx)**2 + (x[np.newaxis,:]-cy)**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')

radii = r.flatten()
I = res[:,:,2].flatten()/I.max()*10
from scipy.interpolate import UnivariateSpline
spl = UnivariateSpline(np.concatenate([radii,-radii]), np.tile(I,2))
rr = np.linspace(0,slm_size/np.sqrt(2),100)
plt.plot(rr,spl(rr))
plt.plot(radii,I,'.')

slm.centre=(cx,cy)
slm.radial_blaze_function = np.ones(384)
inner_edge_i = 1500//18 #bad
sd = 400/18.0
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot
slm.radial_blaze_function = np.ones(384)
test_spot = [200,-200,0,100];
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.radial_blaze_function = radial_blaze_function
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.75,0]])
#slm.make_spots([test_spot])
#slm.update_gaussian_to_tophat(1900,1, distance=distance)
#dim_slm(1)
#dim_slm(0.75)
#dim_slm(0.5)
#dim_slm(0.2)
#dim_slm(0.1)
#cam.exposure=-2
def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))

def brightest_g():
    time.sleep(0.1)
    #cam.color_image()
    hdr = snap()
    img = hdr[...,0]
    #img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += hdr[...,1]
        #avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    #cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})

"""
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})
slm.make_spots([test_spot + [0,0,0.15,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})

focus_stack(50,5, snap=snap)
slm.update_gaussian_to_tophat(1900,1, distance=distance)
focus_stack(50,5, snap=snap)
slm.update_gaussian_to_tophat(2500,1, distance=distance)
slm.update_gaussian_to_tophat(2500,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(50,5, snap=snap)
slm.update_gaussian_to_tophat(3500,1, distance=distance)
slm.update_gaussian_to_tophat(5000,1, distance=distance)
slm.update_gaussian_to_tophat(5000,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(50,5, snap=snap)
wavelength
wavevector
slm.wavevector
slm.wavelength
1.0/(slm.wavevector)
slm.radial_phase_dr
radii
gaussian_to_tophat_phase(100, slm.radial_phase_dr, slm.wavelength, initial_r, initial_r, distance)
update_gaussian_to_tophat
update_gaussian_to_tophat()
update_gaussian_to_tophat(1,1,1)
slm.gaussian_to_tophat_phase(100, slm.radial_phase_dr, slm.wavelength, initial_r, initial_r, distance)
slm.gaussian_to_tophat_phase(100, slm.radial_phase_dr, 1.0/slm.wavevector, initial_r, initial_r, distance)
slm.update_gaussian_to_tophat(initial_r, initial_r, distance)
focus_stack(50,5, snap=snap)
slm.disable_gaussian_to_tophat()
focus_stack(50,5, snap=snap)
slm.update_gaussian_to_tophat(initial_r, initial_r, distance)
slm.disable_gaussian_to_tophat()
slm.update_gaussian_to_tophat(initial_r, 1, distance)
focus_stack(50,5, snap=snap)
slm.update_gaussian_to_tophat(1, 1, distance)
focus_stack(50,5, snap=snap)
slm.update_gaussian_to_tophat(1900, 1900, distance)
focus_stack(50,5, snap=snap)
slm.update_gaussian_to_tophat(3000, 3000, distance)
focus_stack(50,5, snap=snap)
slm.update_gaussian_to_tophat(3000, 6000, distance)
focus_stack(50,5, snap=snap)
slm.update_gaussian_to_tophat(300, 6000, distance)
focus_stack(50,5, snap=snap)
slm.update_gaussian_to_tophat(300, 60, distance)
focus_stack(50,5, snap=snap)
slm.update_gaussian_to_tophat(300, 1, distance)
focus_stack(50,5, snap=snap)
slm.update_gaussian_to_tophat(5000,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(50,5, snap=snap)
slm.make_spots([test_spot + [0,0,0.1,0]])
slm.update_gaussian_to_tophat(5000,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(50,5, snap=snap)
slm.make_spots([test_spot + [0,0,0.2,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(50,5, snap=snap)

img = snap()
imgsize = np.shape(img)
width = int(imgsize[0])/10

xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
#rs = np.linspace(-5,5,xsection.shape[0])
rs = np.linspace(-50,50,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    #plt.imshow(img)
    #raw_input('Press <ENTER> to continue')
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))
slm.make_spots([test_spot + [0,0,0.2,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
zernike_coefficients = zernike_coefficients
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')

## ---(Mon Oct 29 11:35:43 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%qt gui
%gui qt
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
slm_size = 6.9
initial_r = 1.9
N = res.shape[0]
x = (np.arange(N)-(N-1)/2.0)/N * slm_size #centres of apertures
gaussian = np.exp(-x**2/initial_r**2)
gaussian /= np.mean(gaussian)
f, axes = plt.subplots(1,2)
# plot the data and a Gaussian fit
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(x, data[:,i], '+', color=plt.cm.gist_rainbow(float(i)/N))
        m = np.polyfit(gaussian, data[:,i], 1)
        ax.plot(x, gaussian*m[0]+m[1], '-', color=plt.cm.gist_rainbow(float(i)/N))

# plot the data against the Gaussian
f, axes = plt.subplots(1,2)
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(gaussian, data[:,i], '-+', color=plt.cm.gist_rainbow(float(i)/N))


# plot the data vs r
r = np.sqrt(x[:,np.newaxis]**2 + x[np.newaxis,:]**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')

# find the centroid
plt.figure()
s=slm_size/2.0
plt.imshow(res[:,:,2],extent=(-s,s,-s,s))
for thresh in [0.0,0.1,0.2,0.5,0.9]:
    I = res[:,:,2].copy()
    I /= np.max(I)
    I -= thresh
    I[I<0] = 0
    cx = np.sum(x[:,np.newaxis]*I)/np.sum(I)
    cy = np.sum(x[np.newaxis,:]*I)/np.sum(I)
    hide = plt.plot(cy,cx,'+')
    print "found centroid at {}, {} with threshold {}".format(cx, cy, thresh)


# pick the right values for cx and cy...
r = np.sqrt((x[:,np.newaxis]-cx)**2 + (x[np.newaxis,:]-cy)**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')

radii = r.flatten()
I = res[:,:,2].flatten()/I.max()*10
from scipy.interpolate import UnivariateSpline
spl = UnivariateSpline(np.concatenate([radii,-radii]), np.tile(I,2))
rr = np.linspace(0,slm_size/np.sqrt(2),100)
plt.plot(rr,spl(rr))
plt.plot(radii,I,'.')
np.concatenate([radii,-radii])
radii = r.flatten()
I = res[:,:,2].flatten()/I.max()*10
from scipy.interpolate import UnivariateSpline
#spl = UnivariateSpline(np.concatenate([radii,-radii]), np.tile(I,2))
rr = np.linspace(0,slm_size/np.sqrt(2),100)
#plt.plot(rr,spl(rr))
plt.plot(radii,I,'.')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')

## ---(Mon Oct 29 12:03:49 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')

## ---(Mon Oct 29 15:20:18 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%qt gui
%gui qt
cam.show_gui()
test_spot = [200,-200,0,100];
distance = 3000e3

# Calibrate HDR processing (not needed unless you're 
# struggling, snap is already defined.)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
## TURN LIGHTS OFF!
#cam.exposure=-2
#snap = calibrate_hdr()
import nplab
%gui qt
df = nplab.datafile.DataFile('C:/local/dev/slm_interference_lithography/2018-10-25-2.h5', mode='r')
df.show_gui()
def plot_shack_hartmann(results, threshold=0.1):
    """Plot the results of the above wavefront sensor"""
    N = results.shape[0]
    weights = results[:,:,2] > results[:,:,2].max()*threshold
    centre = np.mean(results[:,:,:2]*weights[:,:,np.newaxis], axis=(0,1))/np.mean(weights)
    r = np.max(np.abs((results[:,:,:2]-centre)*weights[:,:,np.newaxis]))
    f, ax = plt.subplots(1,2)
    for i in range(N):
        for j in range(N):
            if weights[i,j] > 0:
                u = (i+0.5)/N - 0.5
                v = (j+0.5)/N - 0.5
                shift = (results[i,j,:2] - centre)/r/N
                ax[0].plot([u,u+shift[0]],[v,v+shift[1]],'o-')
    ax[1].imshow(results[:,:,2], cmap='cubehelix')


import numpy as np
import matplotlib.pyplot as plt
plot_shack_hartmann(df['sequential_shack_hartmann_0'])
plot_shack_hartmann(df['sequential_shack_hartmann_1'])
plot_shack_hartmann(df['sequential_shack_hartmann_2'])
plot_shack_hartmann(df['sequential_shack_hartmann_3'])
plot_shack_hartmann(df['sequential_shack_hartmann_4'])
plot_shack_hartmann(df['sequential_shack_hartmann_5'])
plot_shack_hartmann(df['sequential_shack_hartmann_6'])
plot_shack_hartmann(df['sequential_shack_hartmann_7'])
plot_shack_hartmann(df['sequential_shack_hartmann_8'])
plot_shack_hartmann(df['sequential_shack_hartmann_9'])
plot_shack_hartmann(df['sequential_shack_hartmann_10'])
plot_shack_hartmann(df['sequential_shack_hartmann_11'])
plot_shack_hartmann(df['sequential_shack_hartmann_0'])
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, test_spot, 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
res = sequential_shack_hartmann(slm, snap, test_spot, 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.make_spots([test_spot + [0,0,1,0]])
dset = focus_stack(11, 0.5, snap)
z = slm.zernike_coefficients
z
slm.zernike_coefficients[1] = 10
slm.zernike_coefficients
slm.zernike_coefficients = slm.zernike_coefficients
slm.zernike_coefficients = np.zeros(12)
slm.disable_gaussian_to_tophat()
slm.gaussian_to_tophat(1900, 1, distance)
slm.update_gaussian_to_tophat(1900, 1, distance)
slm.focal_length
slm.focal_length = 3040*1e3
slm.update_gaussian_to_tophat(1.9, 0.0001, slm.focal_length)
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.update_gaussian_to_tophat(1.9, 1.9)
slm.disable_gaussian_to_tophat(1.9, 1.9)
slm.disable_gaussian_to_tophat()
slm.zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = np.zeros(12)
slm.centre = [0.5, 0.5]
slm.radial_phase_dr = 0.009*2
slm.wavevector = 15700
slm.focal_length = 3040
slm.make_spots([[20,10,0,1],[-20,10,0,1]])
slm.make_spots([[0,0,0,1]])
test_spot = [200,-200,0,100];
slm.make_spots([test_spot + [0,0,0.075,0]])
slm.make_spots([test_spot])
test_spot = [20,10,0,100];
slm.make_spots([test_spot])
test_spot = [30,20,0,100];
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1.9, 0.001)
slm.focal_length
slm.radial_phase_dr
1/slm.wavevector
1.0/slm.wavevector
1.0/slm.wavevector*1e6
1.0/(633e-9*1e3)
1.0/_
slm.wavevector
2*np.pi/(400e-9*1e3)
slm.wavevector = 2*np.pi*1e6/633.0
slm.wavevector
2*np.pi/float(self.wavevector)
2*np.pi/float(slm.wavevector)
nplab.close_current_datafile()
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%gui qt
%matplotlib inline
6.9/768
3040*0.000633/6.9
10/_
slm.focal_length
nplab.close_current_datafile()
%gui qt
%matplotlib inline
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
IL_SHADER_SOURCE = """
uniform vec4 spots[100];
uniform int n;
uniform float blazing[32];
uniform float zernikeCoefficients[12];
uniform float radialPhase["""+str(RADIAL_ARRAY_LENGTH)+"""];
uniform float radialPhaseDr = 0.009 * 2.0;
uniform float radialBlaze["""+str(RADIAL_ARRAY_LENGTH)+"""];
uniform float k=15700; //units of mm-1
uniform float f=3500.0; //mm
uniform vec2 slmsize=vec2(6.9,6.9); //size of SLM
uniform vec2 slmcentre=vec2(0.5,0.5); //centre of SLM
const float pi = 3.141;

float wrap2pi(float phase){
  return mod(phase + pi, 2*pi) -pi;
}

float phase_to_gray(float phase){
  return phase/2.0/pi +0.5;
}

vec2 unitvector(float angle){
  return vec2(cos(angle), sin(angle));
}

float apply_LUT(float phase){
  int phint = int(floor((phase/2.0/pi +0.5)*30.9999999)); //blazing table element just before our point
  float alpha = fract((phase/2.0/pi +0.5)*30.9999999); //remainder
  return mix(blazing[phint], blazing[phint+1], alpha); //this uses the blazing table with linear interpolation
}

float zernikeAberration(){
//this function is exactly the same as zernikeCombination, except that it uses a uniform
//called zernikeCoefficients as its argument.  This avoids copying the array = more efficient.
  //takes a 12-element array of coefficients, and returns a weighted sum
  //of Zernike modes.  This should now be THE way of generating aberration
  //corrections from Zernikes...
  float x = 2.0*gl_TexCoord[0].x - 1.0;
  float y = 2.0*gl_TexCoord[0].y - 1.0;
  float r2 = x*x+y*y;
  float a = 0.0;
  a += zernikeCoefficients[0] * (2.0*x*y);                                                //(2,-2)
  a += zernikeCoefficients[1] * (2.0*r2-1.0);                                           //(2,0)
  a += zernikeCoefficients[2] * (x*x-y*y);                                               //(2,2)
  a += zernikeCoefficients[3] * (3.0*x*x*y-y*y*y);                                 //(3,-3)
  a += zernikeCoefficients[4] * ((3.0*r2-2.0)*y);                                    //(3,-1)
  a += zernikeCoefficients[5] * ((3.0*r2-2.0)*x);                                    //(3,1)
  a += zernikeCoefficients[6] * (x*x*x-3.0*x*y*y);                                 //(3,3)
  a += zernikeCoefficients[7] * (4.0*x*y*(x*x-y*y));                              //(4,-4)
  a += zernikeCoefficients[8] * ((4.0*r2-3.0)*2.0*x*y);                          //(4,-2)
  a += zernikeCoefficients[9] * (6.0*r2*r2-6*r2+1);                               //(4,0)
  a += zernikeCoefficients[10] * ((4.0*r2-3.0)*(x*x-y*y));                      //(4,2)
  a += zernikeCoefficients[11] * (x*x*x*x-6.0*x*x*y*y+y*y*y*y);          //(4,4)
  return a;
}

float radialPhaseFunction(vec2 uv){
  //calculate a radially-symmetric phase function from the uniform radialPhase
  float r = sqrt(dot(uv,uv));
  int index = int(floor(r/radialPhaseDr));
  float alpha = fract(r/radialPhaseDr);
  return mix(radialPhase[index], radialPhase[index+1], alpha);
}
float radialBlazeFunction(vec2 uv){
  //calculate a radially-symmetric phase function from the uniform radialPhase
  float r = sqrt(dot(uv,uv));
  int index = int(floor(r/radialPhaseDr));
  float alpha = fract(r/radialPhaseDr);
  return mix(radialBlaze[index], radialBlaze[index+1], alpha);
}

void main(){ // basic gratings and lenses for a single spot
  vec2 uv = (gl_TexCoord[0].xy - slmcentre)*slmsize;
  vec3 pos = vec3(k*uv/f, -k*dot(uv,uv)/(2.0*f*f));
  float basephase = zernikeAberration() + radialPhaseFunction(uv);
  float phase, real=0.0, imag=0.0;
  for(int i; i<2*n; i+=2){
    if(length(uv/slmsize - spots[i+1].xy) < spots[i+1][2]){
      phase = dot(pos, spots[i].xyz) + basephase;
      float amp = spots[i][3];
      real += amp * sin(phase);
      imag += amp * cos(phase);
    }
  }
  
  phase = atan(real, imag);
  float g = apply_LUT(phase);
  g = (g-0.5) * radialBlazeFunction(uv) + 0.5;
  gl_FragColor=vec4(g,g,g,1.0);
  //gl_FragColor=vec4(1,1,0,1);
}
"""
RADIAL_ARRAY_LENGTH = 384
IL_SHADER_SOURCE = """
uniform vec4 spots[100];
uniform int n;
uniform float blazing[32];
uniform float zernikeCoefficients[12];
uniform float radialPhase["""+str(RADIAL_ARRAY_LENGTH)+"""];
uniform float radialPhaseDr = 0.009 * 2.0;
uniform float radialBlaze["""+str(RADIAL_ARRAY_LENGTH)+"""];
uniform float k=15700; //units of mm-1
uniform float f=3500.0; //mm
uniform vec2 slmsize=vec2(6.9,6.9); //size of SLM
uniform vec2 slmcentre=vec2(0.5,0.5); //centre of SLM
const float pi = 3.141;

float wrap2pi(float phase){
  return mod(phase + pi, 2*pi) -pi;
}

float phase_to_gray(float phase){
  return phase/2.0/pi +0.5;
}

vec2 unitvector(float angle){
  return vec2(cos(angle), sin(angle));
}

float apply_LUT(float phase){
  int phint = int(floor((phase/2.0/pi +0.5)*30.9999999)); //blazing table element just before our point
  float alpha = fract((phase/2.0/pi +0.5)*30.9999999); //remainder
  return mix(blazing[phint], blazing[phint+1], alpha); //this uses the blazing table with linear interpolation
}

float zernikeAberration(){
//this function is exactly the same as zernikeCombination, except that it uses a uniform
//called zernikeCoefficients as its argument.  This avoids copying the array = more efficient.
  //takes a 12-element array of coefficients, and returns a weighted sum
  //of Zernike modes.  This should now be THE way of generating aberration
  //corrections from Zernikes...
  float x = 2.0*gl_TexCoord[0].x - 1.0;
  float y = 2.0*gl_TexCoord[0].y - 1.0;
  float r2 = x*x+y*y;
  float a = 0.0;
  a += zernikeCoefficients[0] * (2.0*x*y);                                                //(2,-2)
  a += zernikeCoefficients[1] * (2.0*r2-1.0);                                           //(2,0)
  a += zernikeCoefficients[2] * (x*x-y*y);                                               //(2,2)
  a += zernikeCoefficients[3] * (3.0*x*x*y-y*y*y);                                 //(3,-3)
  a += zernikeCoefficients[4] * ((3.0*r2-2.0)*y);                                    //(3,-1)
  a += zernikeCoefficients[5] * ((3.0*r2-2.0)*x);                                    //(3,1)
  a += zernikeCoefficients[6] * (x*x*x-3.0*x*y*y);                                 //(3,3)
  a += zernikeCoefficients[7] * (4.0*x*y*(x*x-y*y));                              //(4,-4)
  a += zernikeCoefficients[8] * ((4.0*r2-3.0)*2.0*x*y);                          //(4,-2)
  a += zernikeCoefficients[9] * (6.0*r2*r2-6*r2+1);                               //(4,0)
  a += zernikeCoefficients[10] * ((4.0*r2-3.0)*(x*x-y*y));                      //(4,2)
  a += zernikeCoefficients[11] * (x*x*x*x-6.0*x*x*y*y+y*y*y*y);          //(4,4)
  return a;
}

float radialPhaseFunction(vec2 uv){
  //calculate a radially-symmetric phase function from the uniform radialPhase
  float r = sqrt(dot(uv,uv));
  int index = int(floor(r/radialPhaseDr));
  float alpha = fract(r/radialPhaseDr);
  return mix(radialPhase[index], radialPhase[index+1], alpha);
}
float radialBlazeFunction(vec2 uv){
  //calculate a radially-symmetric phase function from the uniform radialPhase
  float r = sqrt(dot(uv,uv));
  int index = int(floor(r/radialPhaseDr));
  float alpha = fract(r/radialPhaseDr);
  return mix(radialBlaze[index], radialBlaze[index+1], alpha);
}

void main(){ // basic gratings and lenses for a single spot
  vec2 uv = (gl_TexCoord[0].xy - slmcentre)*slmsize;
  vec3 pos = vec3(k*uv/f, -k*dot(uv,uv)/(2.0*f*f));
  float basephase = zernikeAberration() + radialPhaseFunction(uv);
  float phase, real=0.0, imag=0.0;
  for(int i; i<2*n; i+=2){
    if(length(uv/slmsize - spots[i+1].xy) < spots[i+1][2]){
      phase = dot(pos, spots[i].xyz) + basephase;
      float amp = spots[i][3];
      real += amp * sin(phase);
      imag += amp * cos(phase);
    }
  }
  
  phase = atan(real, imag);
  float g = apply_LUT(phase);
  g = (g-0.5) * radialBlazeFunction(uv) + 0.5;
  gl_FragColor=vec4(g,g,g,1.0);
  //gl_FragColor=vec4(1,1,0,1);
}
"""
IL_SHADER_SOURCE = """
uniform vec4 spots[100];
uniform int n;
uniform float blazing[32];
uniform float zernikeCoefficients[12];
uniform float radialPhase["""+str(RADIAL_ARRAY_LENGTH)+"""];
uniform float radialPhaseDr = 0.009 * 2.0;
uniform float radialBlaze["""+str(RADIAL_ARRAY_LENGTH)+"""];
uniform float k=15700; //units of mm-1
uniform float f=3500.0; //mm
uniform vec2 slmsize=vec2(6.9,6.9); //size of SLM
uniform vec2 slmcentre=vec2(0.5,0.5); //centre of SLM
const float pi = 3.141;

float wrap2pi(float phase){
  return mod(phase + pi, 2*pi) -pi;
}

float phase_to_gray(float phase){
  return phase/2.0/pi +0.5;
}

vec2 unitvector(float angle){
  return vec2(cos(angle), sin(angle));
}

float apply_LUT(float phase){
  int phint = int(floor((phase/2.0/pi +0.5)*30.9999999)); //blazing table element just before our point
  float alpha = fract((phase/2.0/pi +0.5)*30.9999999); //remainder
  return mix(blazing[phint], blazing[phint+1], alpha); //this uses the blazing table with linear interpolation
}

float zernikeAberration(){
//this function is exactly the same as zernikeCombination, except that it uses a uniform
//called zernikeCoefficients as its argument.  This avoids copying the array = more efficient.
  //takes a 12-element array of coefficients, and returns a weighted sum
  //of Zernike modes.  This should now be THE way of generating aberration
  //corrections from Zernikes...
  float x = 2.0*gl_TexCoord[0].x - 1.0;
  float y = 2.0*gl_TexCoord[0].y - 1.0;
  float r2 = x*x+y*y;
  float a = 0.0;
  a += zernikeCoefficients[0] * (2.0*x*y);                                                //(2,-2)
  a += zernikeCoefficients[1] * (2.0*r2-1.0);                                           //(2,0)
  a += zernikeCoefficients[2] * (x*x-y*y);                                               //(2,2)
  a += zernikeCoefficients[3] * (3.0*x*x*y-y*y*y);                                 //(3,-3)
  a += zernikeCoefficients[4] * ((3.0*r2-2.0)*y);                                    //(3,-1)
  a += zernikeCoefficients[5] * ((3.0*r2-2.0)*x);                                    //(3,1)
  a += zernikeCoefficients[6] * (x*x*x-3.0*x*y*y);                                 //(3,3)
  a += zernikeCoefficients[7] * (4.0*x*y*(x*x-y*y));                              //(4,-4)
  a += zernikeCoefficients[8] * ((4.0*r2-3.0)*2.0*x*y);                          //(4,-2)
  a += zernikeCoefficients[9] * (6.0*r2*r2-6*r2+1);                               //(4,0)
  a += zernikeCoefficients[10] * ((4.0*r2-3.0)*(x*x-y*y));                      //(4,2)
  a += zernikeCoefficients[11] * (x*x*x*x-6.0*x*x*y*y+y*y*y*y);          //(4,4)
  return a;
}

float radialPhaseFunction(vec2 uv){
  //calculate a radially-symmetric phase function from the uniform radialPhase
  float r = sqrt(dot(uv,uv));
  int index = int(floor(r/radialPhaseDr));
  float alpha = fract(r/radialPhaseDr);
  return mix(radialPhase[index], radialPhase[index+1], alpha);
}
float radialBlazeFunction(vec2 uv){
  //calculate a radially-symmetric phase function from the uniform radialPhase
  float r = sqrt(dot(uv,uv));
  int index = int(floor(r/radialPhaseDr));
  float alpha = fract(r/radialPhaseDr);
  return mix(radialBlaze[index], radialBlaze[index+1], alpha);
}

void main(){ // basic gratings and lenses for a single spot
  vec2 uv = (gl_TexCoord[0].xy - slmcentre)*slmsize;
  vec3 pos = vec3(k*uv/f, -k*dot(uv,uv)/(2.0*f*f));
  float basephase = zernikeAberration() + radialPhaseFunction(uv);
  float phase, real=0.0, imag=0.0;
  for(int i; i<2*n; i+=2){
    if(length(uv/slmsize - spots[i+1].xy) < spots[i+1][2]){
      phase = dot(pos, spots[i].xyz) + basephase;
      float amp = spots[i][3];
      real += amp * sin(phase);
      imag += amp * cos(phase);
    }
  }
  
  phase = atan(real, imag);
  float g = apply_LUT(phase);
  g = (g-0.5) * radialBlazeFunction(uv) + 0.5;
  gl_FragColor=vec4(g,g,g,1.0);
  gl_FragColor=vec4(1,1,0,1);
}
"""
slm.shader_source = IL_SHADER_SOURCE
slm.shader_source = slm_interference_lithography.IL_SHADER_SOURCE
import slm_interference_lithography
slm.shader_source = slm_interference_lithography.IL_SHADER_SOURCE
slm.centre = [0.5, 0.5]
slm.active_area = [6.9, 6.9]
slm.radial_phase_dr = 0.009*2
slm.wavevector = 1.0/(633e-9*1e3)
slm.focal_length = 3040
slm.disable_gaussian_to_tophat()
slm.make_spots([[20,10,0,1],[-20,10,0,1]])
test_spot = [-20,10,0,1]
slm.make_spots([test_spot])
test_spot = [200,-200,0,100]
slm.make_spots([test_spot])
nplab.close_current_datafile()
%gui qt
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
slm = VeryCleverBeamsplitter()
slm.move_hologram(1920,0,1024,768)
blazing_function = np.array([  0,   0,   0,   0,   0,   0,   0,   0,   0,  12,  69,  92, 124,
blazing_function = np.array([  0,   0,   0,   0,   0,   0,   0,   0,   0,  12,  69,  92, 124,
   139, 155, 171, 177, 194, 203, 212, 225, 234, 247, 255, 255, 255,
   255, 255, 255, 255, 255, 255]).astype(np.float)/255.0 #np.linspace(0,1,32)
slm.blazing_function = blazing_function

slm.zernike_coefficients = np.zeros(12)
slm.centre = [0.5, 0.5]
slm = VeryCleverBeamsplitter()
slm.move_hologram(1920,0,1024,768)
blazing_function = np.array([  0,   0,   0,   0,   0,   0,   0,   0,   0,  12,  69,  92, 124,
   139, 155, 171, 177, 194, 203, 212, 225, 234, 247, 255, 255, 255,
   255, 255, 255, 255, 255, 255]).astype(np.float)/255.0 #np.linspace(0,1,32)
slm.blazing_function = blazing_function

slm.blazing_function = np.linspace(0,1,32)
slm.centre = [0.5, 0.5]
slm.active_area = [6.9, 6.9]
slm.radial_phase_dr = 0.009*2
slm.wavevector = 1.0/(633e-9*1e3)
slm.focal_length = 3040
slm.disable_gaussian_to_tophat()
test_spot = [-20,10,0,1]
slm.make_spots([test_spot])
slm.move_hologram(1920,0,1024,768)
nplab.close_current_datafile()
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
slm.wavevector = 2*np.pi/(633e-9*1e3)
#    slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.focal_length
slm.radial_phase_dr
2*np.pi/float(self.wavevector)
2*np.pi/float(slm.wavevector)
plt.plot(slm.radial_phase)
slm.make_spots([[0,0,0,1]])
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.radial_phase
np.max(slm.radial_phase)
np.min(slm.radial_phase)
slm.radial_phase_dr
slm.radial_phase_dr = 0.018
slm.active_area[0]/2.0/slm.radial_phase_dr
slm.radial_phase[191]
slm.radial_phase = slm.radial_phase
slm.zernike_coefficients[1] = 5
slm.zernike_coefficients = slm.zernike_coefficients
slm.zernike_coefficients[1] = 0
slm.zernike_coefficients = slm.zernike_coefficients
slm.make_spots([[0,0,100,1]])
slm.make_spots([[0,0,1000,1]])
slm.make_spots([[0,0,0,1]])
slm.radial_phase = np.linspace(0,600,384)
RADIAL_ARRAY_LENGTH = 384
slm.shader_source = """
uniform vec4 spots[100];
uniform int n;
uniform float blazing[32];
uniform float zernikeCoefficients[12];
uniform float radialPhase["""+str(RADIAL_ARRAY_LENGTH)+"""];
uniform float radialPhaseDr = 0.009 * 2.0;
uniform float radialBlaze["""+str(RADIAL_ARRAY_LENGTH)+"""];
uniform float k=15700; //units of mm-1
uniform float f=3500.0; //mm
uniform vec2 slmsize=vec2(6.9,6.9); //size of SLM
uniform vec2 slmcentre=vec2(0.5,0.5); //centre of SLM
const float pi = 3.141;

float wrap2pi(float phase){
  return mod(phase + pi, 2*pi) -pi;
}

float phase_to_gray(float phase){
  return phase/2.0/pi +0.5;
}

vec2 unitvector(float angle){
  return vec2(cos(angle), sin(angle));
}

float apply_LUT(float phase){
  int phint = int(floor((phase/2.0/pi +0.5)*30.9999999)); //blazing table element just before our point
  float alpha = fract((phase/2.0/pi +0.5)*30.9999999); //remainder
  return mix(blazing[phint], blazing[phint+1], alpha); //this uses the blazing table with linear interpolation
}

float zernikeAberration(){
//this function is exactly the same as zernikeCombination, except that it uses a uniform
//called zernikeCoefficients as its argument.  This avoids copying the array = more efficient.
  //takes a 12-element array of coefficients, and returns a weighted sum
  //of Zernike modes.  This should now be THE way of generating aberration
  //corrections from Zernikes...
  float x = 2.0*gl_TexCoord[0].x - 1.0;
  float y = 2.0*gl_TexCoord[0].y - 1.0;
  float r2 = x*x+y*y;
  float a = 0.0;
  a += zernikeCoefficients[0] * (2.0*x*y);                                                //(2,-2)
  a += zernikeCoefficients[1] * (2.0*r2-1.0);                                           //(2,0)
  a += zernikeCoefficients[2] * (x*x-y*y);                                               //(2,2)
  a += zernikeCoefficients[3] * (3.0*x*x*y-y*y*y);                                 //(3,-3)
  a += zernikeCoefficients[4] * ((3.0*r2-2.0)*y);                                    //(3,-1)
  a += zernikeCoefficients[5] * ((3.0*r2-2.0)*x);                                    //(3,1)
  a += zernikeCoefficients[6] * (x*x*x-3.0*x*y*y);                                 //(3,3)
  a += zernikeCoefficients[7] * (4.0*x*y*(x*x-y*y));                              //(4,-4)
  a += zernikeCoefficients[8] * ((4.0*r2-3.0)*2.0*x*y);                          //(4,-2)
  a += zernikeCoefficients[9] * (6.0*r2*r2-6*r2+1);                               //(4,0)
  a += zernikeCoefficients[10] * ((4.0*r2-3.0)*(x*x-y*y));                      //(4,2)
  a += zernikeCoefficients[11] * (x*x*x*x-6.0*x*x*y*y+y*y*y*y);          //(4,4)
  return a;
}

float radialPhaseFunction(vec2 uv){
  //calculate a radially-symmetric phase function from the uniform radialPhase
  float r = sqrt(dot(uv,uv));
  int index = int(floor(r/radialPhaseDr));
  float alpha = fract(r/radialPhaseDr);
  //return mix(radialPhase[index], radialPhase[index+1], alpha);
  return 4.0*r;
}
float radialBlazeFunction(vec2 uv){
  //calculate a radially-symmetric phase function from the uniform radialPhase
  float r = sqrt(dot(uv,uv));
  int index = int(floor(r/radialPhaseDr));
  float alpha = fract(r/radialPhaseDr);
  return mix(radialBlaze[index], radialBlaze[index+1], alpha);
}

void main(){ // basic gratings and lenses for a single spot
  vec2 uv = (gl_TexCoord[0].xy - slmcentre)*slmsize;
  vec3 pos = vec3(k*uv/f, -k*dot(uv,uv)/(2.0*f*f));
  float basephase = zernikeAberration() + radialPhaseFunction(uv);
  float phase, real=0.0, imag=0.0;
  for(int i; i<2*n; i+=2){
    if(length(uv/slmsize - spots[i+1].xy) < spots[i+1][2]){
      phase = dot(pos, spots[i].xyz) + basephase;
      float amp = spots[i][3];
      real += amp * sin(phase);
      imag += amp * cos(phase);
    }
  }
  
  phase = atan(real, imag);
  float g = apply_LUT(phase);
  g = (g-0.5) * radialBlazeFunction(uv) + 0.5;
  gl_FragColor=vec4(g,g,g,1.0);
  //gl_FragColor=vec4(1,1,0,1);
}
"""
blazing_function = np.array([  0,   0,   0,   0,   0,   0,   0,   0,   0,  12,  69,  92, 124,
   139, 155, 171, 177, 194, 203, 212, 225, 234, 247, 255, 255, 255,
   255, 255, 255, 255, 255, 255]).astype(np.float)/255.0 #np.linspace(0,1,32)
slm.blazing_function = blazing_function
slm.zernike_coefficients = np.zeros(12)
slm.centre = [0.5, 0.5]
slm.active_area = [6.9, 6.9]
slm.radial_phase_dr = 0.009*2
slm.wavevector = 2*np.pi/(633e-9*1e3)
slm.focal_length = 3040
#distance = 2325e3
#slm.update_gaussian_to_tophat(1900,3000, distance=distance)
#slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.disable_gaussian_to_tophat()
slm.make_spots([[20,10,0,1],[-20,10,0,1]])
test_spot = [-20,10,0,1]
slm.make_spots([test_spot])
blazing_function = np.array([  0,   0,   0,   0,   0,   0,   0,   0,   0,  12,  69,  92, 124,
   139, 155, 171, 177, 194, 203, 212, 225, 234, 247, 255, 255, 255,
   255, 255, 255, 255, 255, 255]).astype(np.float)/255.0 #np.linspace(0,1,32)
slm.blazing_function = blazing_function
slm.zernike_coefficients = np.zeros(12)
slm.centre = [0.5, 0.5]
slm.active_area = [6.9, 6.9]
slm.radial_phase_dr = 0.009*2
slm.wavevector = 2*np.pi/(633e-9*1e3)
slm.focal_length = 3040
#distance = 2325e3
#slm.update_gaussian_to_tophat(1900,3000, distance=distance)
#slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.disable_gaussian_to_tophat()
slm.make_spots([[20,10,0,1],[-20,10,0,1]])
test_spot = [-20,10,0,1]
slm.make_spots([test_spot])

RADIAL_ARRAY_LENGTH = 384
slm.shader_source = """
uniform vec4 spots[100];
uniform int n;
uniform float blazing[32];
uniform float zernikeCoefficients[12];
uniform float radialPhase["""+str(RADIAL_ARRAY_LENGTH)+"""];
uniform float radialPhaseDr = 0.009 * 2.0;
uniform float radialBlaze["""+str(RADIAL_ARRAY_LENGTH)+"""];
uniform float k=15700; //units of mm-1
uniform float f=3500.0; //mm
uniform vec2 slmsize=vec2(6.9,6.9); //size of SLM
uniform vec2 slmcentre=vec2(0.5,0.5); //centre of SLM
const float pi = 3.141;

float wrap2pi(float phase){
  return mod(phase + pi, 2*pi) -pi;
}

float phase_to_gray(float phase){
  return phase/2.0/pi +0.5;
}

vec2 unitvector(float angle){
  return vec2(cos(angle), sin(angle));
}

float apply_LUT(float phase){
  int phint = int(floor((phase/2.0/pi +0.5)*30.9999999)); //blazing table element just before our point
  float alpha = fract((phase/2.0/pi +0.5)*30.9999999); //remainder
  return mix(blazing[phint], blazing[phint+1], alpha); //this uses the blazing table with linear interpolation
}

float zernikeAberration(){
//this function is exactly the same as zernikeCombination, except that it uses a uniform
//called zernikeCoefficients as its argument.  This avoids copying the array = more efficient.
  //takes a 12-element array of coefficients, and returns a weighted sum
  //of Zernike modes.  This should now be THE way of generating aberration
  //corrections from Zernikes...
  float x = 2.0*gl_TexCoord[0].x - 1.0;
  float y = 2.0*gl_TexCoord[0].y - 1.0;
  float r2 = x*x+y*y;
  float a = 0.0;
  a += zernikeCoefficients[0] * (2.0*x*y);                                                //(2,-2)
  a += zernikeCoefficients[1] * (2.0*r2-1.0);                                           //(2,0)
  a += zernikeCoefficients[2] * (x*x-y*y);                                               //(2,2)
  a += zernikeCoefficients[3] * (3.0*x*x*y-y*y*y);                                 //(3,-3)
  a += zernikeCoefficients[4] * ((3.0*r2-2.0)*y);                                    //(3,-1)
  a += zernikeCoefficients[5] * ((3.0*r2-2.0)*x);                                    //(3,1)
  a += zernikeCoefficients[6] * (x*x*x-3.0*x*y*y);                                 //(3,3)
  a += zernikeCoefficients[7] * (4.0*x*y*(x*x-y*y));                              //(4,-4)
  a += zernikeCoefficients[8] * ((4.0*r2-3.0)*2.0*x*y);                          //(4,-2)
  a += zernikeCoefficients[9] * (6.0*r2*r2-6*r2+1);                               //(4,0)
  a += zernikeCoefficients[10] * ((4.0*r2-3.0)*(x*x-y*y));                      //(4,2)
  a += zernikeCoefficients[11] * (x*x*x*x-6.0*x*x*y*y+y*y*y*y);          //(4,4)
  return a;
}

float radialPhaseFunction(vec2 uv){
  //calculate a radially-symmetric phase function from the uniform radialPhase
  float r = sqrt(dot(uv,uv));
  int index = int(floor(r/radialPhaseDr));
  float alpha = fract(r/radialPhaseDr);
  //return mix(radialPhase[index], radialPhase[index+1], alpha);
  return 4.0*r;
}
float radialBlazeFunction(vec2 uv){
  //calculate a radially-symmetric phase function from the uniform radialPhase
  float r = sqrt(dot(uv,uv));
  int index = int(floor(r/radialPhaseDr));
  float alpha = fract(r/radialPhaseDr);
  return mix(radialBlaze[index], radialBlaze[index+1], alpha);
}

void main(){ // basic gratings and lenses for a single spot
  vec2 uv = (gl_TexCoord[0].xy - slmcentre)*slmsize;
  vec3 pos = vec3(k*uv/f, -k*dot(uv,uv)/(2.0*f*f));
  float basephase = zernikeAberration() + radialPhaseFunction(uv);
  float phase, real=0.0, imag=0.0;
  for(int i; i<2*n; i+=2){
    if(length(uv/slmsize - spots[i+1].xy) < spots[i+1][2]){
      phase = dot(pos, spots[i].xyz) + basephase;
      float amp = spots[i][3];
      real += amp * sin(phase);
      imag += amp * cos(phase);
    }
  }
  
  phase = atan(real, imag);
  float g = apply_LUT(phase);
  g = (g-0.5) * radialBlazeFunction(uv) + 0.5;
  gl_FragColor=vec4(g,g,g,1.0);
  gl_FragColor=vec4(1,1,0,1);
}
"""
RADIAL_ARRAY_LENGTH = 384
slm.shader_source = """
uniform vec4 spots[100];
uniform int n;
uniform float blazing[32];
uniform float zernikeCoefficients[12];
uniform float radialPhase["""+str(RADIAL_ARRAY_LENGTH)+"""];
uniform float radialPhaseDr = 0.009 * 2.0;
uniform float radialBlaze["""+str(RADIAL_ARRAY_LENGTH)+"""];
uniform float k=15700; //units of mm-1
uniform float f=3500.0; //mm
uniform vec2 slmsize=vec2(6.9,6.9); //size of SLM
uniform vec2 slmcentre=vec2(0.5,0.5); //centre of SLM
const float pi = 3.141;

float wrap2pi(float phase){
  return mod(phase + pi, 2*pi) -pi;
}

float phase_to_gray(float phase){
  return phase/2.0/pi +0.5;
}

vec2 unitvector(float angle){
  return vec2(cos(angle), sin(angle));
}

float apply_LUT(float phase){
  int phint = int(floor((phase/2.0/pi +0.5)*30.9999999)); //blazing table element just before our point
  float alpha = fract((phase/2.0/pi +0.5)*30.9999999); //remainder
  return mix(blazing[phint], blazing[phint+1], alpha); //this uses the blazing table with linear interpolation
}

float zernikeAberration(){
//this function is exactly the same as zernikeCombination, except that it uses a uniform
//called zernikeCoefficients as its argument.  This avoids copying the array = more efficient.
  //takes a 12-element array of coefficients, and returns a weighted sum
  //of Zernike modes.  This should now be THE way of generating aberration
  //corrections from Zernikes...
  float x = 2.0*gl_TexCoord[0].x - 1.0;
  float y = 2.0*gl_TexCoord[0].y - 1.0;
  float r2 = x*x+y*y;
  float a = 0.0;
  a += zernikeCoefficients[0] * (2.0*x*y);                                                //(2,-2)
  a += zernikeCoefficients[1] * (2.0*r2-1.0);                                           //(2,0)
  a += zernikeCoefficients[2] * (x*x-y*y);                                               //(2,2)
  a += zernikeCoefficients[3] * (3.0*x*x*y-y*y*y);                                 //(3,-3)
  a += zernikeCoefficients[4] * ((3.0*r2-2.0)*y);                                    //(3,-1)
  a += zernikeCoefficients[5] * ((3.0*r2-2.0)*x);                                    //(3,1)
  a += zernikeCoefficients[6] * (x*x*x-3.0*x*y*y);                                 //(3,3)
  a += zernikeCoefficients[7] * (4.0*x*y*(x*x-y*y));                              //(4,-4)
  a += zernikeCoefficients[8] * ((4.0*r2-3.0)*2.0*x*y);                          //(4,-2)
  a += zernikeCoefficients[9] * (6.0*r2*r2-6*r2+1);                               //(4,0)
  a += zernikeCoefficients[10] * ((4.0*r2-3.0)*(x*x-y*y));                      //(4,2)
  a += zernikeCoefficients[11] * (x*x*x*x-6.0*x*x*y*y+y*y*y*y);          //(4,4)
  return a;
}

float radialPhaseFunction(vec2 uv){
  //calculate a radially-symmetric phase function from the uniform radialPhase
  float r = sqrt(dot(uv,uv));
  int index = int(floor(r/radialPhaseDr));
  float alpha = fract(r/radialPhaseDr);
  //return mix(radialPhase[index], radialPhase[index+1], alpha);
  return 4.0*r;
}
float radialBlazeFunction(vec2 uv){
  //calculate a radially-symmetric phase function from the uniform radialPhase
  float r = sqrt(dot(uv,uv));
  int index = int(floor(r/radialPhaseDr));
  float alpha = fract(r/radialPhaseDr);
  return mix(radialBlaze[index], radialBlaze[index+1], alpha);
}

void main(){ // basic gratings and lenses for a single spot
  vec2 uv = (gl_TexCoord[0].xy - slmcentre)*slmsize;
  vec3 pos = vec3(k*uv/f, -k*dot(uv,uv)/(2.0*f*f));
  float basephase = zernikeAberration() + radialPhaseFunction(uv);
  float phase, real=0.0, imag=0.0;
  for(int i; i<2*n; i+=2){
    if(length(uv/slmsize - spots[i+1].xy) < spots[i+1][2]){
      phase = dot(pos, spots[i].xyz) + basephase;
      float amp = spots[i][3];
      real += amp * sin(phase);
      imag += amp * cos(phase);
    }
  }
  
  phase = atan(real, imag);
  float g = apply_LUT(phase);
  g = (g-0.5) * radialBlazeFunction(uv) + 0.5;
  gl_FragColor=vec4(g,g,g,1.0);
  //gl_FragColor=vec4(1,1,0,1);
}
"""
slm.move_hologram(1920,0,1024,768)
blazing_function = np.array([  0,   0,   0,   0,   0,   0,   0,   0,   0,  12,  69,  92, 124,
   139, 155, 171, 177, 194, 203, 212, 225, 234, 247, 255, 255, 255,
   255, 255, 255, 255, 255, 255]).astype(np.float)/255.0 #np.linspace(0,1,32)
slm.blazing_function = blazing_function
slm.zernike_coefficients = np.zeros(12)
slm.centre = [0.5, 0.5]
slm.active_area = [6.9, 6.9]
slm.radial_phase_dr = 0.009*2
slm.wavevector = 2*np.pi/(633e-9*1e3)
slm.focal_length = 3040
slm.disable_gaussian_to_tophat()
slm.make_spots([[20,10,0,1],[-20,10,0,1]])
import slm_interference_lithography
slm.shader_source = slm_interference_lithography.IL_SHADER_SOURCE
slm.radial_blaze_function = np.ones(RADIAL_ARRAY_LENGTH)
slm.make_spots([[20,10,0,1],[-20,10,0,1]])
getattr(slm, "wavevector")
nplab.close_current_datafile()
%gui qt
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
slm.update_gaussian_to_tophat(1.9, 0.0001)
%gui qt
cam.show_gui()
slm.make_spots([test_spot + [0,0,0.075,0]])
test_spot
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
slm.make_spots([test_spot[:4] + [0,0,1,0]])
focus_stack(50,5, snap=snap)
def focus_stack(N, dz, snap=None):
    """Shift the focus (using Zernike modes) and acquire images."""
    if snap is None:
        global cam
        snap = lambda: cam.color_image()[:,:,2]
    img = snap()
    focus_stack = ArrayWithAttrs(np.zeros((N,)+img.shape, dtype=img.dtype))
    zernike_coefficients = slm.zernike_coefficients
    for i, d in enumerate(np.linspace(-dz,dz,N)):
        z = zernike_coefficients.copy()
        z[1] += d
        slm.zernike_coefficients = z
        #focus_stack[i,:,:] = snap()
        focus_stack[i,:] = snap()
    slm.zernike_coefficients=zernike_coefficients
    plt.figure()
    #plt.imshow(focus_stack[:,240,:],aspect="auto")
    plt.imshow(focus_stack[:,512],aspect="auto")
    focus_stack.attrs["dz"]=dz
    focus_stack.attrs["zernike_coefficients"]=zernike_coefficients
    dset = nplab.current_datafile().create_dataset("zstack_%d",data=focus_stack)
    return dset


focus_stack(50,5, snap=snap)
df
df['zstack_1']
df.keys()
df['zstack_0'].shape
plt.imshow(df['zstack_0'][:,512,:], aspect="auto")
plt.imshow(df['zstack_0'][:,:,640], aspect="auto")
slm.update_gaussian_to_tophat(1.9, 2)
slm.zernike_coefficients
slm.update_gaussian_to_tophat(1.9, 0.00002)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
slm.zernike_coefficients = np.zeros(12)
res = sequential_shack_hartmann(slm, snap, test_spot, 10, overlap=0.5)
res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)
res
plt.plot(res[:,4,0])
plt.plot(res[:,4,2])
plt.plot(res[:,5,2])
for i in range(10):plt.plot(res[:,i,2])
slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1.9, 2)
slm.update_gaussian_to_tophat(1.5, 2)
slm.update_gaussian_to_tophat(2, 2)
slm.update_gaussian_to_tophat(3, 2)
slm.update_gaussian_to_tophat(3, 0.0002)
slm.make_spots(np.array([test_spot]))
t = (np.array([test_spot]))
t[0,0] += 2
t = (np.array([t]))
slm.make_spots(np.array([t]))
t = (np.array(t[0]))
slm.make_spots(np.array([t]))
t
t.shape
t = (np.array(t[0]))
slm.make_spots(np.array([t]))
slm.make_spots(np.array([test_spot]))
slm.update_gaussian_to_tophat(2.5, 2)
snap()
snap().shape()
snap().shape
plt.plot(np.mean(snap()[512-20:512+20, :], axis=0))
for z in [-3000,-2000,-1000,0]:
    t = np.array(test_spot)
    t[2] = z
    slm.make_spots([t])
    time.sleep(0.2)
    plt.plot(np.mean(snap()[512-20:512+20, :], axis=0))
    
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%gui qt
cam.show_gui()
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)
modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m, discard_edges=1)


slm_size = 6.9
initial_r = 1.9
N = res.shape[0]
x = (np.arange(N)-(N-1)/2.0)/N * slm_size #centres of apertures
gaussian = np.exp(-x**2/initial_r**2)
gaussian /= np.mean(gaussian)
f, axes = plt.subplots(1,2)
# plot the data and a Gaussian fit
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(x, data[:,i], '+', color=plt.cm.gist_rainbow(float(i)/N))
        m = np.polyfit(gaussian, data[:,i], 1)
        ax.plot(x, gaussian*m[0]+m[1], '-', color=plt.cm.gist_rainbow(float(i)/N))

# plot the data against the Gaussian
f, axes = plt.subplots(1,2)
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(gaussian, data[:,i], '-+', color=plt.cm.gist_rainbow(float(i)/N))


# plot the data vs r
r = np.sqrt(x[:,np.newaxis]**2 + x[np.newaxis,:]**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')

plt.figure()
s=slm_size/2.0
plt.imshow(res[:,:,2],extent=(-s,s,-s,s))
for thresh in [0.0,0.1,0.2,0.5,0.9]:
    I = res[:,:,2].copy()
    I /= np.max(I)
    I -= thresh
    I[I<0] = 0
    cx = np.sum(x[:,np.newaxis]*I)/np.sum(I)
    cy = np.sum(x[np.newaxis,:]*I)/np.sum(I)
    hide = plt.plot(cy,cx,'+')
    print "found centroid at {}, {} with threshold {}".format(cx, cy, thresh)


# pick the right values for cx and cy...

# plot the data vs r
r = np.sqrt((x[:,np.newaxis]-cx)**2 + (x[np.newaxis,:]-cy)**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')

radii = r.flatten()
I = res[:,:,2].flatten()/I.max()*10
from scipy.interpolate import UnivariateSpline
spl = UnivariateSpline(np.concatenate([radii,-radii]), np.tile(I,2))
rr = np.linspace(0,slm_size/np.sqrt(2),100)
plt.plot(rr,spl(rr))
plt.plot(radii,I,'.')


slm.centre=(cx,cy)
slm.radial_blaze_function = np.ones(384)
inner_edge_i = 1500//18 #bad
sd = 400/18.0
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.75,0]])
#slm.make_spots([test_spot])
#slm.update_gaussian_to_tophat(1900,1, distance=distance)
#dim_slm(1)
#dim_slm(0.75)
#dim_slm(0.5)
#dim_slm(0.2)
#dim_slm(0.1)
#cam.exposure=-2
def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))

def brightest_g():
    time.sleep(0.1)
    #cam.color_image()
    hdr = snap()
    img = hdr[...,0]
    #img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += hdr[...,1]
        #avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    #cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)


zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})

slm.make_spots([test_spot + [0,0,0.2,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(50,5, snap=snap)

test_spot
slm.make_spots([test_spot[:4] + [0,0,0.2,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(50,5, snap=snap)
distance = 3040
slm.make_spots([test_spot[:4] + [0,0,0.2,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(50,5, snap=snap)
slm.make_spots([test_spot[:4] + [0,0,0.2,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(100,10, snap=snap)

img = snap()
imgsize = np.shape(img)
width = int(imgsize[0])/10

xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
#rs = np.linspace(-5,5,xsection.shape[0])
rs = np.linspace(-50,50,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    #plt.imshow(img)
    #raw_input('Press <ENTER> to continue')
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))
slm.make_spots([test_spot[:4] + [0,0,0.2,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot[:4] + [0,0,2,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)

slm.make_spots([test_spot[:4] + [0,0,0.1,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)

slm.make_spots([test_spot[:4] + [0,0,0.05,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)

focus_stack(50,5, snap=snap)

slm.make_spots([test_spot[:4] + [0,0,0.2,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(50,5, snap=snap)
slm.make_spots([test_spot[:4] + [0,0,0.05,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)

img = snap()
imgsize = np.shape(img)
width = int(imgsize[0])/10

xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
#rs = np.linspace(-5,5,xsection.shape[0])
rs = np.linspace(-50,50,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    #plt.imshow(img)
    #raw_input('Press <ENTER> to continue')
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))
img = snap()
imgsize = np.shape(img)
width = int(imgsize[0])/10

xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
#rs = np.linspace(-5,5,xsection.shape[0])
rs = np.linspace(-50,50,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    #plt.imshow(img)
    #raw_input('Press <ENTER> to continue')
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))

focus_stack(50,5, snap=snap)
focus_stack(100,10,snap=snap)
df.close()
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
close
%close
df.close()
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
distance = 3040
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
# Check you can see the spot when you get to here...
slm.zernike_coefficients = np.zeros(12)
%gui qt
cam.show_gui()
res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)
modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m, discard_edges=1)


slm_size = 6.9
initial_r = 1.9
N = res.shape[0]
x = (np.arange(N)-(N-1)/2.0)/N * slm_size #centres of apertures
gaussian = np.exp(-x**2/initial_r**2)
gaussian /= np.mean(gaussian)
f, axes = plt.subplots(1,2)
# plot the data and a Gaussian fit
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(x, data[:,i], '+', color=plt.cm.gist_rainbow(float(i)/N))
        m = np.polyfit(gaussian, data[:,i], 1)
        ax.plot(x, gaussian*m[0]+m[1], '-', color=plt.cm.gist_rainbow(float(i)/N))

# plot the data against the Gaussian
f, axes = plt.subplots(1,2)
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(gaussian, data[:,i], '-+', color=plt.cm.gist_rainbow(float(i)/N))


# plot the data vs r
r = np.sqrt(x[:,np.newaxis]**2 + x[np.newaxis,:]**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')

# find the centroid
plt.figure()
s=slm_size/2.0
plt.imshow(res[:,:,2],extent=(-s,s,-s,s))
for thresh in [0.0,0.1,0.2,0.5,0.9]:
    I = res[:,:,2].copy()
    I /= np.max(I)
    I -= thresh
    I[I<0] = 0
    cx = np.sum(x[:,np.newaxis]*I)/np.sum(I)
    cy = np.sum(x[np.newaxis,:]*I)/np.sum(I)
    hide = plt.plot(cy,cx,'+')
    print "found centroid at {}, {} with threshold {}".format(cx, cy, thresh)


# pick the right values for cx and cy...

# plot the data vs r
r = np.sqrt((x[:,np.newaxis]-cx)**2 + (x[np.newaxis,:]-cy)**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')

radii = r.flatten()
I = res[:,:,2].flatten()/I.max()*10
from scipy.interpolate import UnivariateSpline
spl = UnivariateSpline(np.concatenate([radii,-radii]), np.tile(I,2))
rr = np.linspace(0,slm_size/np.sqrt(2),100)
plt.plot(rr,spl(rr))
plt.plot(radii,I,'.')


slm.centre=(cx,cy)
slm.radial_blaze_function = np.ones(384)
inner_edge_i = 1500//18 #bad
sd = 400/18.0
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.75,0]])
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))

def brightest_g():
    time.sleep(0.1)
    #cam.color_image()
    hdr = snap()
    img = hdr[...,0]
    #img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += hdr[...,1]
        #avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    #cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])

# Start by autofocusing (optimising mode 2)
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)


zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})
slm.make_spots([test_spot[:4] + [0,0,0.2,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
focus_stack(50,5, snap=snap)
img = snap()
imgsize = np.shape(img)
width = int(imgsize[0])/10

xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
#rs = np.linspace(-5,5,xsection.shape[0])
rs = np.linspace(-50,50,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    #plt.imshow(img)
    #raw_input('Press <ENTER> to continue')
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))
slm.make_spots([test_spot[:4] + [0,0,0.2,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(50,5, snap=snap)
z = zernike_coeffificents
z = zernike_coefficients
focus_stack(50,5, snap=snap)
def focus_stack(N, dz, snap=None):
    """Shift the focus (using Zernike modes) and acquire images."""
    if snap is None:
        global cam
        snap = lambda: cam.color_image()[:,:,2]
    img = snap()
    focus_stack = ArrayWithAttrs(np.zeros((N,)+img.shape, dtype=img.dtype))
    zernike_coefficients = slm.zernike_coefficients
    for i, d in enumerate(np.linspace(-dz,dz,N)):
        #z = zernike_coefficients.copy()
        z = zernike_coefficients
        z[1] += d
        slm.zernike_coefficients = z
        #focus_stack[i,:,:] = snap()
        focus_stack[i,:] = snap()
    slm.zernike_coefficients=zernike_coefficients
    plt.figure()
    #plt.imshow(focus_stack[:,240,:],aspect="auto")
    plt.imshow(focus_stack[:,512],aspect="auto")
    focus_stack.attrs["dz"]=dz
    focus_stack.attrs["zernike_coefficients"]=zernike_coefficients
    dset = nplab.current_datafile().create_dataset("zstack_%d",data=focus_stack)
    return dset


focus_stack(50,5, snap=snap)
slm.make_spots([test_spot[:4] + [0,0,0.2,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot[:4] + [0,0,0.05,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)

slm.make_spots([test_spot[:4] + [0,0,0.04,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)

slm.make_spots([test_spot[:4] + [0,0,0.07,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)

focus_stack(50,5, snap=snap) #focus_stack only works once then throws an error
slm.make_spots([test_spot[:4] + [0,0,0.2,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)

slm.make_spots([test_spot[:4] + [0,0,0.01,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)

slm.make_spots([test_spot[:4] + [0,0,0.1,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)

slm.make_spots([test_spot[:4] + [0,0,0.15,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)

slm.make_spots([test_spot[:4] + [0,0,0.75,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)

slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)

focus_stack(50,5, snap=snap) #focus_stack threw errors with z
slm.make_spots([test_spot[:4] + [0,0,0.05,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)

focus_stack(50,5, snap=snap) #focus_stack threw errors with zc.copy(), changed
img = snap()
imgsize = np.shape(img)
width = int(imgsize[0])/10

xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
#rs = np.linspace(-5,5,xsection.shape[0])
rs = np.linspace(-50,50,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    #plt.imshow(img)
    #raw_input('Press <ENTER> to continue')
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))
focus_stack(50,5, snap=snap) #focus_stack threw errors with zc.copy(), changed
z
clear z
z
focus_stack(50,5,snap=snap)
def focus_stack(N, dz, snap=None):
    """Shift the focus (using Zernike modes) and acquire images."""
    if snap is None:
        global cam
        snap = lambda: cam.color_image()[:,:,2]
    img = snap()
    focus_stack = ArrayWithAttrs(np.zeros((N,)+img.shape, dtype=img.dtype))
    zernike_coefficients = slm.zernike_coefficients
    for i, d in enumerate(np.linspace(-dz,dz,N)):
        z = zernike_coefficients.copy()
        #z = zernike_coefficients
        z[1] += d
        slm.zernike_coefficients = z
        #focus_stack[i,:,:] = snap()
        focus_stack[i,:] = snap()
    slm.zernike_coefficients=zernike_coefficients
    plt.figure()
    #plt.imshow(focus_stack[:,240,:],aspect="auto")
    plt.imshow(focus_stack[:,512],aspect="auto")
    focus_stack.attrs["dz"]=dz
    focus_stack.attrs["zernike_coefficients"]=zernike_coefficients
    dset = nplab.current_datafile().create_dataset("zstack_%d",data=focus_stack)
    return dset


focus_stack(50,5,snap=snap)
def focus_stack(N, dz, snap=None):
    """Shift the focus (using Zernike modes) and acquire images."""
    if snap is None:
        global cam
        snap = lambda: cam.color_image()[:,:,2]
    img = snap()
    focus_stack = ArrayWithAttrs(np.zeros((N,)+img.shape, dtype=img.dtype))
    zernike_coefficients = slm.zernike_coefficients
    for i, d in enumerate(np.linspace(-dz,dz,N)):
        #z = zernike_coefficients.copy()
        #z = zernike_coefficients #attempt to fix1
        z = slm.zernike_coefficients.copy() #attempt to fix2
        z[1] += d
        slm.zernike_coefficients = z
        #focus_stack[i,:,:] = snap()
        focus_stack[i,:] = snap()
    slm.zernike_coefficients=zernike_coefficients
    plt.figure()
    #plt.imshow(focus_stack[:,240,:],aspect="auto")
    plt.imshow(focus_stack[:,512],aspect="auto")
    focus_stack.attrs["dz"]=dz
    focus_stack.attrs["zernike_coefficients"]=zernike_coefficients
    dset = nplab.current_datafile().create_dataset("zstack_%d",data=focus_stack)
    return dset


focus_stack(50,5,snap=snap)
slm.zernike_coefficients
a = [1,2,3]
a.copy()
%clear
debugfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
df.close()
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')

## ---(Thu Nov 01 15:28:59 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')

## ---(Thu Nov 01 16:55:17 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')

## ---(Thu Nov 01 16:59:31 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%qt gui
%gui qt
cam.show_gui()
distance = 3040
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
# Check you can see the spot when you get to here...
slm.zernike_coefficients = np.zeros(12)
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)
distance = 3040
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
# Check you can see the spot when you get to here...
res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)

modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m, discard_edges=1)


slm_size = 6.9
initial_r = 1.9
N = res.shape[0]
x = (np.arange(N)-(N-1)/2.0)/N * slm_size #centres of apertures
gaussian = np.exp(-x**2/initial_r**2)
gaussian /= np.mean(gaussian)
f, axes = plt.subplots(1,2)
# plot the data and a Gaussian fit
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(x, data[:,i], '+', color=plt.cm.gist_rainbow(float(i)/N))
        m = np.polyfit(gaussian, data[:,i], 1)
        ax.plot(x, gaussian*m[0]+m[1], '-', color=plt.cm.gist_rainbow(float(i)/N))

# plot the data against the Gaussian
f, axes = plt.subplots(1,2)
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(gaussian, data[:,i], '-+', color=plt.cm.gist_rainbow(float(i)/N))


# plot the data vs r
r = np.sqrt(x[:,np.newaxis]**2 + x[np.newaxis,:]**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')

# find the centroid
plt.figure()
s=slm_size/2.0
plt.imshow(res[:,:,2],extent=(-s,s,-s,s))
for thresh in [0.0,0.1,0.2,0.5,0.9]:
    I = res[:,:,2].copy()
    I /= np.max(I)
    I -= thresh
    I[I<0] = 0
    cx = np.sum(x[:,np.newaxis]*I)/np.sum(I)
    cy = np.sum(x[np.newaxis,:]*I)/np.sum(I)
    hide = plt.plot(cy,cx,'+')
    print "found centroid at {}, {} with threshold {}".format(cx, cy, thresh)


# pick the right values for cx and cy...

# plot the data vs r
r = np.sqrt((x[:,np.newaxis]-cx)**2 + (x[np.newaxis,:]-cy)**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')

radii = r.flatten()
I = res[:,:,2].flatten()/I.max()*10
from scipy.interpolate import UnivariateSpline
spl = UnivariateSpline(np.concatenate([radii,-radii]), np.tile(I,2))
rr = np.linspace(0,slm_size/np.sqrt(2),100)
plt.plot(rr,spl(rr))
plt.plot(radii,I,'.')


slm.centre=(cx,cy)
slm.radial_blaze_function = np.ones(384)
inner_edge_i = 1500//18 #bad
sd = 400/18.0
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
slm.make_spots([test_spot + [0,0,0.75,0]])
slm.make_spots([test_spot])
slm.make_spots([test_spot[:4] + [0,0,0.75,0]])
slm.make_spots([test_spot[:4]])
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))

def brightest_g():
    time.sleep(0.1)
    #cam.color_image()
    hdr = snap()
    img = hdr[...,0]
    #img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += hdr[...,1]
        #avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    #cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])

# Start by autofocusing (optimising mode 2)
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)


zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})
slm.make_spots([test_spot[:4] + [0,0,0.2,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(50,5, snap=snap) #focus_stack threw errors with zc.copy(), changed
focus_stack(50,5, snap=snap) #focus_stack threw errors with zc.copy(), changed
img = snap()
imgsize = np.shape(img)
width = int(imgsize[0])/10

xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
#rs = np.linspace(-5,5,xsection.shape[0])
rs = np.linspace(-50,50,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    #plt.imshow(img)
    #raw_input('Press <ENTER> to continue')
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))


## ---(Fri Nov 30 10:43:54 2018)---
import nplab
from nplab.instrument.camera.opencv import OpenCVCamera
cam = OpenCVCamera(0)
%gui qt
cam.show_gui(blocking=false)
cam.show_gui(blocking=False)
cam.close()
cam = OpenCVCamera(0)
cam.show_gui(blocking=False)

## ---(Tue Dec 04 11:29:22 2018)---
import nplab
from nplab.instrument.camera.opencv import OpenCVCamera
cam = OpenCVCamera(0)
%gui qt
cam.show_gui(blocking=false)
cam.show_gui(blocking=False)
cam.close()
cam = OpenCVCamera(0)
cam.show_gui(blocking=False)

import nplab
from nplab.instrument.camera.opencv import OpenCVCamera
cam = OpenCVCamera(0)
%gui qt

: cam.show_gui(blocking=False)
cam.close()
cam = OpenCVCamera(0)
cam.show_gui(blocking=False)
cam = OpenCVCamera(0)
cam.show_gui(blocking=False)

cam = OpenCVCamera(0)
cam.show_gui(blocking=False)

## ---(Thu Dec 06 16:12:45 2018)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%gui qt
cam.show_gui()
distance = 3040
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
# Check you can see the spot when you get to here...
slm.zernike_coefficients = np.zeros(12)
res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)

modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m, discard_edges=1)


slm_size = 6.9
initial_r = 1.9
N = res.shape[0]
x = (np.arange(N)-(N-1)/2.0)/N * slm_size #centres of apertures
gaussian = np.exp(-x**2/initial_r**2)
gaussian /= np.mean(gaussian)
f, axes = plt.subplots(1,2)
# plot the data and a Gaussian fit
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(x, data[:,i], '+', color=plt.cm.gist_rainbow(float(i)/N))
        m = np.polyfit(gaussian, data[:,i], 1)
        ax.plot(x, gaussian*m[0]+m[1], '-', color=plt.cm.gist_rainbow(float(i)/N))

# plot the data against the Gaussian
f, axes = plt.subplots(1,2)
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(gaussian, data[:,i], '-+', color=plt.cm.gist_rainbow(float(i)/N))


r = np.sqrt(x[:,np.newaxis]**2 + x[np.newaxis,:]**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')
plt.figure()
s=slm_size/2.0
plt.imshow(res[:,:,2],extent=(-s,s,-s,s))
for thresh in [0.0,0.1,0.2,0.5,0.9]:
    I = res[:,:,2].copy()
    I /= np.max(I)
    I -= thresh
    I[I<0] = 0
    cx = np.sum(x[:,np.newaxis]*I)/np.sum(I)
    cy = np.sum(x[np.newaxis,:]*I)/np.sum(I)
    hide = plt.plot(cy,cx,'+')
    print "found centroid at {}, {} with threshold {}".format(cx, cy, thresh)


r = np.sqrt((x[:,np.newaxis]-cx)**2 + (x[np.newaxis,:]-cy)**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')
radii = r.flatten()
I = res[:,:,2].flatten()/I.max()*10
from scipy.interpolate import UnivariateSpline
spl = UnivariateSpline(np.concatenate([radii,-radii]), np.tile(I,2))
rr = np.linspace(0,slm_size/np.sqrt(2),100)
plt.plot(rr,spl(rr))
plt.plot(radii,I,'.')
slm.centre=(cx,cy)
slm.radial_blaze_function = np.ones(384)
inner_edge_i = 1500//18 #bad
sd = 400/18.0
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.75,0]])
#slm.make_spots([test_spot])
#slm.update_gaussian_to_tophat(1900,1, distance=distance)
#dim_slm(1)
#dim_slm(0.75)
#dim_slm(0.5)
#dim_slm(0.2)
#dim_slm(0.1)
#cam.exposure=-2
def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))

def brightest_g():
    time.sleep(0.1)
    #cam.color_image()
    hdr = snap()
    img = hdr[...,0]
    #img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += hdr[...,1]
        #avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    #cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})
slm.make_spots([test_spot[:4] + [0,0,0.2,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.make_spots([test_spot[:4] + [0,0,0.2,0]])
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
slm.zernike_coefficients = zernike_coefficients
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
distance = 3040
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
distance = 1000
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
distance = 1000
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
%gui qt
cam.show_gui()
slm.zernike_coefficients = np.zeros(12)
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)
modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m, discard_edges=1)


slm_size = 6.9
initial_r = 1.9
N = res.shape[0]
x = (np.arange(N)-(N-1)/2.0)/N * slm_size #centres of apertures
gaussian = np.exp(-x**2/initial_r**2)
gaussian /= np.mean(gaussian)
f, axes = plt.subplots(1,2)
# plot the data and a Gaussian fit
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(x, data[:,i], '+', color=plt.cm.gist_rainbow(float(i)/N))
        m = np.polyfit(gaussian, data[:,i], 1)
        ax.plot(x, gaussian*m[0]+m[1], '-', color=plt.cm.gist_rainbow(float(i)/N))

# plot the data against the Gaussian
f, axes = plt.subplots(1,2)
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(gaussian, data[:,i], '-+', color=plt.cm.gist_rainbow(float(i)/N))


# plot the data vs r
r = np.sqrt(x[:,np.newaxis]**2 + x[np.newaxis,:]**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')

plt.figure()
s=slm_size/2.0
plt.imshow(res[:,:,2],extent=(-s,s,-s,s))
for thresh in [0.0,0.1,0.2,0.5,0.9]:
    I = res[:,:,2].copy()
    I /= np.max(I)
    I -= thresh
    I[I<0] = 0
    cx = np.sum(x[:,np.newaxis]*I)/np.sum(I)
    cy = np.sum(x[np.newaxis,:]*I)/np.sum(I)
    hide = plt.plot(cy,cx,'+')
    print "found centroid at {}, {} with threshold {}".format(cx, cy, thresh)


r = np.sqrt((x[:,np.newaxis]-cx)**2 + (x[np.newaxis,:]-cy)**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')

radii = r.flatten()
I = res[:,:,2].flatten()/I.max()*10
from scipy.interpolate import UnivariateSpline
spl = UnivariateSpline(np.concatenate([radii,-radii]), np.tile(I,2))
rr = np.linspace(0,slm_size/np.sqrt(2),100)
plt.plot(rr,spl(rr))
plt.plot(radii,I,'.')
slm.centre=(cx,cy)
slm.radial_blaze_function = np.ones(384)
inner_edge_i = 1500//18 #bad
sd = 400/18.0
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.75,0]])
#slm.make_spots([test_spot])
#slm.update_gaussian_to_tophat(1900,1, distance=distance)
#dim_slm(1)
#dim_slm(0.75)
#dim_slm(0.5)
#dim_slm(0.2)
#dim_slm(0.1)
#cam.exposure=-2
def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))

def brightest_g():
    time.sleep(0.1)
    #cam.color_image()
    hdr = snap()
    img = hdr[...,0]
    #img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += hdr[...,1]
        #avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    #cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})
slm.make_spots([test_spot[:4] + [0,0,0.2,0]])
slm.update_gaussian_to_tophat(1900,1, distance=di
slm.make_spots([test_spot[:4] + [0,0,0.2,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(50,5, snap=snap) #focus_stack threw errors with zc.copy(), changed

"""
"""
# Scan through a parameter, plotting sections of the beam
#changed this section as camera changed
img = snap()
imgsize = np.shape(img)
width = int(imgsize[0])/10

xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
#rs = np.linspace(-5,5,xsection.shape[0])
rs = np.linspace(-50,50,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    #plt.imshow(img)
    #raw_input('Press <ENTER> to continue')
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%clear
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
distance = 1000
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
distance = 1200
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
%gui qt
cam.show_gui()
distance = 1500
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
slm.make_spots([test_spot[:4] + [0,0,1,0]])
distance = 3000
slm.focal_length
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
slm.zernike_coefficients = np.zeros(12)
res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.update_gaussian_to_tophat(1.9, 1.5)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)
res
swapped = np.array(res)
swapped[0,0,:]
swapped[:,:,0] = res[:,:,1]
swapped[:,:,1] = res[:,:,0]
plot_shack_hartmann(swapped)
plt.plot(res[:,:,2].sum(axis=1))
plt.plot(res[:,:,2].sum(axis=0))
slm.make_spots([test_spot[:4] + [0,0,0.0,0]])
np.sum(snap())
np.sum(snap())/1e6
snap().shape
np.mean(snap())
plt.plot(res[:,4:6,2].mean(axis=0))
plt.plot(res[:,:,2].mean(axis=0))
plt.plot(res[:,3:6,2].mean(axis=0))
plt.plot(res[:,4:6,2].mean(axis=1))
slm.update_gaussian_to_tophat(1.9, 0.0001)
res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)
plot_shack_hartmann(res[:,:,(1,0,2)])
plot_shack_hartmann(res[:,:,[1,0,2]])
plot_shack_hartmann(np.array((res[:,:,1],res[:,:,0],res[:,:,2]))

)
plot_shack_hartmann(np.array((res[:,:,1],res[:,:,0],res[:,:,2])).transpose(1,2,0)


)
plt.plot(np.mean(res[:,:,2], axis=0))
plt.plot(np.mean(res[:,:,2], axis=1))
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
slm.make_spots([test_spot[:4] + [0,0,0.05,0]])
res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.0)
plt.plot(np.mean(res[:,:,2], axis=1))
plt.plot(np.mean(res[:,:,2], axis=0))
res = sequential_shack_hartmann(slm, snap, test_spot[:4], 20, overlap=1.0)
plt.plot(np.mean(res[:,:,2], axis=1))
plt.plot(np.mean(res[:,:,2], axis=0))
plot_shack_hartmann(np.array((res[:,:,1],res[:,:,0],res[:,:,2])))
plot_shack_hartmann(np.array((res[:,:,1],res[:,:,0],res[:,:,2])).transpose(1,2,0))
slm.make_spots([test_spot[:4] + [0,0,0.05,0]])
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?
slm.make_spots([test_spot[:4] + [0,0,1,0]])
plt.plot(radial_blaze_function)
slm.radial_phase_dr
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
slm.zernike_coefficients = np.zeros(12)
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)
modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m, discard_edges=1)


slm_size = 6.9
initial_r = 1.9
N = res.shape[0]
x = (np.arange(N)-(N-1)/2.0)/N * slm_size #centres of apertures
gaussian = np.exp(-x**2/initial_r**2)
gaussian /= np.mean(gaussian)
f, axes = plt.subplots(1,2)
# plot the data and a Gaussian fit
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(x, data[:,i], '+', color=plt.cm.gist_rainbow(float(i)/N))
        m = np.polyfit(gaussian, data[:,i], 1)
        ax.plot(x, gaussian*m[0]+m[1], '-', color=plt.cm.gist_rainbow(float(i)/N))

# plot the data against the Gaussian
f, axes = plt.subplots(1,2)
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(gaussian, data[:,i], '-+', color=plt.cm.gist_rainbow(float(i)/N))


r = np.sqrt(x[:,np.newaxis]**2 + x[np.newaxis,:]**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')

plt.figure()
s=slm_size/2.0
plt.imshow(res[:,:,2],extent=(-s,s,-s,s))
for thresh in [0.0,0.1,0.2,0.5,0.9]:
    I = res[:,:,2].copy()
    I /= np.max(I)
    I -= thresh
    I[I<0] = 0
    cx = np.sum(x[:,np.newaxis]*I)/np.sum(I)
    cy = np.sum(x[np.newaxis,:]*I)/np.sum(I)
    hide = plt.plot(cy,cx,'+')
    print "found centroid at {}, {} with threshold {}".format(cx, cy, thresh)


r = np.sqrt((x[:,np.newaxis]-cx)**2 + (x[np.newaxis,:]-cy)**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')
slm.centre=(cx,cy)
slm.radial_blaze_function = np.ones(384)
inner_edge_i = 1500//18 #bad
sd = 400/18.0
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
slm.make_spots([test_spot[:4] + [0,0,0.05,0]])
plt.plot(radial_blaze_function)
res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
slm.radial_blaze_function = np.ones(384)
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?
inner_edge_i = 5000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
slm.radial_blaze_function = np.ones(384)
inner_edge_i = 1500//18 #bad
sd = 400/18.0
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
plt.plot(radial_blaze_function)
sd = 2000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
plt.plot(radial_blaze_function)
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
res = sequential_shack_hartmann(slm, snap, test_spot[:4], 25, overlap=0.5)
plot_shack_hartmann(res)
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
sd = 100/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
slm.make_spots([test_spot[:4] + [0,0,0.05,0]])
slm.make_spots([test_spot[:4] + [0,0,1,0]])
focus_stack(50,5, snap=snap) #focus_stack threw errors with zc.copy(), changed

xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
#rs = np.linspace(-5,5,xsection.shape[0])
rs = np.linspace(-50,50,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    #plt.imshow(img)
    #raw_input('Press <ENTER> to continue')
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))

img = snap()
imgsize = np.shape(img)
width = int(imgsize[0])/10

xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
#rs = np.linspace(-5,5,xsection.shape[0])
rs = np.linspace(-50,50,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    #plt.imshow(img)
    #raw_input('Press <ENTER> to continue')
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))
slm.make_spots([test_spot[:4] + [0,0,1,0]])
zernike_coefficients = np.zeros(12)
slm.make_spots([test_spot[:4] + [0,0,1,0]])
zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
slm.make_spots([test_spot[:4] + [0,0,1,0]])
sd = 2000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?
slm.make_spots([test_spot[:4] + [0,0,0.5,0]])
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?
slm.make_spots([test_spot[:4] + [0,0,0.5,0]])
slm.make_spots([test_spot[:4] + [0,0,0.05,0]])
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?
slm.make_spots([test_spot[:4] + [0,0,0.1,0]])
slm.make_spots([test_spot[:4] + [0,0,1,0]])
plt.plot(radial_blaze_function)
sd = 1200/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?
plt.plot(radial_blaze_function)
slm.make_spots([test_spot[:4] + [0,0,0.05,0]])
slm.centre=(cx,cy)
slm.radial_blaze_function = np.ones(384)
inner_edge_i = 1500//18 #bad
sd = 400/18.0
inner_edge_i = 1000//18 #good
#sd = 1000/18.0
sd = 1500/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?
slm.make_spots([test_spot[:4] + [0,0,0.05,0]])
sd = 500/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?
slm.make_spots([test_spot[:4] + [0,0,0.05,0]])
inner_edge_i = 1000//18 #good
sd = 1000/18.0
slm.radial_blaze_function = np.ones(384)
slm.make_spots([test_spot[:4] + [0,0,0.05,0]])
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
slm.zernike_coefficients = np.zeros(12)
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%qt gui
%gui qt
cam.show_gui()
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
slm.zernike_coefficients = np.zeros(12)
#dim_slm(1)
#cam.exposure=-5
res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.radial_blaze_function = np.ones(384)
inner_edge_i = 1500//18 #bad
sd = 400/18.0
inner_edge_i = 1000//18 #good
sd = 1000/18.0
inner_edge_i = 800//18 #good
sd = 500/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?
slm.make_spots([test_spot[:4] + [0,0,0.05,0]])
slm.make_spots([test_spot[:4] + [0,0,0.07,0]])
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?
slm.make_spots([test_spot[:4] + [0,0,0.07,0]])
sd = 1500/18.0
slm.make_spots([test_spot[:4] + [0,0,0.07,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.update_gaussian_to_tophat(1.9, 1)
slm.update_gaussian_to_tophat(1.9, 2)
slm.update_gaussian_to_tophat(1.5, 2)
slm.update_gaussian_to_tophat(2.5, 2)
img = snap()
plt.plot(img[:,img.shape[1]//2,:])
plt.plot(img[:,img.shape[1]//2])
slm.radial_blaze_function = np.ones(384)
img = snap()
plt.plot(img[:,img.shape[1]//2])
inner_edge_i = 800//18 #good
sd = 1500/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?
"""
inner_edge_i = 800//18 #good
sd = 1500/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?
images = []
for i in range (10):
    images.append(snap())

averaged = np.mean(images, axis=2)
plt.imshow(averaged)
averaged = np.mean(images, axis=0)
plt.imshow(averaged)
plt.plot(img[:,img.shape[1]//2])
slm.update_gaussian_to_tophat(2.5, 2)
img = snap()
slm.update_gaussian_to_tophat(2.5, 2)
plt.plot(img[:,img.shape[1]//2])
plt.imshow(img)
img = snap()
plt.imshow(img)
plt.plot(img[:,img.shape[1]//2])
slm.make_spots([test_spot[:4] + [0,0,0.2,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#focus_stack(50,5, snap=snap)
focus_stack(50,5, snap=snap) #focus_stack threw errors with zc.copy(), changed

focus_stack(50,5, snap=snap) #focus_stack threw errors with zc.copy(), changed

img = snap()
imgsize = np.shape(img)
width = int(imgsize[0])/10

xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
#rs = np.linspace(-5,5,xsection.shape[0])
rs = np.linspace(-50,50,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    #plt.imshow(img)
    #raw_input('Press <ENTER> to continue')
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))
cam.show_gui()
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?
slm.make_spots([test_spot[:4] + [0,0,0.07,0]])
sd = 1500/18.0
slm.make_spots([test_spot[:4] + [0,0,0.07,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.update_gaussian_to_tophat(1.9, 1)
slm.update_gaussian_to_tophat(1.9, 2)
slm.update_gaussian_to_tophat(1.5, 2)
slm.update_gaussian_to_tophat(2.5, 2)
img = snap()
plt.plot(img[:,img.shape[1]//2,:])
plt.plot(img[:,img.shape[1]//2])
slm.radial_blaze_function = np.ones(384)
img = snap()
plt.plot(img[:,img.shape[1]//2])
inner_edge_i = 800//18 #good
sd = 1500/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?

slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.update_gaussian_to_tophat(1.9, 1)
slm.update_gaussian_to_tophat(1.9, 2)
slm.update_gaussian_to_tophat(1.5, 2)
slm.update_gaussian_to_tophat(2.5, 2)
img = snap()
plt.plot(img[:,img.shape[1]//2,:])
plt.plot(img[:,img.shape[1]//2])
slm.radial_blaze_function = np.ones(384)
img = snap()
plt.plot(img[:,img.shape[1]//2])
inner_edge_i = 800//18 #good
sd = 1500/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?

inner_edge_i = 800//18 #good
sd = 1500/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?
images = []
for i in range (10):
    images.append(snap())

averaged = np.mean(images, axis=2)
plt.imshow(averaged)
averaged = np.mean(images, axis=0)
plt.imshow(averaged)
plt.plot(img[:,img.shape[1]//2])
slm.update_gaussian_to_tophat(2.5, 2)

slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
slm.make_spots([test_spot[:4] + [0,0,0.05,0]])
slm.make_spots([test_spot[:4] + [0,0,1,0]])

distance = 1500
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
slm.make_spots([test_spot[:4] + [0,0,1,0]])
distance = 3000
slm.focal_length
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
slm.zernike_coefficients = np.zeros(12)
res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.update_gaussian_to_tophat(1.9, 1.5)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)
res
swapped = np.array(res)
swapped[0,0,:]
swapped[:,:,0] = res[:,:,1]
swapped[:,:,1] = res[:,:,0]
plot_shack_hartmann(swapped)
plt.plot(res[:,:,2].sum(axis=1))
plt.plot(res[:,:,2].sum(axis=0))
slm.make_spots([test_spot[:4] + [0,0,0.0,0]])
np.sum(snap())
np.sum(snap())/1e6
snap().shape
np.mean(snap())
plt.plot(res[:,4:6,2].mean(axis=0))
plt.plot(res[:,:,2].mean(axis=0))
plt.plot(res[:,3:6,2].mean(axis=0))
plt.plot(res[:,4:6,2].mean(axis=1))
slm.update_gaussian_to_tophat(1.9, 0.0001)
res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)

slm.make_spots([test_spot[:4] + [0,0,0.05,0]])
slm.make_spots([test_spot[:4] + [0,0,0.07,0]])
inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?
slm.make_spots([test_spot[:4] + [0,0,0.07,0]])
sd = 1500/18.0
slm.make_spots([test_spot[:4] + [0,0,0.07,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.update_gaussian_to_tophat(1.9, 1)
slm.update_gaussian_to_tophat(1.9, 2)
slm.update_gaussian_to_tophat(1.5, 2)
slm.update_gaussian_to_tophat(2.5, 2)
img = snap()

inner_edge_i = 800//18 #good
sd = 1500/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?
images = []
for i in range (10):
    images.append(snap())
    
averaged = np.mean(images, axis=2)
plt.imshow(averaged)
averaged = np.mean(images, axis=0)
plt.imshow(averaged)

inner_edge_i = 800//18 #good
sd = 1500/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?
images = []
for i in range (10):
    images.append(snap())
    
averaged = np.mean(images, axis=2)
plt.imshow(averaged)
averaged = np.mean(images, axis=0)
plt.imshow(averaged)

slm.update_gaussian_to_tophat(1.9, 2)
slm.update_gaussian_to_tophat(2.5, 2)
slm.update_gaussian_to_tophat(2.7, 2)
slm.update_gaussian_to_tophat(3, 2)
images = []
for i in range (20):
    images.append(snap())
    
averaged = np.mean(images, axis=0)
plt.imshow(averaged)

res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(1.9, 2)
slm.update_gaussian_to_tophat(2.2, 2)
slm.update_gaussian_to_tophat(2.5, 2)
slm.update_gaussian_to_tophat(2.8, 2)
images = []
for i in range (30):
    images.append(snap())
    
averaged = np.mean(images, axis=0)
plt.imshow(averaged)

res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot[:4] + [0,0,1,0]])
for i in range (30):
    images.append(snap())
    
averaged = np.mean(images, axis=0)
plt.imshow(averaged)

slm.update_gaussian_to_tophat(1.9, 2)
slm.update_gaussian_to_tophat(1.0, 2)
for i in [1.0:0.2:3.5]
for i in [1.0:0.2:3.5]
    print i


for i in range(1.0, 3.0, 0.2)
    print i


for i in range(1.0, 3.0, 0.2)


for i in range(1.0, 4.0, 2)


for i in range(1.0, 4.0, 2)


for in range(1, 4, 2)
for i in range(1,4,2)
for i in range(1,4,2):
    print i
    
for i in range(1.0,3.6,0.2):
    print i
    
for i in range(10,36,2):
    print i/10
    
for i in range(10,36,2):
    print float(i)/10
    
thimages = []
for i in range(10,36,2):
    thnum = float(i)/10
    slm.update_gaussian_to_tophat(thnum, 2)
    thimages.append(snap())
    
plt.imshow(thimages[0])
plt.imshow(thimages[1])
plt.imshow(thimages[2])
plt.imshow(thimages[3])
plt.imshow(thimages[4])
plt.imshow(thimages[5])
plt.imshow(thimages[6])
plt.imshow(thimages[7])
plt.imshow(thimages[8])
plt.imshow(thimages[9])
plt.imshow(thimages[10])
plt.imshow(thimages[11])
plt.imshow(thimages[12])
plt.imshow(thimages[13])
slm.update_gaussian_to_tophat(1.0, 2)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(1.9, 2)
slm.update_gaussian_to_tophat(2, 2)
slm.update_gaussian_to_tophat(2.2, 2)
slm.update_gaussian_to_tophat(2.5, 2)
slm.update_gaussian_to_tophat(2.8, 2)
slm.update_gaussian_to_tophat(2.8, 1)
slm.update_gaussian_to_tophat(1.9, 1)
slm.update_gaussian_to_tophat(2.3, 1)
wait(0.1)
sleep(0.1)
time.sleep(0.1)
time.sleep(1)
averaged = np.mean(images, axis=0)
plt.imshow(averaged)
distance = 3000
slm.focal_length

img = snap()
plt.imshow(img)
plt.plot(img[:,img.shape[1]//2])

thimages = []
lineprofiles = []
for i in range(10, 40, 2):
    thnum = float(i)/10
    slm.update_gaussian_to_tophat(thnum, 2)
    thimages.append(snap())
    img = snap()
    lineprofiles.append(img[:,img.shape[1]//2]))
    time.sleep(0.2)
thimages = []
lineprofiles = []
for i in range(10, 40, 2):
    thnum = float(i)/10
    slm.update_gaussian_to_tophat(thnum, 2)
    thimages.append(snap())
    img = snap()
    lineprofiles.append(img[:,img.shape[1]//2])
    time.sleep(0.2)
    
plt.plot(lineprofiles[0], color ='blue')
plt.plot(lineprofiles[1], color='orange')
plt.xlabel('Pixels')
plt.ylabel('Intensity (arb)')
plt.show()

len(lineprofiles)
plt.plot(lineprofiles[15])
plt.plot(lineprofiles[14])
for i in range(0, len(lineprofiles)-1):
    plt.plot(lineprofiles[i])

plt.xlabel('Pixels')
plt.ylabel('Intensity (arb)')
plt.show()

thimages = []
lineprofiles = []
for i in range(19, 35, 1):
    thnum = float(i)/10
    slm.update_gaussian_to_tophat(thnum, 2)
    thimages.append(snap())
    img = snap()
    lineprofiles.append(img[:,img.shape[1]//2])
    time.sleep(0.2)

#Plot the line profiles
for i in range(0, len(lineprofiles)-1):
    plt.plot(lineprofiles[i])

plt.xlabel('Pixels')
plt.ylabel('Intensity (arb)')
plt.show()

thimages = []
lineprofiles = []
for i in range(19, 35, 1):
    thnum = float(i)/10
    slm.update_gaussian_to_tophat(thnum, 2)
    for j in range (10):
        images.append(snap())
    averaged = np.mean(images, axis=0)
    thimages.append(averaged)
    img = averaged
    lineprofiles.append(img[:,img.shape[1]//2])
    time.sleep(0.2)

#Plot the line profiles
for i in range(0, len(lineprofiles)-1):
    plt.plot(lineprofiles[i])

plt.xlabel('Pixels')
plt.ylabel('Intensity (arb)')
plt.show()

thimages = []
lineprofiles = []
for i in range(18, 39, 1):
    thnum = float(i)/10
    slm.update_gaussian_to_tophat(thnum, 2)
    for j in range (10):
        images.append(snap())
    averaged = np.mean(images, axis=0)
    thimages.append(averaged)
    img = averaged
    lineprofiles.append(img[:,img.shape[1]//2])
    time.sleep(0.2)

#Plot the line profiles
for i in range(0, len(lineprofiles)-1):
    plt.plot(lineprofiles[i])

plt.xlabel('Pixels')
plt.ylabel('Intensity (arb)')
plt.show()

thimages = []
lineprofiles = []
for i in range(15, 45, 1):
    thnum = float(i)/10
    slm.update_gaussian_to_tophat(thnum, 2)
    for j in range (10):
        images.append(snap())
    averaged = np.mean(images, axis=0)
    thimages.append(averaged)
    img = averaged
    lineprofiles.append(img[:,img.shape[1]//2])
    time.sleep(0.2)

#Plot the line profiles
for i in range(0, len(lineprofiles)-1):
    plt.plot(lineprofiles[i])

plt.xlabel('Pixels')
plt.ylabel('Intensity (arb)')
plt.show()

thimages = []
lineprofiles = []
for i in range(15, 45, 2):
    thnum = float(i)/10
    slm.update_gaussian_to_tophat(thnum, 2)
    for j in range (10):
        images.append(snap())
    averaged = np.mean(images, axis=0)
    thimages.append(averaged)
    img = averaged
    lineprofiles.append(img[:,img.shape[1]//2])
    time.sleep(0.2)

#Plot the line profiles
for i in range(0, len(lineprofiles)-1):
    plt.plot(lineprofiles[i])

plt.xlabel('Pixels')
plt.ylabel('Intensity (arb)')
plt.show()

thimages = []
lineprofiles = []
for i in range(15, 40, 2):
    thnum = float(i)/10
    slm.update_gaussian_to_tophat(thnum, 2)
    for j in range (5):
        images.append(snap())
    averaged = np.mean(images, axis=0)
    thimages.append(averaged)
    img = averaged
    lineprofiles.append(img[:,img.shape[1]//2])
    time.sleep(0.1)

#Plot the line profiles
for i in range(0, len(lineprofiles)-1):
    plt.plot(lineprofiles[i])

plt.xlabel('Pixels')
plt.ylabel('Intensity (arb)')
plt.show()

thimages = []
lineprofiles = []
for i in range(15, 40, 2):
    thnum = float(i)/10
    slm.update_gaussian_to_tophat(thnum, 2)
    images = []
    for j in range (5):
        images.append(snap())
    averaged = np.mean(images, axis=0)
    thimages.append(averaged)
    img = averaged
    lineprofiles.append(img[:,img.shape[1]//2])
    time.sleep(0.1)


#Plot the line profiles
for i in range(0, len(lineprofiles)-1):
    plt.plot(lineprofiles[i])


plt.xlabel('Pixels')
plt.ylabel('Intensity (arb)')
plt.show()
slm.update_gaussian_to_tophat(1.0, 2)
slm.update_gaussian_to_tophat(1.9, 2)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(1.9, 2)

slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)

slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(1.9, 2)

slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
cam.show)gui()
cam.show_gui()
slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(1.9, 2)

slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(1.0, 2)

slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)

slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)

cam.show_gui()
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
 res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)

slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(1.0, 2)

slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
 res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)

 slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(1.9, 2)

 slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(2.5, 2)

slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
 res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)

runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%qt gui
%gui qt
cam.show_gui()
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
slm.zernike_coefficients = np.zeros(12)
res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])

res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)

slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])

res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)

modes = measure_modes(slm, snap, [20,10,2050,1], 5, overlap=0)
flat = modes[12]
f, axes = plt.subplots(3,4)
axes_flat = [axes[i,j] for i in range(3) for j in range(4)]
for m, ax in zip(modes[:12], axes_flat):
    plot_sh_shifts(ax, m, discard_edges=1)


slm_size = 6.9
initial_r = 1.9
N = res.shape[0]
x = (np.arange(N)-(N-1)/2.0)/N * slm_size #centres of apertures
gaussian = np.exp(-x**2/initial_r**2)
gaussian /= np.mean(gaussian)
f, axes = plt.subplots(1,2)
# plot the data and a Gaussian fit
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(x, data[:,i], '+', color=plt.cm.gist_rainbow(float(i)/N))
        m = np.polyfit(gaussian, data[:,i], 1)
        ax.plot(x, gaussian*m[0]+m[1], '-', color=plt.cm.gist_rainbow(float(i)/N))

# plot the data against the Gaussian
f, axes = plt.subplots(1,2)
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(gaussian, data[:,i], '-+', color=plt.cm.gist_rainbow(float(i)/N))


r = np.sqrt(x[:,np.newaxis]**2 + x[np.newaxis,:]**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')
plt.figure()
s=slm_size/2.0
plt.imshow(res[:,:,2],extent=(-s,s,-s,s))
for thresh in [0.0,0.1,0.2,0.5,0.9]:
    I = res[:,:,2].copy()
    I /= np.max(I)
    I -= thresh
    I[I<0] = 0
    cx = np.sum(x[:,np.newaxis]*I)/np.sum(I)
    cy = np.sum(x[np.newaxis,:]*I)/np.sum(I)
    hide = plt.plot(cy,cx,'+')
    print "found centroid at {}, {} with threshold {}".format(cx, cy, thresh)


r = np.sqrt((x[:,np.newaxis]-cx)**2 + (x[np.newaxis,:]-cy)**2)
f, ax = plt.subplots(1,1)
ax.plot(r.flatten(), res[:,:,2].flatten(), '.')
radii = r.flatten()
I = res[:,:,2].flatten()/I.max()*10
from scipy.interpolate import UnivariateSpline
spl = UnivariateSpline(np.concatenate([radii,-radii]), np.tile(I,2))
rr = np.linspace(0,slm_size/np.sqrt(2),100)
plt.plot(rr,spl(rr))
plt.plot(radii,I,'.')
slm.radial_blaze_function = np.ones(384)
inner_edge_i = 1500//18 #bad
sd = 400/18.0
inner_edge_i = 1000//18 #good
sd = 1000/18.0
inner_edge_i = 800//18 #good
sd = 1500/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])

slm.radial_blaze_function = np.ones(384)
inner_edge_i = 1500//18 #bad
sd = 400/18.0
inner_edge_i = 1000//18 #good
sd = 1000/18.0
inner_edge_i = 800//18 #good
sd = 1500/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function
res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)

zernike_coefficients = np.zeros(12)
slm.zernike_coefficients = zernike_coefficients
#slm.make_spots([test_spot + [0,0,0.75,0]])
#slm.make_spots([test_spot])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
#dim_slm(1)
#dim_slm(0.75)
#dim_slm(0.5)
#dim_slm(0.2)
#dim_slm(0.1)
#cam.exposure=-2
def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))

def brightest_g():
    time.sleep(0.1)
    #cam.color_image()
    hdr = snap()
    img = hdr[...,0]
    #img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += hdr[...,1]
        #avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    #cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])

def brightest_hdr():
    hdr = snap()
    for i in range(4):
        hdr += snap()
    hdr /= 5
    return np.max(scipy.ndimage.uniform_filter(hdr, 17))

def brightest_g():
    time.sleep(0.1)
    #cam.color_image()
    hdr = snap()
    img = hdr[...,0]
    #img = cam.color_image()[...,0]
    avg = np.zeros(shape = img.shape, dtype=np.float)
    for i in range(4):
        avg += hdr[...,1]
        #avg += cam.color_image()[...,1]
    avg /= 4
    return np.max(scipy.ndimage.uniform_filter(avg, 17))

def beam_sd():
    #cam.color_image()
    time.sleep(0.1)
    hdr = snap()
    x = np.mean(hdr * np.arange(hdr.shape[0])[:,np.newaxis])/np.mean(hdr)
    y = np.mean(hdr * np.arange(hdr.shape[1])[np.newaxis,:])/np.mean(hdr)
    dx2 = np.mean(hdr * ((np.arange(hdr.shape[0])-x)**2)[:,np.newaxis])/np.mean(hdr)
    dy2 = np.mean(hdr * ((np.arange(hdr.shape[1])-y)**2)[np.newaxis,:])/np.mean(hdr)
    sd = np.sqrt(dx2+dy2)
    return 1/sd

def average_fn(f, n):
    return lambda: np.mean([f() for i in range(n)])

merit_function = lambda: np.mean([beam_sd() for i in range(3)])

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.5, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.1, modes=[1])
zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=0.3, modes=[0,1,2])
for dz in [0.5,0.35,0.3,0.2,0.15,0.1,0.07,0.05,0.01]:
    print "step size: {}".format(dz)
    zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, beam_sd, dz=dz)

zernike_coefficients = optimise_aberration_correction(slm, cam, zernike_coefficients, average_fn(beam_sd,3), dz=0.1)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.5)
zernike_coefficients = optimise_aberration_correction(slm, 
                                cam, zernike_coefficients, merit_function, 
                                dz=0.1)
nplab.current_datafile().create_dataset("spot_image_%d",data=cam.color_image(),attrs={"zernike_coefficients":zernike_coefficients})
res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)

slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])

res = sequential_shack_hartmann(slm, snap, test_spot[:4], 30, overlap=0.5)
plot_shack_hartmann(res)

 slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(2.5, 2)

 slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(1.9, 2)

 slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(3, 2)

 slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(1.0, 2)

inner_edge_i = 800//18 #good
sd = 1500/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?
images = []
for i in range (10):
    images.append(snap())
    
averaged = np.mean(images, axis=2)
plt.imshow(averaged)

inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?
slm.make_spots([test_spot[:4] + [0,0,0.07,0]])
sd = 1500/18.0
slm.make_spots([test_spot[:4] + [0,0,0.07,0]])
slm.update_gaussian_to_tophat(1900,1, distance=distance)
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.update_gaussian_to_tophat(1.9, 1)
slm.update_gaussian_to_tophat(1.9, 2)
slm.update_gaussian_to_tophat(1.5, 2)
slm.update_gaussian_to_tophat(2.5, 2)
img = snap()
plt.plot(img[:,img.shape[1]//2,:])
plt.plot(img[:,img.shape[1]//2])
slm.radial_blaze_function = np.ones(384)
img = snap()
plt.plot(img[:,img.shape[1]//2])
inner_edge_i = 800//18 #good
sd = 1500/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?

slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.update_gaussian_to_tophat(1.9, 1)
slm.update_gaussian_to_tophat(1.9, 2)
slm.update_gaussian_to_tophat(1.5, 2)
slm.update_gaussian_to_tophat(2.5, 2)
img = snap()
plt.plot(img[:,img.shape[1]//2,:])
plt.plot(img[:,img.shape[1]//2])
slm.radial_blaze_function = np.ones(384)
img = snap()
plt.plot(img[:,img.shape[1]//2])
inner_edge_i = 800//18 #good
sd = 1500/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?

inner_edge_i = 800//18 #good
sd = 1500/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?
images = []
for i in range (10):
    images.append(snap())

averaged = np.mean(images, axis=2)

inner_edge_i = 1000//18 #good
sd = 1000/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?
slm.make_spots([test_spot[:4] + [0,0,0.07,0]])
sd = 1500/18.0
slm.make_spots([test_spot[:4] + [0,0,0.07,0]])
slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.update_gaussian_to_tophat(1.9, 1)
slm.update_gaussian_to_tophat(1.9, 2)
slm.update_gaussian_to_tophat(1.5, 2)
slm.update_gaussian_to_tophat(2.5, 2)
img = snap()
plt.plot(img[:,img.shape[1]//2,:])
plt.plot(img[:,img.shape[1]//2])
slm.radial_blaze_function = np.ones(384)
img = snap()
plt.plot(img[:,img.shape[1]//2])
inner_edge_i = 800//18 #good
sd = 1500/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?

slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.update_gaussian_to_tophat(1.9, 1)
slm.update_gaussian_to_tophat(1.9, 2)
slm.update_gaussian_to_tophat(1.5, 2)
slm.update_gaussian_to_tophat(2.5, 2)
img = snap()
plt.plot(img[:,img.shape[1]//2,:])
plt.plot(img[:,img.shape[1]//2])
slm.radial_blaze_function = np.ones(384)
img = snap()
plt.plot(img[:,img.shape[1]//2])
inner_edge_i = 800//18 #good
sd = 1500/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?

inner_edge_i = 800//18 #good
sd = 1500/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?
images = []
for i in range (10):
    images.append(snap())

averaged = np.mean(images, axis=2)

cx
cy
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%qt gui
%gui qt
cam.show_gui()
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.radial_blaze_function = np.ones(384)
inner_edge_i = 1500//18 #bad
sd = 400/18.0
inner_edge_i = 1000//18 #good
sd = 1000/18.0
inner_edge_i = 800//18 #good
sd = 1500/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function 
inner_edge_i = 800//18 #good
sd = 1500/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?
images = []
for i in range (10):
    images.append(snap())

averaged = np.mean(images, axis=2)

averaged = np.mean(images, axis=0)
plt.imshow(averaged)
slm.make_spots([test_spot[:4] + [0,0,1,0]])
 slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(1.0, 2)

slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])

res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)

 slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(1.0, 2)

 slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(2.5, 2)

thimages = []
lineprofiles = []
for i in range(15, 40, 2):
    thnum = float(i)/10
    slm.update_gaussian_to_tophat(thnum, 2)
    images = []
    for j in range (5):
        images.append(snap())
    averaged = np.mean(images, axis=0)
    thimages.append(averaged)
    img = averaged
    lineprofiles.append(img[:,img.shape[1]//2])
    time.sleep(0.1)


#Plot the line profiles
for i in range(0, len(lineprofiles)-1):
    plt.plot(lineprofiles[i])


plt.xlabel('Pixels')
plt.ylabel('Intensity (arb)')
plt.show()
thimages = []
lineprofiles = []
for i in range(15, 30, 2):
    thnum = float(i)/10
    slm.update_gaussian_to_tophat(thnum, 2)
    images = []
    for j in range (5):
        images.append(snap())
    averaged = np.mean(images, axis=0)
    thimages.append(averaged)
    img = averaged
    lineprofiles.append(img[:,img.shape[1]//2])
    time.sleep(0.1)


#Plot the line profiles
for i in range(0, len(lineprofiles)-1):
    plt.plot(lineprofiles[i])


plt.xlabel('Pixels')
plt.ylabel('Intensity (arb)')
plt.show()

thimages = []

lineprofiles = []
for i in range(15, 30, 2):
    thnum = float(i)/10
    slm.update_gaussian_to_tophat(thnum, 2)
    images = []
    for j in range (5):
        images.append(snap())
    averaged = np.mean(images, axis=0)
    thimages.append(averaged)
    img = averaged
    lineprofiles.append(img[:,img.shape[1]//2])
    time.sleep(0.1)


#Plot the line profiles
for i in range(0, len(lineprofiles)-1):
    plt.plot(lineprofiles[i])


plt.xlabel('Pixels')
plt.ylabel('Intensity (arb)')
plt.show()

thimages = []

lineprofiles = []
for i in range(14, 25, 1):
    thnum = float(i)/10
    slm.update_gaussian_to_tophat(thnum, 2)
    images = []
    for j in range (5):
        images.append(snap())
    averaged = np.mean(images, axis=0)
    thimages.append(averaged)
    img = averaged
    lineprofiles.append(img[:,img.shape[1]//2])
    time.sleep(0.1)


#Plot the line profiles
for i in range(0, len(lineprofiles)-1):
    plt.plot(lineprofiles[i])


plt.xlabel('Pixels')
plt.ylabel('Intensity (arb)')
plt.show()

thimages = []

lineprofiles = []
for i in range(14, 23, 1):
    thnum = float(i)/10
    slm.update_gaussian_to_tophat(thnum, 2)
    images = []
    for j in range (5):
        images.append(snap())
    averaged = np.mean(images, axis=0)
    thimages.append(averaged)
    img = averaged
    lineprofiles.append(img[:,img.shape[1]//2])
    time.sleep(0.1)


#Plot the line profiles
for i in range(0, len(lineprofiles)-1):
    plt.plot(lineprofiles[i])


plt.xlabel('Pixels')
plt.ylabel('Intensity (arb)')
plt.show()

thimages = []

lineprofiles = []
for i in range(14, 20, 1):
    thnum = float(i)/10
    slm.update_gaussian_to_tophat(thnum, 2)
    images = []
    for j in range (5):
        images.append(snap())
    averaged = np.mean(images, axis=0)
    thimages.append(averaged)
    img = averaged
    lineprofiles.append(img[:,img.shape[1]//2])
    time.sleep(0.1)


#Plot the line profiles
for i in range(0, len(lineprofiles)-1):
    plt.plot(lineprofiles[i])


plt.xlabel('Pixels')
plt.ylabel('Intensity (arb)')
plt.show()

 slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(1.6, 2)

 slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(1.9, 2)

 slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(2.6, 2)

 slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(2.7, 2)

thimages = []
lineprofiles = []
for i in range(15, 30, 2):
    thnum = float(i)/10
    slm.update_gaussian_to_tophat(thnum, 2)
    images = []
    for j in range (5):
        images.append(snap())
    averaged = np.mean(images, axis=0)
    thimages.append(averaged)
    img = averaged
    lineprofiles.append(img[img.shape[0]//2,:])
    time.sleep(0.1)


#Plot the line profiles
for i in range(0, len(lineprofiles)-1):
    plt.plot(lineprofiles[i])


plt.xlabel('Pixels')
plt.ylabel('Intensity (arb)')
plt.show()

sd = 1500/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?
inner_edge_i = 1000//18 #good
sd = 1000/18.0
inner_edge_i = 800//18 #good
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?
thimages = []
lineprofiles = []
for i in range(15, 30, 2):
    thnum = float(i)/10
    slm.update_gaussian_to_tophat(thnum, 2)
    images = []
    for j in range (5):
        images.append(snap())
    averaged = np.mean(images, axis=0)
    thimages.append(averaged)
    img = averaged
    lineprofiles.append(img[img.shape[0]//2,:])
    time.sleep(0.1)


#Plot the line profiles
for i in range(0, len(lineprofiles)-1):
    plt.plot(lineprofiles[i])


plt.xlabel('Pixels')
plt.ylabel('Intensity (arb)')
plt.show()

thimages = []
lineprofiles = []
for i in range(13, 25, 1):
    thnum = float(i)/10
    slm.update_gaussian_to_tophat(thnum, 2)
    images = []
    for j in range (5):
        images.append(snap())
    averaged = np.mean(images, axis=0)
    thimages.append(averaged)
    img = averaged
    lineprofiles.append(img[img.shape[0]//2,:])
    time.sleep(0.1)


#Plot the line profiles
for i in range(0, len(lineprofiles)-1):
    plt.plot(lineprofiles[i])


plt.xlabel('Pixels')
plt.ylabel('Intensity (arb)')
plt.show()

thimages = []
lineprofiles = []
for i in range(13, 20, 1):
    thnum = float(i)/10
    slm.update_gaussian_to_tophat(thnum, 2)
    images = []
    for j in range (5):
        images.append(snap())
    averaged = np.mean(images, axis=0)
    thimages.append(averaged)
    img = averaged
    lineprofiles.append(img[img.shape[0]//2,:])
    time.sleep(0.1)


#Plot the line profiles
for i in range(0, len(lineprofiles)-1):
    plt.plot(lineprofiles[i])


plt.xlabel('Pixels')
plt.ylabel('Intensity (arb)')
plt.show()

inner_edge_i = 800//18 #good
sd = 1400/18.0
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function #radial blaze function moves spot - change in centre?
thimages = []
lineprofiles = []
for i in range(13, 20, 1):
    thnum = float(i)/10
    slm.update_gaussian_to_tophat(thnum, 2)
    images = []
    for j in range (5):
        images.append(snap())
    averaged = np.mean(images, axis=0)
    thimages.append(averaged)
    img = averaged
    lineprofiles.append(img[img.shape[0]//2,:])
    time.sleep(0.1)


#Plot the line profiles
for i in range(0, len(lineprofiles)-1):
    plt.plot(lineprofiles[i])


plt.xlabel('Pixels')
plt.ylabel('Intensity (arb)')
plt.show()

plt.plot(lineprofiles[1])
thimages = []
lineprofiles = []
for i in range(1000, 2000, 500):
    inner_edge_i = 800//18 #good
    sdtest = i/18.0
    sd = sdtest
    nrest = 384 - inner_edge_i
    radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function
    slm.update_gaussian_to_tophat(1.9, 2)
    images = []
    for j in range (5):
        images.append(snap())
    averaged = np.mean(images, axis=0)
    thimages.append(averaged)
    img = averaged
    lineprofiles.append(img[img.shape[0]//2,:])
    time.sleep(0.1)


#Plot the line profiles
for i in range(0, len(lineprofiles)-1):
    plt.plot(lineprofiles[i])


plt.xlabel('Pixels')
plt.ylabel('Intensity (arb)')
plt.show()
thimages = []
lineprofiles = []
for i in range(1000, 2000, 500):
    inner_edge_i = 800//18 #good
    sdtest = i/18.0
    sd = sdtest
    nrest = 384 - inner_edge_i
    radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
    slm.radial_blaze_function = radial_blaze_function
    slm.update_gaussian_to_tophat(1.9, 2)
    images = []
    for j in range (5):
        images.append(snap())
    averaged = np.mean(images, axis=0)
    thimages.append(averaged)
    img = averaged
    lineprofiles.append(img[img.shape[0]//2,:])
    time.sleep(0.1)


#Plot the line profiles
for i in range(0, len(lineprofiles)-1):
    plt.plot(lineprofiles[i])


plt.xlabel('Pixels')
plt.ylabel('Intensity (arb)')
plt.show()

thimages = []
lineprofiles = []
for i in range(1000, 2000, 500):
    inner_edge_i = 800//18 #good
    sdtest = i/18.0
    sd = sdtest
    nrest = 384 - inner_edge_i
    radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
    slm.radial_blaze_function = radial_blaze_function
    slm.update_gaussian_to_tophat(1.5, 2)
    images = []
    for j in range (5):
        images.append(snap())
    averaged = np.mean(images, axis=0)
    thimages.append(averaged)
    img = averaged
    lineprofiles.append(img[img.shape[0]//2,:])
    time.sleep(0.1)


#Plot the line profiles
for i in range(0, len(lineprofiles)-1):
    plt.plot(lineprofiles[i])


plt.xlabel('Pixels')
plt.ylabel('Intensity (arb)')
plt.show()

thimages = []
lineprofiles = []
for i in range(1000, 2000, 500):
    inner_edge_i = 800//18 #good
    sdtest = i/18.0
    sd = sdtest
    nrest = 384 - inner_edge_i
    print sd
    radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
    slm.radial_blaze_function = radial_blaze_function
    slm.update_gaussian_to_tophat(1.9, 2)
    images = []
    for j in range (5):
        images.append(snap())
    averaged = np.mean(images, axis=0)
    thimages.append(averaged)
    img = averaged
    lineprofiles.append(img[img.shape[0]//2,:])
    time.sleep(0.1)


#Plot the line profiles
for i in range(0, len(lineprofiles)-1):
    plt.plot(lineprofiles[i])


plt.xlabel('Pixels')
plt.ylabel('Intensity (arb)')
plt.show()

thimages = []
lineprofiles = []
for i in range(1000, 2000, 100):
    inner_edge_i = 800//18 #good
    sdtest = i/18.0
    sd = sdtest
    nrest = 384 - inner_edge_i
    print sd
    radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
    slm.radial_blaze_function = radial_blaze_function
    slm.update_gaussian_to_tophat(1.9, 2)
    images = []
    for j in range (5):
        images.append(snap())
    averaged = np.mean(images, axis=0)
    thimages.append(averaged)
    img = averaged
    lineprofiles.append(img[img.shape[0]//2,:])
    time.sleep(0.1)


#Plot the line profiles
for i in range(0, len(lineprofiles)-1):
    plt.plot(lineprofiles[i])


plt.xlabel('Pixels')
plt.ylabel('Intensity (arb)')
plt.show()

thimages = []
lineprofiles = []
for i in range(1000, 2000, 100):
    inner_edge_i = 800//18 #good
    sdtest = i/18.0
    sd = sdtest
    nrest = 384 - inner_edge_i
    print sd
    radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
    slm.radial_blaze_function = radial_blaze_function
    slm.update_gaussian_to_tophat(2.5, 2)
    images = []
    for j in range (5):
        images.append(snap())
    averaged = np.mean(images, axis=0)
    thimages.append(averaged)
    img = averaged
    lineprofiles.append(img[img.shape[0]//2,:])
    time.sleep(0.1)


#Plot the line profiles
for i in range(0, len(lineprofiles)-1):
    plt.plot(lineprofiles[i])


plt.xlabel('Pixels')
plt.ylabel('Intensity (arb)')
plt.show()


## ---(Tue Jan 08 12:01:02 2019)---
runfile('C:/local/dev/slm_interference_lithography/beam_profiling.py', wdir='C:/local/dev/slm_interference_lithography')
%gq gui
%qt gui
%gui qt
cam.show_gui()
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)
res = sequential_shack_hartmann(slm, snap, test_spot[:4], 20, overlap=0.5)
plot_shack_hartmann(res)

slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
thnum = 1
plt.title(thnum)
for k in range(15, 19, 2):
    thnum = float(i)/10
    
    thimages = []
    lineprofiles = []
    for i in range(1000, 2000, 100):
        inner_edge_i = 800//18 #good
        sdtest = i/18.0
        sd = sdtest
        nrest = 384 - inner_edge_i
        radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
        slm.radial_blaze_function = radial_blaze_function
        slm.update_gaussian_to_tophat(thnum, 2)
        images = []
        for j in range (5):
            images.append(snap())
        averaged = np.mean(images, axis=0)
        thimages.append(averaged)
        img = averaged
        lineprofiles.append(img[img.shape[0]//2,:])
        time.sleep(0.1)
    
    
    #Plot the line profiles
    for i in range(0, len(lineprofiles)-1):
        plt.plot(lineprofiles[i])
    
    plt.title(thnum)
    plt.xlabel('Pixels')
    plt.ylabel('Intensity (arb)')
    plt.show()


for k in range(15, 19, 2):
    thnum = float(k)/10
    
    thimages = []
    lineprofiles = []
    for i in range(1000, 2000, 100):
        inner_edge_i = 800//18 #good
        sdtest = i/18.0
        sd = sdtest
        nrest = 384 - inner_edge_i
        radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
        slm.radial_blaze_function = radial_blaze_function
        slm.update_gaussian_to_tophat(thnum, 2)
        images = []
        for j in range (5):
            images.append(snap())
        averaged = np.mean(images, axis=0)
        thimages.append(averaged)
        img = averaged
        lineprofiles.append(img[img.shape[0]//2,:])
        time.sleep(0.1)
    
    
    #Plot the line profiles
    for i in range(0, len(lineprofiles)-1):
        plt.plot(lineprofiles[i])
    
    plt.title(thnum)
    plt.xlabel('Pixels')
    plt.ylabel('Intensity (arb)')
    plt.show()


for k in range(10, 30, 2):
    thnum = float(k)/10
    
    thimages = []
    lineprofiles = []
    for i in range(500, 2500, 100):
        inner_edge_i = 800//18 #good
        sdtest = i/18.0
        sd = sdtest
        nrest = 384 - inner_edge_i
        radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
        slm.radial_blaze_function = radial_blaze_function
        slm.update_gaussian_to_tophat(thnum, 2)
        images = []
        for j in range (5):
            images.append(snap())
        averaged = np.mean(images, axis=0)
        thimages.append(averaged)
        img = averaged
        lineprofiles.append(img[img.shape[0]//2,:])
    
    
    #Plot the line profiles
    for i in range(0, len(lineprofiles)-1):
        plt.plot(lineprofiles[i])
    
    plt.title(thnum)
    plt.xlabel('Pixels')
    plt.ylabel('Intensity (arb)')
    plt.show()


for k in range(15, 30, 2):
    thnum = float(k)/10
    
    thimages = []
    lineprofiles = []
    for i in range(500, 2500, 100):
        inner_edge_i = 800//18 #good
        sdtest = i/18.0
        sd = sdtest
        nrest = 384 - inner_edge_i
        radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
        slm.radial_blaze_function = radial_blaze_function
        slm.update_gaussian_to_tophat(thnum, 2)
        images = []
        for j in range (5):
            images.append(snap())
        averaged = np.mean(images, axis=0)
        thimages.append(averaged)
        img = averaged
        lineprofiles.append(img[img.shape[0]//2,:])
    
    
    #Plot the line profiles
    for i in range(0, len(lineprofiles)-1):
        plt.plot(lineprofiles[i])
    
    plt.title(thnum)
    plt.xlabel('Pixels')
    plt.ylabel('Intensity (arb)')
    plt.show()


slm.update_gaussian_to_tophat(thnum, 2)
slm.make_spots([test_spot[:4] + [0,0,0.2,0]])
 slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(2.7, 2)

for k in range(15, 30, 2):
    thnum = float(k)/10
    
    thimages = []
    lineprofiles = []
    for i in range(500, 2500, 100):
        inner_edge_i = 800//18 #good
        sdtest = i/18.0
        sd = sdtest
        nrest = 384 - inner_edge_i
        radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
        slm.radial_blaze_function = radial_blaze_function
        slm.make_spots([test_spot[:4] + [0,0,1,0]])
        slm.update_gaussian_to_tophat(thnum, 2)
        images = []
        for j in range (5):
            images.append(snap())
        averaged = np.mean(images, axis=0)
        thimages.append(averaged)
        img = averaged
        lineprofiles.append(img[img.shape[0]//2,:])
    
    
    #Plot the line profiles
    for i in range(0, len(lineprofiles)-1):
        plt.plot(lineprofiles[i])
    
    plt.title(thnum)
    plt.xlabel('Pixels')
    plt.ylabel('Intensity (arb)')
    plt.show()


for k in range(10, 28, 1):
    thnum = float(k)/10
    
    thimages = []
    lineprofiles = []
    for i in range(500, 2500, 100):
        inner_edge_i = 800//18 #good
        sdtest = i/18.0
        sd = sdtest
        nrest = 384 - inner_edge_i
        radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
        slm.radial_blaze_function = radial_blaze_function
        slm.make_spots([test_spot[:4] + [0,0,1,0]])
        slm.update_gaussian_to_tophat(thnum, 2)
        images = []
        for j in range (5):
            images.append(snap())
        averaged = np.mean(images, axis=0)
        thimages.append(averaged)
        img = averaged
        lineprofiles.append(img[img.shape[0]//2,:])
    
    
    #Plot the line profiles
    for i in range(0, len(lineprofiles)-1):
        plt.plot(lineprofiles[i])
    
    plt.title(thnum)
    plt.xlabel('Pixels')
    plt.ylabel('Intensity (arb)')
    plt.show()


find_peaks(lineprofiles[2], prominence=1, width=20)
from scipy.signal import find_peaks
from scipy.signal import find peaks
from scipy.signal import find_peaks
from scipy.signal import findpeaks
from admit.util.peakfinder.PeakDetect import PeakDetect
for k in range(10, 30, 1):
    thnum = float(k)/10
    
    thimages = []
    lineprofiles = []
    for i in range(800, 2000, 100):
        inner_edge_i = 800//18 #good
        sdtest = i/18.0
        sd = sdtest
        nrest = 384 - inner_edge_i
        radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
        slm.radial_blaze_function = radial_blaze_function
        slm.make_spots([test_spot[:4] + [0,0,1,0]])
        slm.update_gaussian_to_tophat(thnum, 2)
        images = []
        for j in range (5):
            images.append(snap())
        averaged = np.mean(images, axis=0)
        thimages.append(averaged)
        img = averaged
        lineprofiles.append(img[img.shape[0]//2,:])
    
    
    #Plot the line profiles
    for i in range(0, len(lineprofiles)-1):
        plt.plot(lineprofiles[i])
    
    plt.title(thnum)
    plt.xlabel('Pixels')
    plt.ylabel('Intensity (arb)')
    plt.show()


for k in range(15, 30, 1):
    thnum = float(k)/10
    
    thimages = []
    lineprofiles = []
    for i in range(700, 2000, 100):
        inner_edge_i = 800//18 #good
        sdtest = i/18.0
        sd = sdtest
        nrest = 384 - inner_edge_i
        radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
        slm.radial_blaze_function = radial_blaze_function
        slm.make_spots([test_spot[:4] + [0,0,1,0]])
        slm.update_gaussian_to_tophat(thnum, 2)
        images = []
        for j in range (5):
            images.append(snap())
        averaged = np.mean(images, axis=0)
        thimages.append(averaged)
        img = averaged
        lineprofiles.append(img[img.shape[0]//2,:])
    
    
    #Plot the line profiles
    for i in range(0, len(lineprofiles)-1):
        plt.plot(lineprofiles[i])
    
    plt.title(thnum)
    plt.xlabel('Pixels')
    plt.ylabel('Intensity (arb)')
    plt.show()


for k in range(20, 30, 1):
    thnum = float(k)/10
    
    thimages = []
    lineprofiles = []
    for i in range(1000, 2500, 100):
        inner_edge_i = 800//18 #good
        sdtest = i/18.0
        sd = sdtest
        nrest = 384 - inner_edge_i
        radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
        slm.radial_blaze_function = radial_blaze_function
        slm.make_spots([test_spot[:4] + [0,0,1,0]])
        slm.update_gaussian_to_tophat(thnum, 2)
        images = []
        for j in range (5):
            images.append(snap())
        averaged = np.mean(images, axis=0)
        thimages.append(averaged)
        img = averaged
        lineprofiles.append(img[img.shape[0]//2,:])
    
    
    #Plot the line profiles
    for i in range(0, len(lineprofiles)-1):
        plt.plot(lineprofiles[i])
    
    plt.title(thnum)
    plt.xlabel('Pixels')
    plt.ylabel('Intensity (arb)')
    plt.show()


for k in range(23, 27, 1):
    thnum = float(k)/10
    
    thimages = []
    lineprofiles = []
    for i in range(500, 3000, 100):
        inner_edge_i = 800//18 #good
        sdtest = i/18.0
        sd = sdtest
        nrest = 384 - inner_edge_i
        radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
        slm.radial_blaze_function = radial_blaze_function
        slm.make_spots([test_spot[:4] + [0,0,1,0]])
        slm.update_gaussian_to_tophat(thnum, 2)
        images = []
        for j in range (5):
            images.append(snap())
        averaged = np.mean(images, axis=0)
        thimages.append(averaged)
        img = averaged
        lineprofiles.append(img[img.shape[0]//2,:])
    
    
    #Plot the line profiles
    for i in range(0, len(lineprofiles)-1):
        plt.plot(lineprofiles[i])
    
    plt.title(thnum)
    plt.xlabel('Pixels')
    plt.ylabel('Intensity (arb)')
    plt.show()


for k in range(23, 27, 1):
    thnum = float(k)/10
    
    thimages = []
    lineprofiles = []
    for i in range(800, 3000, 100):
        inner_edge_i = 800//18 #good
        sdtest = i/18.0
        sd = sdtest
        nrest = 384 - inner_edge_i
        radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
        slm.radial_blaze_function = radial_blaze_function
        slm.make_spots([test_spot[:4] + [0,0,1,0]])
        slm.update_gaussian_to_tophat(thnum, 2)
        images = []
        for j in range (5):
            images.append(snap())
        averaged = np.mean(images, axis=0)
        thimages.append(averaged)
        img = averaged
        lineprofiles.append(img[img.shape[0]//2,:])
    
    
    #Plot the line profiles
    for i in range(0, len(lineprofiles)-1):
        plt.plot(lineprofiles[i])
    
    plt.title(thnum)
    plt.xlabel('Pixels')
    plt.ylabel('Intensity (arb)')
    plt.show()


for k in range(23, 27, 1):
    thnum = float(k)/10
    
    thimages = []
    lineprofiles = []
    for i in range(1200, 3000, 100):
        inner_edge_i = 800//18 #good
        sdtest = i/18.0
        sd = sdtest
        nrest = 384 - inner_edge_i
        radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
        slm.radial_blaze_function = radial_blaze_function
        slm.make_spots([test_spot[:4] + [0,0,1,0]])
        slm.update_gaussian_to_tophat(thnum, 2)
        images = []
        for j in range (5):
            images.append(snap())
        averaged = np.mean(images, axis=0)
        thimages.append(averaged)
        img = averaged
        lineprofiles.append(img[img.shape[0]//2,:])
    
    
    #Plot the line profiles
    for i in range(0, len(lineprofiles)-1):
        plt.plot(lineprofiles[i])
    
    plt.title(thnum)
    plt.xlabel('Pixels')
    plt.ylabel('Intensity (arb)')
    plt.show()


for k in range(23, 27, 1):
    thnum = float(k)/10
    
    thimages = []
    lineprofiles = []
    for i in range(1500, 2000, 100):
        inner_edge_i = 800//18 #good
        sdtest = i/18.0
        sd = sdtest
        nrest = 384 - inner_edge_i
        radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
        slm.radial_blaze_function = radial_blaze_function
        slm.make_spots([test_spot[:4] + [0,0,1,0]])
        slm.update_gaussian_to_tophat(thnum, 2)
        images = []
        for j in range (5):
            images.append(snap())
        averaged = np.mean(images, axis=0)
        thimages.append(averaged)
        img = averaged
        lineprofiles.append(img[img.shape[0]//2,:])
    
    
    #Plot the line profiles
    for i in range(0, len(lineprofiles)-1):
        plt.plot(lineprofiles[i])
    
    plt.title(thnum)
    plt.xlabel('Pixels')
    plt.ylabel('Intensity (arb)')
    plt.show()


for k in range(23, 27, 1):
    thnum = float(k)/10
    
    thimages = []
    lineprofiles = []
    for i in range(1700, 2000, 100):
        inner_edge_i = 800//18 #good
        sdtest = i/18.0
        sd = sdtest
        nrest = 384 - inner_edge_i
        radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
        slm.radial_blaze_function = radial_blaze_function
        slm.make_spots([test_spot[:4] + [0,0,1,0]])
        slm.update_gaussian_to_tophat(thnum, 2)
        images = []
        for j in range (5):
            images.append(snap())
        averaged = np.mean(images, axis=0)
        thimages.append(averaged)
        img = averaged
        lineprofiles.append(img[img.shape[0]//2,:])
        plt.title(thnum)
        print(i)
        plt.xlabel('Pixels')
        plt.ylabel('Intensity (arb)')
        plt.show()


plt.plot(img)
plt.imshow(img)
plt.title(thnum)
print(i)
plt.imshow(img)
plt.show()
for k in range(23, 27, 1):
    thnum = float(k)/10
    
    thimages = []
    lineprofiles = []
    for i in range(1700, 2000, 100):
        inner_edge_i = 800//18 #good
        sdtest = i/18.0
        sd = sdtest
        nrest = 384 - inner_edge_i
        radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
        slm.radial_blaze_function = radial_blaze_function
        slm.make_spots([test_spot[:4] + [0,0,1,0]])
        slm.update_gaussian_to_tophat(thnum, 2)
        images = []
        for j in range (5):
            images.append(snap())
        averaged = np.mean(images, axis=0)
        thimages.append(averaged)
        img = averaged
        lineprofiles.append(img[img.shape[0]//2,:])
        plt.title(thnum)
        print(i)
        plt.imshow(img)
        plt.show()


for k in range(15, 26, 1):
    thnum = float(k)/10
    
    thimages = []
    lineprofiles = []
    for i in range(500, 3000, 200):
        inner_edge_i = 800//18 #good
        sdtest = i/18.0
        sd = sdtest
        nrest = 384 - inner_edge_i
        radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
        slm.radial_blaze_function = radial_blaze_function
        slm.make_spots([test_spot[:4] + [0,0,1,0]])
        slm.update_gaussian_to_tophat(thnum, 2)
        images = []
        for j in range (5):
            images.append(snap())
        averaged = np.mean(images, axis=0)
        thimages.append(averaged)
        img = averaged
        lineprofiles.append(img[img.shape[0]//2,:])
        plt.title(thnum)
        print(i)
        plt.imshow(img)
        plt.show()


for k in range(19, 25, 1):
    thnum = float(k)/10
    
    thimages = []
    lineprofiles = []
    for i in range(900, 3000, 200):
        inner_edge_i = 800//18 #good
        sdtest = i/18.0
        sd = sdtest
        nrest = 384 - inner_edge_i
        radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
        slm.radial_blaze_function = radial_blaze_function
        slm.make_spots([test_spot[:4] + [0,0,1,0]])
        slm.update_gaussian_to_tophat(thnum, 2)
        images = []
        for j in range (5):
            images.append(snap())
        averaged = np.mean(images, axis=0)
        thimages.append(averaged)
        img = averaged
        plt.title(thnum)
        plt.plot(img[img.shape[0]//2,:])
        print(i)
        plt.imshow(img)
        plt.show()


for k in range(19, 27, 1):
    thnum = float(k)/10
    
    thimages = []
    lineprofiles = []
    for i in range(1000, 3000, 200):
        inner_edge_i = 800//18 #good
        sdtest = i/18.0
        sd = sdtest
        nrest = 384 - inner_edge_i
        radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
        slm.radial_blaze_function = radial_blaze_function
        slm.make_spots([test_spot[:4] + [0,0,1,0]])
        slm.update_gaussian_to_tophat(thnum, 2)
        images = []
        for j in range (5):
            images.append(snap())
        averaged = np.mean(images, axis=0)
        thimages.append(averaged)
        img = averaged
        plt.title(thnum)
        plt.plot(img[img.shape[0]//2,:])
        print(i)
        plt.imshow(img)
        plt.show()


inner_edge_i = 800//18 #good
sdtest = 2000/18.0
sd = sdtest
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function
slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(2.5, 2)
focus_stack(50,5, snap=snap) #focus_stack threw errors with zc.copy(), changed
img = snap()
imgsize = np.shape(img)
width = int(imgsize[0])/10

xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
#rs = np.linspace(-5,5,xsection.shape[0])
rs = np.linspace(-50,50,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    #plt.imshow(img)
    #raw_input('Press <ENTER> to continue')
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))
slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(2.5, 2)
slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(2.5, 1)

slm.zernike_coefficients = np.zeros(12)
slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(2.5, 2)
slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(2.5, 1)

slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(1.0, 2)

slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)
slm.update_gaussian_to_tophat(1.9, 0.0001)
slm.make_spots([test_spot[:4] + [0,0,0.075,0]])
res = sequential_shack_hartmann(slm, snap, test_spot[:4], 10, overlap=0.5)
plot_shack_hartmann(res)
slm_size = 6.9
initial_r = 1.9
N = res.shape[0]
x = (np.arange(N)-(N-1)/2.0)/N * slm_size #centres of apertures
gaussian = np.exp(-x**2/initial_r**2)
gaussian /= np.mean(gaussian)
f, axes = plt.subplots(1,2)
# plot the data and a Gaussian fit
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(x, data[:,i], '+', color=plt.cm.gist_rainbow(float(i)/N))
        m = np.polyfit(gaussian, data[:,i], 1)
        ax.plot(x, gaussian*m[0]+m[1], '-', color=plt.cm.gist_rainbow(float(i)/N))

# plot the data against the Gaussian
f, axes = plt.subplots(1,2)
for data, ax in zip([res[:,:,2], res[:,:,2].T], axes):
    for i in range(N):
        ax.plot(gaussian, data[:,i], '-+', color=plt.cm.gist_rainbow(float(i)/N))


plt.figure()
s=slm_size/2.0
plt.imshow(res[:,:,2],extent=(-s,s,-s,s))
for thresh in [0.0,0.1,0.2,0.5,0.9]:
    I = res[:,:,2].copy()
    I /= np.max(I)
    I -= thresh
    I[I<0] = 0
    cx = np.sum(x[:,np.newaxis]*I)/np.sum(I)
    cy = np.sum(x[np.newaxis,:]*I)/np.sum(I)
    hide = plt.plot(cy,cx,'+')
    print "found centroid at {}, {} with threshold {}".format(cx, cy, thresh)


inner_edge_i = 800//18 #good
sdtest = 2000/18.0
sd = sdtest
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function
slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(2.5, 2)
img = snap()
imgsize = np.shape(img)
width = int(imgsize[0])/10

xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
#rs = np.linspace(-5,5,xsection.shape[0])
rs = np.linspace(-50,50,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    #plt.imshow(img)
    #raw_input('Press <ENTER> to continue')
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))
inner_edge_i = 800//18 #good
sdtest = 2000/18.0
sd = sdtest
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function
slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(2.6, 2)
img = snap()
imgsize = np.shape(img)
width = int(imgsize[0])/10

xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
#rs = np.linspace(-5,5,xsection.shape[0])
rs = np.linspace(-50,50,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    #plt.imshow(img)
    #raw_input('Press <ENTER> to continue')
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))
inner_edge_i = 800//18 #good
sdtest = 2000/18.0
sd = sdtest
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function
slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(1.9, 2)
slm.zernike_coefficients = np.zeros(12)
img = snap()
imgsize = np.shape(img)
width = int(imgsize[0])/10

xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
#rs = np.linspace(-5,5,xsection.shape[0])
rs = np.linspace(-50,50,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    #plt.imshow(img)
    #raw_input('Press <ENTER> to continue')
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))

slm.zernike_coefficients = np.zeros(12)
slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(1.9, 1)
focus_stack(50,5, snap=snap)
xsection = np.zeros((width,int(imgsize[1])),dtype=np.uint8)
ysection = np.zeros((xsection.shape[0],int(imgsize[0])),dtype=np.uint8)
#rs = np.linspace(-5,5,xsection.shape[0])
rs = np.linspace(-50,50,xsection.shape[0])
for i, r in enumerate(rs):
    slm.zernike_coefficients = [-1.3,0.8,r,0,0,0,0,0,0,0,0,0,]
    time.sleep(0.1)
    #img = cam.color_image()
    img = snap()
    #plt.imshow(img)
    #raw_input('Press <ENTER> to continue')
    imgsize = np.shape(img)
    width = int(imgsize[0])/10
    ximgcentre = int(imgsize[0])/2
    yimgcentre = int(imgsize[1])/2
    xsection[i,:] = np.mean(img[(ximgcentre-width):(ximgcentre+width),:], axis=0)
    #previously 230 and 250
    #ysection[i,:,:] = np.mean(img[:,310:330,:], axis=1)
    ysection[i,:] = np.mean(img[:,(yimgcentre-width):(yimgcentre+width)], axis=1)

f, axes = plt.subplots(1,2)
axes[0].imshow(xsection,aspect='auto',extent = (0,640,rs.max(), rs.min()))
axes[1].imshow(ysection,aspect='auto',extent = (0,480,rs.max(), rs.min()))
slm.zernike_coefficients = np.zeros(12)
for k in range(19, 26, 1):
    thnum = float(k)/10
    slm.zernike_coefficients = np.zeros(12)
    thimages = []
    lineprofiles = []
    for i in range(1000, 3000, 200):
        inner_edge_i = 800//18 #good
        sdtest = i/18.0
        sd = sdtest
        nrest = 384 - inner_edge_i
        radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
        slm.radial_blaze_function = radial_blaze_function
        slm.make_spots([test_spot[:4] + [0,0,1,0]])
        slm.update_gaussian_to_tophat(thnum, 2)
        images = []
        for j in range (5):
            images.append(snap())
        averaged = np.mean(images, axis=0)
        thimages.append(averaged)
        img = averaged
        plt.title(thnum)
        plt.plot(img[img.shape[0]//2,:])
        print(i)
        plt.imshow(img)
        plt.show()
        
        focus_stack(50,5, snap=snap)
        plt.show()


for k in range(18, 26, 1):
    thnum = float(k)/10
    slm.zernike_coefficients = np.zeros(12)
    thimages = []
    lineprofiles = []
    for i in range(800, 3000, 200):
        inner_edge_i = 800//18 #good
        sdtest = i/18.0
        sd = sdtest
        nrest = 384 - inner_edge_i
        radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
        slm.radial_blaze_function = radial_blaze_function
        slm.make_spots([test_spot[:4] + [0,0,1,0]])
        slm.update_gaussian_to_tophat(thnum, 2)
        images = []
        for j in range (5):
            images.append(snap())
        averaged = np.mean(images, axis=0)
        thimages.append(averaged)
        img = averaged
        plt.title(thnum)
        plt.plot(img[img.shape[0]//2,:])
        print(i)
        plt.imshow(img)
        plt.show()
        
        focus_stack(50,5, snap=snap)
        plt.show()


for k in range(22, 26, 1):
    thnum = float(k)/10
    slm.zernike_coefficients = np.zeros(12)
    thimages = []
    lineprofiles = []
    for i in range(800, 3000, 200):
        inner_edge_i = 800//18 #good
        sdtest = i/18.0
        sd = sdtest
        nrest = 384 - inner_edge_i
        radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
        slm.radial_blaze_function = radial_blaze_function
        slm.make_spots([test_spot[:4] + [0,0,1,0]])
        slm.update_gaussian_to_tophat(thnum, 2)
        images = []
        for j in range (5):
            images.append(snap())
        averaged = np.mean(images, axis=0)
        thimages.append(averaged)
        img = averaged
        plt.title(thnum)
        plt.plot(img[img.shape[0]//2,:])
        print(i)
        plt.imshow(img)
        plt.show()
        
        focus_stack(50,5, snap=snap)
        plt.show()


inner_edge_i = 800//18 #good
sdtest = 1600/18.0
sd = sdtest
nrest = 384 - inner_edge_i
radial_blaze_function = np.concatenate([np.ones(inner_edge_i),
                                        np.exp(-(np.arange(nrest))**2/2.0/sd**2)])
slm.radial_blaze_function = radial_blaze_function
slm.make_spots([test_spot[:4] + [0,0,1,0]])
slm.update_gaussian_to_tophat(2.5, 2)
images = []
for j in range (20):
    images.append(snap())
averaged = np.mean(images, axis=0)
thimages.append(averaged)
img = averaged

plt.imshow(img)
images = []
for j in range (20):
    images.append(snap())
averaged = np.mean(images, axis=0)
thimages.append(averaged)
img = averaged

plt.imshow(img)
images = []
for j in range (20):
    images.append(snap())
averaged = np.mean(images, axis=0)
thimages.append(averaged)
img = averaged

plt.imshow(img)
images = []
for j in range (20):
    images.append(snap())
averaged = np.mean(images, axis=0)
thimages.append(averaged)
img = averaged

plt.imshow(img)
 images = []
for j in range (20):
    images.append(snap())
averaged = np.mean(images, axis=0)
thimages.append(averaged)
img = averaged

plt.imshow(img)
 images = []
for j in range (20):
    images.append(snap())
averaged = np.mean(images, axis=0)
thimages.append(averaged)
img = averaged

plt.imshow(img)
 images = []
for j in range (20):
    images.append(snap())
averaged = np.mean(images, axis=0)
thimages.append(averaged)
img = averaged

plt.imshow(img)
 images = []
for j in range (20):
    images.append(snap())
averaged = np.mean(images, axis=0)
thimages.append(averaged)
img = averaged

plt.imshow(img)
 images = []
for j in range (20):
    images.append(snap())
averaged = np.mean(images, axis=0)
thimages.append(averaged)
img = averaged

plt.imshow(img)
 images = []
for j in range (20):
    images.append(snap())
averaged = np.mean(images, axis=0)
thimages.append(averaged)
img = averaged

plt.imshow(img)
 images = []
for j in range (20):
    images.append(snap())
averaged = np.mean(images, axis=0)
thimages.append(averaged)
img = averaged
